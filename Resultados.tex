Neste capítulo serão apresentados os resultados das pesquisas e implementações concebidas durante o período de realização deste trabalho. Como já dito no decorrer do texto, foram implementados um processador \py{}, em \hw{}, capaz de executar algoritmos escritos em \py{}, e um conversor, capaz de dar origem aos arquivos utilizados para inicialização das memórias.

Assim, aqui, poderão ser encontradas informações básicas que descrevem o desempenho de uma arquitetura física, tais como suas características gerais (seção \ref{result_carac_gerais} e os resultados das simulações realizadas (seção \ref{result_testes}.

Além disso, foi escolhido um algoritmo levemente mais complexo, o qual será abordado na seção \ref{result_algo_final}, para ser executado na arquitetura. 

O principal objetivo desse trabalho, como já foi dito anteriormente, é abrir portas para o desenvolvimento da máquina virtual \py{} completamente em \hw{}. Portanto, esperava-se que fosse possível realizar a implementação básica que servisse de ponto de partida e, assim sendo, pode-se considerar que o objetivo foi atingido. 

Com essa arquitetura, trabalhos futuros poderão se preocupar simplesmente em adicionar módulos responsáveis por suportar funcionalidades ainda não suportadas aqui até então. 

\section{Características Gerais}
\label{result_carac_gerais}

Para iniciar a análise dos resultados deste projeto, precisa-se introduzir as ferramentas utilizadas para a realização dos testes. Dados como frequência de operação e energia dissipada dependem diretamente do dispositivo utilizado como alvo de prototipação.

Dito isto, apresenta-se como ferramenta principal do desenvolvimento deste projeto o programa, desenvolvido pela empresa \textit{Altera}, chamado \textit{Quartus II}. A mesma empresa desenvolvedora do \sw{} também desenvolve sistemas FPGA e, como dispositivo alvo da prototipação, então, utilizou-se o FPGA \textit{Cyclone III} número EP3C25F324C6. 

Todo o projeto do \hw{} foi desenvolvido utilizando-se a linguagem de descrição de \hw{} chamada VHDL, que possibilitou a criação de cada componente individualmente e, posteriormente, a integração dos mesmos. Contudo, antes de iniciar-se o desenvolvimento com a linguagem, foi utilizada a ferramenta \textit{Logisim} para montar o \textit{register-transfer level}, comumente conhecido como RTL, o qual permitiu melhor visibilidade sobre os objetivos da arquitetura e, posteriormente, da implementação. 

Com essas definições, pode-se iniciar a análise dos resultados. Primeiramente, com análise da frequência máxima de operação encontrada (subseção \ref{result_freq}), após área ocupada (subseção \ref{result_carac_area}) e análises de energia e potência (subseção \ref{result_energia}). Além disso, esta seção ainda apresenta a análise das instruções implementadas, na subseção \ref{result_analise_instrucoes}, mostrando principalmente os cíclos de \clock{} necessários para sua execução.

\subsection{Frequência Máxima de Operação}
\label{result_freq}

Utilizando-se a mesma ferramenta utilizada para o desenvolvimento e posterior prototipação em FPGA, foi possível obter dados referentes à frequência e, por conseguinte, periodo de \clock{}, da arquitetura criada. 

Primeiramente, realizar-se-á uma comparação entre os resultados obtidos em uma implementação parcial desta mesma arquitetura, a qual não dispunha de, basicamente, nenhuma possibilidade simples modificar suas configurações básicas, tampouco de algumas instruções suportadas atualmente(mais informações sobre as diferenças entre a versão atual e a anterior podem ser encontradas no capítulo \ref{modificacoes}). Essa versão parcial possuia uma frequência máxima de operação de 89,29 MHz. 

Já a versão atual, organizada e com maior leque de instruções suportadas, teve leve queda dessa frequência, possuindo, atualmente, 78,44 MHz. Com esse valor, é possível definir, através da equação \ref{eq_periodo}, um período de \clock{} de 12,74 ns.

\begin{equation}
\label{eq_periodo}
T = 1/f
\end{equation}

Nos trabalhos correlatos analisados na seção \ref{trab_correlatos}, foi possível observar que, na maioria deles, as frequências de operação máximas definidas pelos projetistas giraram em torno dos 100 MHz. É possível que suas frequências máximas reais tenham sido levemente superior a isso, mas foram, provavelmente, arredondadas para um valor abaixo. 

A Figura \ref{img_freq} o resultado da análise de frequência realizada pela ferramenta \textit{Quartus} no decorrer da compilação. Nela pode ser objservada a frequência máxima sugerida pela ferramenta para que seja aplicada ao pino de entrada \textit{clk}, referente à entrada de \clock{} do sistema.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/resultados/freq.jpg}
\caption{Frequência máxima de operação gerada pela ferramenta \textit{Quartus}.}
\label{img_freq}
\end{figure}

\subsection{Área Ocupada em um FPGA}
\label{result_carac_area}

Ainda analisando dados obtidos através da ferramenta \textit{Quartus}, pode-se analisar, na Figura \ref{img_area}, as informações referentes à área ocupada em um FPGA. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/resultados/area.jpg}
\caption{Área ocupada em um FPGA gerada pela ferramenta \textit{Quartus}.}
\label{img_area}
\end{figure}

Na imagem, é possível perceber que como foi feita a utilização de cada componente dentro da arquitetura. Analisando ela, é possível identificar os seguintes componentes:

\begin{description}

	\item[Total de elementos lógicos:] A ferramenta retornou um valor de 751 elementos lógicos de um total suportado de 24.624 (caracterizando 3\% do total). 
	\item[Total de registradores:] Foi apresentado pela ferramenta um total de 366 registradores. Esse número é dado conforme o número de \bis{} dos componentes. Ou seja, um registrador, como descrito nos capítulos anteriores, com 12 \bis{}, gera 12 registradores lógicos nesses dados.
	\item[Total de pinos:] O valor total de pinos apresentado foi de 33 pinos de um total suportado de 216 (15\% da capacidade utilizada). Os pinos que a ferramenta se refere são os sinais que entram ou saem da entitade topo, ou seja, do processador. Cada pino apresentado corresponde a um \bi{}, tal como os registradores.
	\item[Total de \bis{} de memória:] Conforme o capítulo \ref{modificacoes} mostrou, houve um grande aumento em cada uma das memórias do processador. Esse valor representa o número de \bis{} de memória presentes nesta arquitetura, sendo ele 137.216 de um total suportado de 608.256 (caracterizando 23\% do total). Esse valor depende diretamente no número de \bis{} dos endereços das memórias, assim como o valor total de registradores também.
	\item[Multiplicadores de elementos de 9 \bis{} embarcados:] Foram utilizados 4 multiplicadores de elementos de 9 \bis{} de um total existente de 132.

\end{description}

Os valores acima apresentados como sendo a área ocupada do processador são válidos apenas se o número de \bis{} dos endereços das memórias for 12. Qualquer outro valor gera alterações significativas nos valores acima, principalmente no número de registradores e de \bis{} de memória.

\subsection{Análises de Energia e Potência}
\label{result_energia}

\subsection{Análises das Instruções Implementadas}
\label{result_analise_instrucoes}

Como foi explicado nos capítulos anteriores, para que cada instrução fosse executada corretamente, foram criadas máquinas de estados que, ao serem integradas, deram origem a uma máquina de estados maior. Contudo, o fluxo de execução de cada uma das instruções continuou previsível e, por isso, pode ser calculado o tempo necessário para a execução de cada instrução.

Assim sendo, criou-se o gráfico apresentado na Figura \ref{graf_ciclos_instr}, o qual apresenta o número de ciclos de \clock{} necessários para a execução de cada uma das instruções. Em alguns casos, principalmente com as instruções BINARY\_, não foi necessário apresentar todas as instruções individualmente, visto que todas elas seguem o mesmo fluxo de execução.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.5]{images/resultados/ciclos_instrucao.png}
\caption{Gráfico de barras com os ciclos de \clock{} necessários para a execução de cada instrução.}
\label{graf_ciclos_instr}
\end{figure}

Assim, com a análise do gráfico, é possível perceber que instruções que acessam a memória e instruções que fazem mais de uma leitura na pilha utilizam maior número de ciclos para serem executadas. É possível, por exemplo, comparar as instruções BINARY\_ com as UNARY\_, sendo que a diferença delas, como o gráfico mostra, é de 2 ciclos. Esses dois ciclos são os responsável pela leitura do segundo dado da pilha, tendo em vista que essa é a única diferença entre as duas instruções.

A instrução COMPARE\_OP está na liderança no que diz respeito à quantidade de ciclos necessários para sua execução. O motivo, para isso é que tal instrução não salva nenhum dado na pilha após ser executada. Algo que deveria torná-la mais rápida é o que a torna mais lenta e o motivo para isso pode ser visto em uma comparação com as instruções BINARY\_. O fluxo de execução de ambas as instruções é basicamente o mesmo: ler 2 dados da pilha e executar na ULA. 

Após passar pela ULA, as instruções BINARY\_ salvam o dado novamente na pilha, não sendo necessário, portanto, decrementar o ponteiro de \tos{} duas vezes. Já a instrução COMPARE\_OP, por ler dois dados e não salvar nada na pilha após, necessita executar dois decrementos no valor do ponteiro TOS, algo que, como visto na comparação entre BINARY\_ e UNARY\_, custa exatamente 2 ciclos de \clock{}. O ciclo extra decorre do fato de a ULA precisar esperar até salvar o resultado no \textit{regComp}, não podendo serem modificadas suas entradas. O apêndice \ref{ap_me_binary} apresenta a máquina de estados da instrução COMPARE\_OP, onde pode ser visto que o estado "co7" apenas realiza o salvamento no registrador regComp.

Para concluir, pode-se perceber que instruções relacionadas a desvios e carregamento de dados externos para a pilha são extremamente rápidas de serem executadas, como já era esperado. O ciclo de erros é a máquina de estados parcial mais rápida de ser executada, com apenas 3 estados.

\section{Simulações}
\label{result_testes}

Ao se implementar uma arquitetura em \hw{}, é preciso que sejam feitas simulações capazes de validar a execução da mesma. No caso da arquitetura desenvolvida neste projeto, as simulações se baseiam em algoritmos binários gerados através da ferramenta \textit{pyConv}, apresentada no capítulo \ref{conversor}.

Os algoritmo gerados pelo conversor dependem exclusivamente do algoritmo digitado como entrada dele. A entrada de instruções ocorre digitando-se as instruções da \pvm{} (suas palavras chaves). Tais instruções são geradas diretamente pela ferramenta \textit{Disassembler} e podem ser copiadas diretamente para o \textit{pyConv}.

O código binário gerado, por sua vez, é baseado na tabela \ref{table_opCode}. Nela, é possível verificar os códigos binários para cada uma das instruções suportadas no processador.

\input{tables/resultados/table_binary_code}

Contudo, só a tabela \ref{table_opCode} não é suficiente para todas as funcionalidades, visto que a instrução COMPARE\_OP recebe como argumento o código binário de uma operação de comparação. Então, criou-se a tabela \ref{table_comp}, que apresenta os códigos binários que devem ser utilizados como argumento da operação de comparação.

\input{tables/resultados/table_compareOp}

Feita essa apresentação prévia de informações, as subseções seguintes apresentarão simulações realizadas na arquitetura. Para isso, utilizou-se a ferramenta \textit{Modelsim}. Primeiramente, apresentou-se uma simulação mostrando o funcionamento de todas as operações BINARY\_ e UNARY\_ (subseção \ref{result_arith}. Após, foram apresentados resultados de simulações com algoritmos de \textit{loop} (subseção \ref{result_loop}), chamada e retorno de funções (subseção \ref{result_func}) e comparações múltiplas com desvios variádos (subseção \ref{result_algoritmo_maior}.

\subsection{\textbf{TESTE 1:} Instruções BINARY\_ e UNARY\_}
\label{result_arith}


\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste1.jpg}
\caption{Código \textit{Assembly} do teste 1.}
\label{img_ass1}
\end{figure}


\begin{figure}[htp]
\centering
\includegraphics[scale=0.4]{images/resultados/Simulacoes/pizza_teste1.png}
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 1.}
\label{img_graf1}
\end{figure}

%\begin{figure}[htp]
%\centering
%\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste1.jpg}
%\caption{Resultado da simulação do teste 1.}
%\label{img_final1}
%\end{figure}

\subsection{\textbf{TESTE 2:} Algoritmo com \textit{Loop}}
\label{result_loop}

O teste número 2 consiste na execução de um \textit{loop}, o qual vai de zero a 10. A cada ciclo de repetição, como mostra a Figura \ref{img_ass2} entre as linhas 3 e 15, são executadas instruções de carregamento de dados da memória, comparação e operação aritmética de soma. Nessa Figura, é possível perceber o código \as{} gerado pelo \textit{pyConv} no mesmo formato já apresentado na subseção \ref{result_arith}.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste2.jpg}
\caption{Código \textit{Assembly} do teste 2.}
\label{img_ass2}
\end{figure}

O código \as{} é, então, carregado para a memória de instruções e aparece no formato apresentado na Figura \ref{img_bin2}. Para todos os testes existe esse processo, contudo tal imagem só será mostrada aqui para evitar repetições desnecessárias.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/resultados/Simulacoes/memInstr_teste2.jpg}
\caption{Código binário do teste 2 carregado para a memória de instruções.}
\label{img_bin2}
\end{figure}

A Figura \ref{img_graf2} apresenta o gráfico mostrando a proporção das classes de instruções executadas nesse teste. Essa informação é importante para ser gerada uma estimativa do tempo de execução esperado. É expressivo que a maior quantidade de instruções, 56,8\%, são de leitura ou acesso à memória. Nesse valor também é incluído a entrada de constantes internas. Contudo, como já vimos anteriormente, instruções aritméticas e de comparação precisam de bastante tempo para serem executadas. 

O fato de instruções relacionadas a desvios aparecerem em segunda posição nas que mais aparecem não incrementa praticamente nada no tempo de execução, visto que essas instruções são as mais rápidas de serem executadas.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.4]{images/resultados/Simulacoes/pizza_teste2.png}
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 2.}
\label{img_graf2}
\end{figure}

Com a análise das instruções utilizadas para a realização desta simulação, foi possível estimar o tempo como sendo 11.457 ns. Ao executar a simulação, percebeu-se que houve um pequeno incremento no tempo teórico calculado, obtendo-se um tempo de 11.514 ns.

A Figura \ref{img_final2} apresenta a memória externa com os resultados da execução. É possível perceber o valor 10, em binário, salvo na posição 0, a qual foi destinada para ser o contador do \textit{loop}. O valor 255 aparece na posição 1, o qual é executado após a finalização do \textit{loop}.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste2.jpg}
\caption{Resultado da simulação do teste 2.}
\label{img_final2}
\end{figure}

\subsection{\textbf{TESTE 3:} Chamada e Retorno de Funções}
\label{result_func}

O teste 3 consiste na implementação de uma operação aritmética com o resultado retornado de uma função. Para isso, primeiramente carrega-se uma constante para ser o operando 1. Então, chama-se uma função que carrega dois operandos, executa uma subtração e retorna o valor. 

É então que o valor retornado é multiplicado pelo valor carregado previamente e, o resultado, salvo na memória externa. A Figura \ref{img_ass3} apresenta o código \as{} deste algoritmo.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste3.jpg}
\caption{Código \textit{Assembly} do teste 3.}
\label{img_ass3}
\end{figure}

Analisando o algoritmo apresentado, foi possível gerar o gráfico apresentado na Figura \ref{img_graf3}, que mostra a proporção das classes de instruções utilizadas. O tempo teórico calculado para essa execução foi de 921 ns. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.4]{images/resultados/Simulacoes/pizza_teste3.png}
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 3.}
\label{img_graf3}
\end{figure}

Após a execução, observou-se que o tempo de execução foi levemente menor que o teórico, sendo este 894 ns. A Figura \ref{img_final3} apresenta o valor final, 30, salvo na posição zero da memória externa. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste3.jpg}
\caption{Resultado da simulação do teste 3.}
\label{img_final3}
\end{figure}

\subsection{\textbf{TESTE 4:} Algoritmo com instruções Variáveis}
\label{result_algoritmo_maior}

Para a última simulação, a de número 4, foi criado um algoritmo com o objetivo único de executar a maior variedade de instruções possível. Assim, como pode ser visto na Figura \ref{img_ass4}, o algoritmo executa diversos desvios, operações aritméticas e até uma comparação. Ele pode ser considerado como um agrupamento dos três testes feitos anteriormente.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste4.jpg}
\caption{Código \textit{Assembly} do teste 4.}
\label{img_ass4}
\end{figure}

Seu gráfico de proporção entre as classes de instruções executadas é apresentado na Figura \ref{img_graf4}. Nele, percebe-se que a maior parte das instruções são de acesso à memória. Os devios, que aparecem em segundo, não geram tanto incremento no tempo de execução quanto as operações aritméticas, em terceiro.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.4]{images/resultados/Simulacoes/pizza_teste4.png}
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 4.}
\label{img_graf4}
\end{figure}

O resultado de todas essas execuções podem ser vistos na Figura \ref{img_final4}. O valor salvo na posição 0 corresponde ao valor inserido na primeira posição da memória de instruções. O valor da posição 1 corresponde ao resultado da multiplicação de 15 (valor da posição 0) por 2 (carregado na linha 52), resultando 30. 

Nas posições 2 e 3, respectivamente, aparecem o resultado da soma da posição 0 com a 1 e o resultado de 20 somado com 120 (valor retornado da função que soma 100 e 20).

\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste4.jpg}
\caption{Resultado da simulação do teste 4.}
\label{img_final4}
\end{figure}