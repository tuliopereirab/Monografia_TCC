Neste capítulo serão apresentados os resultados das pesquisas e implementações concebidas durante o período de realização deste trabalho. Como já dito no decorrer do texto, foram implementados um processador \py{}, em \hw{}, capaz de executar algoritmos escritos em \py{}, e um conversor, capaz de dar origem aos arquivos utilizados para inicialização das memórias.

Assim, aqui, poderão ser encontradas informações básicas que descrevem o desempenho de uma arquitetura física, tais como suas características gerais (Seção \ref{result_carac_gerais} e os resultados das simulações realizadas (Seção \ref{result_testes}).

%Além disso, foi escolhido um algoritmo levemente mais complexo, o qual será abordado na Seção \ref{result_algo_final}, para ser executado na arquitetura. 

O principal objetivo desse trabalho, como também já foi dito anteriormente, é abrir portas para o desenvolvimento da máquina virtual \py{} completamente em \hw{}. Portanto, esperava-se que fosse possível realizar uma implementação básica que servisse de ponto de partida. %e, assim sendo, pode-se considerar que o objetivo foi atingido. 

Com essa arquitetura, trabalhos futuros poderão se preocupar simplesmente em adicionar módulos responsáveis por suportar funcionalidades ainda não suportadas nesta versão. 

\section{Características Gerais}
\label{result_carac_gerais}

Para iniciar a análise dos resultados deste projeto, precisa-se introduzir as ferramentas utilizadas para a realização dos testes. Dados como frequência de operação e potência dissipada dependem diretamente do dispositivo utilizado como alvo de prototipação.

Dito isto, apresenta-se como ferramenta principal do desenvolvimento deste projeto a ferramenta, desenvolvida pela empresa \textit{Altera}, chamada \textit{Quartus II}. A mesma empresa desenvolvedora do \sw{} também desenvolve sistemas FPGA e, como dispositivo alvo da prototipação, então, utilizou-se o FPGA \textit{Cyclone III} número EP3C25F324C6. A justificativa para o uso deste dispositivo específico é o fato da Universidade Federal do Pampa possuir diversos deles e deixá-los disponíveis para a utilização dos alunos.

Todo o projeto do \hw{} foi desenvolvido utilizando-se a linguagem de descrição de \hw{} chamada VHDL, que possibilitou a criação de cada componente individualmente e, posteriormente, a integração dos mesmos. Contudo, antes de iniciar-se o desenvolvimento com a linguagem, foi utilizada a ferramenta \textit{Logisim} para montar o \textit{register-transfer level}, comumente conhecido como RTL, o qual permitiu melhor visibilidade sobre os objetivos da arquitetura e, posteriormente, da implementação. 

Com essas definições, pode-se iniciar a análise dos resultados. Primeiramente, com análise da frequência máxima de operação encontrada (subseção \ref{result_freq}), após área ocupada (subseção \ref{result_carac_area}) e análises de potência (subseção \ref{result_energia}). Além disso, esta seção ainda apresenta a análise das instruções implementadas, na subseção \ref{result_analise_instrucoes}, mostrando principalmente os ciclos de \clock{} necessários para sua execução. 

\subsection{Frequência Máxima de Operação}
\label{result_freq}

Utilizando-se a mesma ferramenta utilizada para o desenvolvimento e posterior prototipação em FPGA, foi possível obter dados referentes à frequência e, por conseguinte, periodo de \clock{}, da arquitetura criada. 

Primeiramente, realizar-se-á uma comparação entre os resultados obtidos em uma implementação parcial desta mesma arquitetura, a qual não dispunha de, basicamente, nenhuma possibilidade simples modificar suas configurações básicas, tampouco de algumas instruções suportadas atualmente (mais informações sobre as diferenças entre a versão atual e a anterior foram apresentadas no Capítulo \ref{modificacoes}). Essa versão parcial possuía uma frequência máxima de operação de 89,29 MHz. 

Já a versão atual, organizada e com maior leque de instruções suportadas, teve uma leve queda no valor da frequência, possuindo, atualmente, 84,35 MHz. Com esse valor, é possível definir, através da Equação \ref{eq_periodo}, um período de \clock{} de 11,85 nanosegundos (ns).

\begin{equation}
\label{eq_periodo}
T = 1/f
\end{equation}

Nos trabalhos correlatos analisados na Seção \ref{trab_correlatos}, foi possível observar que, na maioria deles, as frequências de operação máximas definidas pelos projetistas giraram em torno dos 100 MHz. É possível que suas frequências máximas reais tenham sido levemente superior a isso, mas foram, provavelmente, arredondadas para um valor abaixo. 

A Figura \ref{img_freq} apresenta o resultado da análise de frequência realizada pela ferramenta \textit{Quartus} no decorrer da compilação. Nela pode ser observada a frequência máxima sugerida pela ferramenta para que seja aplicada ao pino de entrada \textit{clk}, referente à entrada de \clock{} do sistema.

\begin{figure}[]
\caption{Frequência máxima de operação gerada pela ferramenta \textit{Quartus}.}
\centerline{\includegraphics[scale=0.7]{images/resultados/freq.jpg}}
\fonte{Autor (2019)}
\label{img_freq}
\end{figure}

É importante ressaltar que a frequência apresentada aqui não inclui a operação de divisão na ULA. Ao realizar-se testes adicionando-a ao projeto, houve queda da frequência apresentada até 13 MHz, algo inaceitável. Acredita-se que tal problema decorre do fato de o dispositivo utilizado para prototipação não possuir nenhum divisor lógico nativo, apenas multiplicadoR. Assim, para realizar uma divisão, utilizam-se outros métodos que não são eficazes e tornam a operação lenta, impactando na frequência final de operação de todo o sistema.

\subsection{Área Ocupada em um FPGA}
\label{result_carac_area}

Ainda analisando dados obtidos através da ferramenta \textit{Quartus}, pode-se analisar, na Figura \ref{img_area}, as informações referentes à área ocupada no FPGA \textit{Cyclone III} apresentado. 

\begin{figure}[]
\caption{Área ocupada em um FPGA gerada pela ferramenta \textit{Quartus}.}
\centerline{\includegraphics[scale=0.7]{images/resultados/area.jpg}}
\fonte{Autor (2019)}
\label{img_area}
\end{figure}

Na imagem, é possível perceber que como foi feita a utilização de cada componente dentro da arquitetura. Analisando ela, é possível identificar os seguintes componentes:

\begin{description}

	\item[Total de elementos lógicos:] A ferramenta retornou um valor de 728 elementos lógicos de um total suportado de 24.624 (caracterizando 3\% do total). 
	\item[Total de registradores:] Foi apresentado pela ferramenta um total de 366 registradores. Esse número é dado conforme o número de \bis{} dos componentes, ou seja, um registrador, como descrito nos capítulos anteriores, com 12 \bis{}, gera 12 registradores lógicos nesses dados.
	\item[Total de pinos:] O valor total de pinos apresentado foi de 33 pinos de um total suportado de 216 (15\% da capacidade utilizada). Os pinos que a ferramenta se refere são os sinais que entram ou saem da entitade topo, ou seja, do processador. Cada pino apresentado corresponde a um \bi{}, tal como os registradores.
	\item[Total de \bis{} de memória:] Conforme o Capítulo \ref{modificacoes} mostrou, houve um grande aumento em cada uma das memórias do processador. Esse valor representa o número de \bis{} de memória presentes nesta arquitetura, sendo ele 137.216 de um total suportado de 608.256 (caracterizando 23\% do total). Esse valor depende diretamente no número de \bis{} dos endereços das memórias, assim como o valor total de registradores também.
	\item[Multiplicadores de elementos de 9 \bis{} embarcados:] Foram utilizados 4 multiplicadores de elementos de 9 \bis{} de um total existente de 132.

\end{description}

Os valores acima apresentados como sendo a área ocupada do processador são válidos apenas se o número de \bis{} dos endereços das memórias for igual a 12. Qualquer outro valor gera alterações significativas nos valores acima, principalmente no número de registradores e de \bis{} de memória.

\subsection{Análises de Potência}
\label{result_energia}

Nos dias atuais, existe uma grande atenção voltada para o consumo energético de todos os sistemas que necessitam de energia. Então, para todos os projetos a serem desenvolvidos futuramente, é esperado que um dos objetivos principais seja obter grande poder computacional dissipando-se menos potência.

Isso se deve, principalmente, ao fato de que a maioria dos dispositivos estão sendo criados para funcionarem com baterias e, portanto, poderem ser levados para qualquer lugar. Assim, realizou-se uma análise de potência dissipada do processador desenvolvido neste trabalho.

A Figura \ref{img_result_energia} apresenta os dados retornados pela ferramenta \textit{Quartus II}. Dentro dela, existe a ferramenta chamada \textit{PowerPlay Power Analyzer}, a qual realiza, juntamente com o auxílio da ferramenta \textit{Modelsim}, levantamento de dados sobre a potência dissipada durante as simulações.

\begin{figure}[]
\caption{Análise de potência gerada pela ferramenta \textit{Quartus}.}
\centerline{\includegraphics[scale=0.9]{images/resultados/energia.jpg}}
\fonte{Autor (2019)}
\label{img_result_energia}
\end{figure}

Para a realização deste teste, configurou-se o \textit{Quartus} de forma que ele gerasse um arquivo no formato \textit{.vcd}, o qual é utilizado pelo \textit{Modelsim} para analisar dados energéticos durante simulações. 

Conforme mostra a Figura \ref{img_result_energia}, a potência térmica total dissipada foi de 132,56 miliwatts (mW). Esse valor é a soma das potências dinâmica (30,07 mW), estática (81,20 mW) e dos pinos de entrada (21,28 mW). A diferença entre os dois é, basicamente, que a potência dinâmica indica a dissipação quando os transistores estão em funcionamento (estado \textit{"on"}), enquanto a estática indica que eles estão desligados (estado \textit{"off"}).

Para estes testes, a ferramenta considerou como temperatura ambiente 26,6 ºC e 1,20 V de tensão interna à arquitetura, enquanto a tensão nos pinos de entrada e saída foi considerada 2,5 V. A temperatura é definida como 26,6 ºC para que sejam feitas análises do sistema em temperaturas consideradas médias, não sendo calor extremo nem frio extremo. Temperaturas próximas a essa podem ser encontradas tanto em cidades consideradas quentes quanto frias, o que permite que o teste seja válido para o maior número de lugares possível.

Além disso, a ferramenta ainda indica a memória de instruções (\textit{memInstr}) como o componente que mais dissipa potência (6,34 mW) seguida pela pilha (4,03 mW). A unidade de controle é responsável por dissipar 1,90 mW, sendo classificada na quarta posição. A Figura \ref{img_energia_ranking} apresenta os quinze componentes que mais consomem energia. 

\begin{figure}[]
\caption{\textit{Ranking} dos componentes conforme suas potências.}
\centerline{\includegraphics[scale=0.7]{images/resultados/energia_ranking.jpg}}
\fonte{Autor (2019)}
\label{img_energia_ranking}
\end{figure}

\subsection{Análises das Instruções Implementadas}
\label{result_analise_instrucoes}

Como foi explicado nos capítulos anteriores, para que cada instrução fosse executada corretamente, foram criadas máquinas de estados que, ao serem integradas, deram origem a uma máquina de estados maior. Contudo, o fluxo de execução de cada uma das instruções continuou previsível e, por isso, pode ser calculado o tempo necessário para a execução de cada instrução.

Assim sendo, criou-se o gráfico apresentado na Figura \ref{graf_ciclos_instr}, o qual apresenta o número de ciclos de \clock{} necessários para a execução de cada uma das instruções. Em alguns casos, principalmente com as instruções BINARY\_, não foi necessário apresentar todas as instruções individualmente, visto que todas elas seguem o mesmo fluxo de execução.

\begin{figure}[]
\caption{Gráfico de barras com os ciclos de \clock{} necessários para a execução de cada instrução.}
\centerline{\includegraphics[scale=0.7]{images/resultados/ciclos_instrucao.png}}
\fonte{Autor (2019)}
\label{graf_ciclos_instr}
\end{figure}

Assim, com a análise do gráfico, é possível perceber que instruções que acessam a memória e instruções que fazem mais de uma leitura na pilha utilizam maior número de ciclos para serem executadas. É possível, por exemplo, comparar as instruções BINARY\_ com as UNARY\_, sendo que a diferença delas, como o gráfico mostra, é de 2 ciclos. Esses dois ciclos são os responsável pela leitura do segundo dado da pilha, tendo em vista que essa é a única diferença entre as duas instruções.

A instrução COMPARE\_OP está na liderança no que diz respeito à quantidade de ciclos necessários para sua execução. O motivo para isso é que tal instrução não salva nenhum dado na pilha após ser executada. Algo que deveria torná-la mais rápida é o que a torna mais lenta e o motivo para isso pode ser visto em uma comparação com as instruções BINARY\_. 

O fluxo de execução de ambas as instruções é basicamente o mesmo: ler 2 dados da pilha e executar na ULA. Após passar pela ULA, as instruções BINARY\_ salvam o dado novamente na pilha, não sendo necessário, portanto, decrementar o ponteiro de \tos{} duas vezes. Já a instrução COMPARE\_OP, por ler dois dados e não salvar nada na pilha, necessita executar dois decrementos no valor do ponteiro TOS, algo que, como visto na comparação entre BINARY\_ e UNARY\_, custa exatamente 2 ciclos de \clock{}. O ciclo extra decorre do fato de a ULA precisar esperar até salvar o resultado no \textit{regComp}, não podendo serem modificadas suas entradas. O apêndice \ref{ap_me_binary} apresenta a máquina de estados da instrução COMPARE\_OP, onde pode ser visto que o estado \textit{"co7"} apenas realiza o salvamento no registrador \textit{regComp}.

Para concluir, pode-se perceber que instruções relacionadas a desvios e carregamento de dados externos para a pilha são extremamente rápidas de serem executadas, como já era esperado. O ciclo de erros é a máquina de estados parcial mais rápida de ser executada, com apenas três estados e, portanto, utilizando três ciclos de \clock{}.

\section{Simulações}
\label{result_testes}

Ao se implementar uma arquitetura em \hw{}, é preciso que sejam feitas simulações capazes de validar a execução da mesma. No caso da arquitetura desenvolvida neste projeto, as simulações se baseiam em algoritmos binários gerados através da ferramenta \textit{pyConv}, apresentada no Capítulo \ref{conversor}.

Os algoritmos gerados pelo conversor dependem exclusivamente do algoritmo digitado como entrada dele. A entrada de instruções ocorre digitando-se as instruções da \pvm{} (suas palavras chaves). Tais instruções são geradas pela ferramenta \textit{Disassembler} e podem ser copiadas para o \textit{pyConv}.

O código binário gerado, por sua vez, é baseado na tabela \ref{table_opCode}. Nela, é possível verificar os códigos binários para cada uma das instruções suportadas no processador.

\input{tables/resultados/table_binary_code}

Contudo, só a tabela \ref{table_opCode} não é suficiente para todas as funcionalidades, visto que a instrução COMPARE\_OP recebe como argumento o código binário de uma operação de comparação. Então, criou-se a tabela \ref{table_comp}, que apresenta os códigos binários que devem ser utilizados como argumento da operação de comparação.

\input{tables/resultados/table_compareOp}

Feita essa apresentação de informações básicas, as subseções seguintes apresentam simulações realizadas na arquitetura. Para isso, utilizou-se a ferramenta \textit{Modelsim}. Primeiramente, pode ser encontrada uma simulação mostrando o funcionamento de todas as operações BINARY\_ e UNARY\_ (subseção \ref{result_arith}. Após, foram apresentados resultados de simulações com algoritmos de \textit{loop} (subseção \ref{result_loop}), chamada e retorno de funções (subseção \ref{result_func}) e um algoritmo variado, contendo comparações e desvios (subseção \ref{result_algoritmo_maior}.

\subsection{\textbf{TESTE 1:} Instruções BINARY\_ e UNARY\_}
\label{result_arith}

A primeira simulação realizada foi responsável por executar um algoritmo de teste para todas as operações binárias e unárias do processador. O código \as{} deste algoritmo pode ser visto na Figura \ref{img_ass1}. A única operação que não aparece no algoritmo e, portanto, sendo considerada a exceção, é a de divisão (instrução BINARY\_DIVIDE). Embora ela esteja funcional, sua utilização gera impacto de grandes proporções na frequência, conforme dito na subseção \ref{result_freq}, causando significativo impacto no tempo de execução.

\begin{figure}[]
\caption{Código \textit{Assembly} do teste 1.}
\centerline{\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste1.jpg}}
\fonte{Autor (2019)}
\label{img_ass1}
\end{figure}

Antes de realizar a simulação, fez-se uma análise no algoritmo criado com o objetivo de verificar as classes de instruções implementadas e fazer uma estimativa de tempo teórico de execução. Como pode ser visto na Figura \ref{img_graf1}, a classe de instruções que mais aparece neste algoritmo é a escrita e leitura na memória, caracterizando 78,1\%. 

\begin{figure}[h]
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 1.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/pizza_teste1.png}}
\fonte{Autor (2019)}
\label{img_graf1}
\end{figure}

Este fato é importante quando calcula-se o tempo teórico para a execução, visto que instruções de acesso à memória utilizam tempo considerável de execução e causam grande impacto quando aparece diversas vezes. O tempo teórico encontrado foi de 4.171 ns, enquanto o tempo prático observado foi de 4.638 ns.

Para fazer a verificação de que o algoritmo funcionou corretamente, analisou-se a memória externa, a qual recebeu cada um dos resultados das operações realizadas. A Figura \ref{img_final1} mostra uma imagem do trecho de memória onde os resultados foram salvos. As posições zero e 1, ou seja, as que estão na linha mais abaixo e à direita, receberam os operandos das operações. Eles são, respectivamente, 15 e 2.

Já as outras posições, na ordem em que aparecem, receberam as operações: soma, subtração, multiplicação, AND, OR, XOR, NOT do operando 1 e NOT do operando 2. Pode-se observar que os valores binários apresentados correspondem aos resultados esperados para cada uma das operações.

\begin{figure}[]
\caption{Resultado da simulação do teste 1.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste1.jpg}}
\fonte{Autor (2019)}
\label{img_final1}
\end{figure}

\subsection{\textbf{TESTE 2:} Algoritmo com \textit{Loop}}
\label{result_loop}

O teste número 2 consiste na execução de um \textit{loop}, o qual vai de zero a 10. A cada ciclo de repetição, como mostra a Figura \ref{img_ass2} entre as linhas 3 e 15, são executadas instruções de carregamento de dados da memória, comparação e operação aritmética de soma. Nessa Figura, é possível perceber o código \as{} gerado pelo \textit{pyConv} no mesmo formato já apresentado na subseção \ref{result_arith}.

\begin{figure}[]
\caption{Código \textit{Assembly} do teste 2.}
\centerline{\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste2.jpg}}
\fonte{Autor (2019)}
\label{img_ass2}
\end{figure}

O código \as{} é, então, carregado para a memória de instruções e aparece no formato apresentado na Figura \ref{img_bin2}. Para todos os testes existe esse processo, contudo tal imagem só será mostrada aqui para evitar repetições desnecessárias.

\begin{figure}[]
\caption{Código binário do teste 2 carregado para a memória de instruções.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/memInstr_teste2.jpg}}
\fonte{Autor (2019)}
\label{img_bin2}
\end{figure}

A Figura \ref{img_graf2} apresenta o gráfico mostrando a proporção das classes de instruções executadas nesse teste. Essa informação é importante para ser gerada uma estimativa do tempo de execução esperado. É expressivo que a maior quantidade de instruções, 56,8\%, são de leitura ou acesso à memória. Nesse valor também é incluído a entrada de constantes internas. Contudo, como já vimos anteriormente, instruções aritméticas e de comparação precisam de bastante tempo para serem executadas. 

O fato de instruções relacionadas a desvios aparecerem em segunda posição nas que mais aparecem não incrementa praticamente nada no tempo de execução, visto que essas instruções são as mais rápidas de serem executadas.

\begin{figure}[]
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 2.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/pizza_teste2.png}}
\fonte{Autor (2019)}
\label{img_graf2}
\end{figure}

Com a análise das instruções utilizadas para a realização desta simulação, foi possível estimar o tempo como sendo 9.800 ns. Ao executar a simulação, percebeu-se que houve um pequeno incremento no tempo teórico calculado, obtendo-se um tempo de 11.514 ns.

A Figura \ref{img_final2} apresenta a memória externa com os resultados da execução. É possível perceber o valor 10, em binário, salvo na posição 0, a qual foi destinada para ser o contador do \textit{loop}. O valor 255 aparece na posição 1, o qual é executado após a finalização do \textit{loop}.

\begin{figure}[]
\caption{Resultado da simulação do teste 2.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste2.jpg}}
\fonte{Autor (2019)}
\label{img_final2}
\end{figure}

\subsection{\textbf{TESTE 3:} Chamada e Retorno de Funções}
\label{result_func}

O teste 3 consiste na implementação de uma operação aritmética com o resultado retornado de uma função. Para isso, primeiramente carrega-se uma constante para ser o operando 1. Então, chama-se uma função que carrega dois operandos, executa uma subtração e retorna o valor. 

É então que o valor retornado é multiplicado pelo valor carregado previamente e, o resultado, salvo na memória externa. A Figura \ref{img_ass3} apresenta o código \as{} deste algoritmo.

\begin{figure}[]
\caption{Código \textit{Assembly} do teste 3.}
\centerline{\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste3.jpg}}
\fonte{Autor (2019)}
\label{img_ass3}
\end{figure}

Analisando o algoritmo apresentado, foi possível gerar o gráfico apresentado na Figura \ref{img_graf3}, que mostra a proporção das classes de instruções utilizadas. O tempo teórico calculado para essa execução foi de 782 ns. 

\begin{figure}[]
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 3.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/pizza_teste3.png}}
\fonte{Autor (2019)}
\label{img_graf3}
\end{figure}

Após a execução, observou-se que o tempo de execução foi maior que o teórico, sendo este 894 ns. A Figura \ref{img_final3} apresenta o valor final, 30, salvo na posição zero da memória externa. 

\begin{figure}[h]
\caption{Resultado da simulação do teste 3.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste3.jpg}}
\fonte{Autor (2019)}
\label{img_final3}
\end{figure}

\subsection{\textbf{TESTE 4:} Algoritmo com instruções Variáveis}
\label{result_algoritmo_maior}

Para a última simulação, a de número 4, foi criado um algoritmo com o objetivo único de executar a maior variedade de instruções possível. Assim, como pode ser visto na Figura \ref{img_ass4}, o algoritmo executa diversos desvios, operações aritméticas e até uma comparação. Ele pode ser considerado como um agrupamento dos três testes feitos anteriormente.

\begin{figure}[]
\caption{Código \textit{Assembly} do teste 4.}
\centerline{\includegraphics[scale=0.7]{images/resultados/Simulacoes/assembly_teste4.jpg}}
\fonte{Autor (2019)}
\label{img_ass4}
\end{figure}

Seu gráfico de proporção entre as classes de instruções executadas é apresentado na Figura \ref{img_graf4}. Nele, percebe-se que a maior parte das instruções são de acesso à memória. Os devios, que aparecem em segundo, não geram tanto incremento no tempo de execução quanto as operações aritméticas, em terceiro.

\begin{figure}[h]
\caption{Gráfico com a proporção das classes de instruções utilizadas para o teste 4.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/pizza_teste4.png}}
\fonte{Autor (2019)}
\label{img_graf4}
\end{figure}

O resultado de todas essas execuções podem ser vistos na Figura \ref{img_final4}. O valor salvo na posição 0 corresponde ao valor inserido na primeira posição da memória de instruções. O valor da posição 1 corresponde ao resultado da multiplicação de 15 (valor da posição 0) por 2 (carregado na linha 52), resultando 30. 

Nas posições 2 e 3, respectivamente, aparecem o resultado da soma da posição 0 com a 1 e o resultado de 20 somado com 120 (valor retornado da função que soma 100 e 20).

O tempo teórico calculado para a execução deste algoritmo foi de 2.548 ns, enquanto o tempo observado na prática foi de 2.874 ns.

\begin{figure}[]
\caption{Resultado da simulação do teste 4.}
\centerline{\includegraphics[scale=0.6]{images/resultados/Simulacoes/memExt_final_teste4.jpg}}
\fonte{Autor (2019)}
\label{img_final4}
\end{figure}

\section{Prototipação FPGA}

Para a conclusão deste projeto e atender ao último objetivo proposto, realizou-se a prototipação em um FPGA do processador. Para isso, utilizou-se a ferramenta \textit{Quartus II}, capaz de montar a arquitetura escrita em VHDL diretamente no \textit{chip} do FPGA, fazendo-a ser executada em \hw{}.

Primeiramente, foram realizadas algumas modificações de baixa complexidade na arquitetura. Dentre essas modificações, estava a modificação dos nomes dos pinos de entrada e saída do FPGA e, além disso, a conexão de alguns sinais internos com sinais externos.

A primeira modificação se fez necessária visto que o FPGA reconhece nomes padrões de pinos e os conecta automaticamente com seus pinos físicos. O grande exemplo dessa modificação foi o sinal de \clock{}, o qual precisou receber o nome de "\textit{osc\_clk}". 

Já referente à segunda modificação, para verificar o resultado da simulação, utilizou-se os \textit{leds} do FPGA para apresentar os quatro últimos \bis{} do registrador PC ou os quatro últimos \bis{} do topo ta pilha. Com essa possibilidade de ver o que foi executado, foram feitas simulações em paralelo com a ferramenta \textit{Modelsim} para que os resultados fossem comparados.

Primeiramente, com o valor de PC sendo apresentado pelos \textit{leds}, executou-se uma simulação no \textit{Modelsim} e observou-se o valor final de PC. O motivo desta técnica ser utilizada é o fato de que o valor de PC só é alterado se o processo passou por todos os estados da máquina de estados. E, se isso aconteceu, é porque a instrução foi executada com sucesso.

Para o segundo método, utilizando o \tos{} nos \textit{leds}, realizou-se a mesma simulação no \textit{Modelsim} e comparou-se o \tos{} final da simulação com o encontrado no FPGA. Em todos os casos, foi possível verificar que os dados eram compatíveis.

Uma grande dificuldade encontrada na prototipação FPGA foi o fato de a ferramenta \textit{Quartus} não disponibilizar acesso fácil à memória interna do dispositivo após a simulação. É possível carregar a memória ao inicializá-lo, mas não acessá-la facilmente após finalizar a execução.