Ao final deste trabalho, é possível perceber que todos os objetivos apresentados no início dele foram satisfeitos. Assim, é possível afirmar que existe uma arquitetura, criada em VHDL, capaz de executar algoritmos escritos em \py{}. Essa arquitetura recebe como entrada o código \as{} da linguagem \py{} no formato binário.

Tal código binário é gerado através de um conversor, chamado de \textit{pyConv}, capaz de receber o código \as{} de alto nível, ou seja, com palavras. Esse, por sua vez, é exatamente idêntico ao gerado pela ferramenta \textit{Disassembler} do próprio compilador \py{}.

Além disso, ao final deste trabalho, tem-se uma arquitetura projetada com organização em seus código, o que torna acessível a adição de módulos de funcionalidades. Basicamente, ao criar-se um módulo com uma nova funcionalidade, como por exemplo matrizes, é possível conectá-lo aos fios internos da arquitetura e alterar a unidade de controle para inserir novas instruções. 

Portanto, este trabalho pode ser considerado o trabalho inicial que poderá, um dia, se tornar um processador que transforma a \pvm{} completa em \hw{}. Hoje, ele é apenas um processador simples que executa as instruções básicas da linguagem \py{} e isso se deve, principalmente, ao pouco tempo para a realização deste trabalho.

Além disso, para trabalhos futuros, tem-se em vista a implementação de alguns outros módulos para este processador e, ainda, tem-se a ideia de integrar o processador em um \textit{chip} (gerando um \textit{system-on-chip} (SoC)). Tal ato permitiria fazer o processador funcionar ao lado de outro processador de propósito geral, sendo que este segundo enviaria as instruções para o primeiro.

Em longo prazo, quando este projeto estiver abrangendo praticamente todas as instruções da PVM, é possível que este processador possa servir de alternativa para a \pvm{} executar seus algoritmos. Podendo ela, através do \textit{pyConv}, enviar instruções diretamente para o \hw{} e receber respostas. 