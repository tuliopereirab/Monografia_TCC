Indubitavelmente, a tecnologia está se expandindo e evoluindo cada vez mais. Inúmeras empresas trabalham para, a cada dia, surgirem novos serviços e funcionalidades que visam simplificar tarefas, divertir, informar, entre outros objetivos. Um dos pilares fundamentais para todas estas possibilidades tecnológicas é a programação.

A programação é a base para de muitos sistemas que vemos no dia a dia, tanto programação com linguagens de alto nível quanto programação utilizando linguagens de baixo nível. Um exemplo de linguagem de alto nível, sobre a qual trata este trabalho, é o \py{}. 

A linguagem \py{} foi lançada em 1991 pelo programador holandês Guido van Rossum. Ela é compilada e executada utilizando uma implementação criada e mantida por Rossum. Tal algoritmo, chamado de \textit{CPython} \cite{insidePVM}, é escrito em C e executa os \textit{bytecodes} (códigos binários utilizados para execução e gerados pelo compilador ao ler o código de alto nível) gerados pelo compilador \textit{Python} tal como uma máquina virtual, não permitindo, portanto, que o código rode diretamente no processador físico da máquina. Ele funciona de modo similar à máquina virtual responsável por executar implementações feitas através da linguagem \java{}, sendo responsável pela execução do algoritmo.

A grande vantagem de se utilizar linguagens interpretadas, assim como a linguagem \py{}, está na portabilidade \cite{Watters1996}. A portabilidade é a capacidade de um programa ser utilizado em inúmeros sistemas diferentes. Assim, um algoritmo escrito em \py{} e compilado para \textit{Windows}, por exemplo, também é capaz de ser executado em um sistema \textit{Linux} sem precisar ser recompilado para o último. Isso acontece pelo fato da máquina virtual \py{} já possuir uma implementação \textit{Linux}. Então, ao invés de recompilar cada um dos algoritmos para que consigam rodar em um sistema diferente, existe uma máquina virtual que já suporta os diferentes sistemas e é capaz de ler o algoritmo. O mesmo acontece com \java{} e também explica o motivo de \java{} ser uma tão amplamente utilizada no mundo inteiro.

A linguagem \textit{Python} possui um compilador \cite{designCompiler} que gera, como resultado, um arquivo contendo os \textit{bytecodes} de determinada implementação feita através da linguagem. Após tal arquivo ser obtido, pode-se iniciar a execução dos \textit{bytecodes} através do interpretador. A Figura \ref{INTRO_diagCompilacao} demonstra um fluxo básico de compilação, onde tem-se como entrada um código qualquer escrito em \textit{Python}, passando por um compilador que gerará, como resultado, um arquivo contendo os \textit{bytecodes} que serão lidos pelo interpretador posteriormente. Podemos perceber que, de posse do compilador citado anteriormente, é, de certa forma, simples obter o arquivo contendo os \textit{bytecodes}. 

\begin{figure}[!htb]
	\caption{Fluxo básico de compilação.}
	\centerline{\includegraphics[scale=1]{images/INTRO_Compilacao.png}}
	\fonte{Autor (2019)}
	\label{INTRO_diagCompilacao}
\end{figure}

É sabido que uma máquina virtual precisa ser executada em um processador de propósito geral, o qual está executando um sistema operacional. Assim, podem-se citar duas camadas abaixo da máquina virtual que precisam funcionar para que seja possível a execução de um algoritmo \py{}. Com isso, é interessante se pensar em como seria o desempenho de uma arquitetura criada em \hw{} que fosse fiel a uma máquina virtual. Esse \hw{} seria uma arquitetura de propósito específico e que somente receberia as instruções compatíveis com a máquina virtual e as executaria diretamente em \hw{}. Com essa ideia, é possível imaginar que existe a possibilidade de que haja ganho de desempenho, principalmente, na execução de algoritmos considerados complexos.

Assim, com essa ideia em mente, este trabalho visa desenvolver uma arquitetura em \textit{hardware}, utilizando a linguagem de descrição de \hw{} \textit{VHDL}, que seja capaz de executar algoritmos escritos originalmente em \textit{Python} e, posteriormente, convertidos para um arquivo de \textit{bytecodes}. Tendo como premissa o fato de uma arquitetura física, desenvolvida para uma funcionalidade específica, conseguir obter melhor desempenho do que a mesma aplicação executada em \sw{}, espera-se a possibilidade de acelerar a execução de algoritmos \py{}, assim como reduzir o consumo de memória e energia para suportar a máquina virtual \py{}. 

Sabe-se, contudo, que a máquina virtual \py{} é eficiente e apenas tem suas perdas de desempenho em aplicações que demandam muita capacidade de execução, executando sequências complexas de cálculos e repetições, necessitando, muitas vezes, obter um dado em um exato momento para ser utilizado imediatamente (aplicações de tempo real). Assim, para esse tipo de aplicação, é interessante que se consiga melhorar o desempenho, utilizando uma implementação em \hw{}, fazendo com que seja possível atender a todas as instruções da melhor forma possível. Porém, em virtude do tempo em que este trabalho será executado juntamente com a ausência de trabalhos visando a aceleração da linguagem \py{}, aplicações de cunho mais complexo e que demandam um extenso conjunto de instruções não serão cobertas na arquitetura. Assim, neste trabalho, será apresentada uma proposta de arquitetura capaz de executar instruções consideradas básicas, por aparecerem na imensa maioria dos algoritmos. Essas instruções, que serão apresentadas nos capítulos subsequentes, serão divididas em classes, as quais serão abordadas individualmente.

A arquitetura desenvolvida neste trabalho tem como principal objetivo servir como ponto de partida para um processador \py{} completo. Assim, não espera-se que todas as instruções da linguagem sejam suportadas na arquitetura, mas que ela esteja preparada para receber módulos que possibilitarão a expansão do conjunto de instruções. Sabe-se, ainda, que a máquina virtual \py{} não foi originalmente projetada para ser descrita por um \hw{} e, com isso, alterações de cunho de projeto deverão ser feitas, porém sem modificar a funcionalidade básica da máquina \py{}. A arquitetura deverá, portanto, receber o código \as{} original da linguagem e utilizá-lo para executar o algoritmo, realizando as operações de cada uma das instruções diretamente em \hw{}.

Espera-se, ao final desse trabalho, que seja obtida uma descrição de uma arquitetura física funcional e que ela possa ser prototipada, utilizando-se \textit{FPGA} (\textit{Field Programmable Gate Array}). A Figura \ref{INTRO_diagFPGA} demonstra o fluxo que se pretende implementar para execução de um programa \textit{Python} em um FPGA. Quando uma arquitetura funcional for obtida, pretende-se criar um \textit{software} de apoio que será responsável por gerar arquivos de inicialização de memória com os \bc{} da aplicação, os quais serão transferidos para a memória interna do FPGA. Desse modo, a arquitetura pode, subsequentemente, iniciar a execução desta aplicação. Com as instruções encontradas no arquivo já presentes na memória do FPGA, esse executará cada uma delas, na ordem em que aparecem, sendo capaz de executar desvios (\textit{jumps}) entre elas.

\begin{figure}[!htb]
	\caption{Fluxo básico que se planeja implementar para execução de um arquivo com \textit{bytecodes Python} em um FPGA.}
	\centerline{\includegraphics[scale=0.6]{images/INTRO_fluxo_entrada_FPGA.png}}
	\fonte{Autor (2019)}
	\label{INTRO_diagFPGA}
\end{figure}

Com o \sw{} que pretende-se implementar, torna-se simplificada a execução de algoritmos na arquitetura e, consequentemente, deixa em aberto possibilidades de implementação a serem abordadas no futuro. Uma delas e, também, a principal, é a criação de um \textit{system-on-chip} (SoC) baseado na interação entre o \sw{} e a arquitetura. Essa ideia, a qual não é desenvolvida neste trabalho, visa a substituição da memória de instruções do \hw{} por conexões com um processador de propósito geral, o qual ficaria incumbido de executar uma variação do algoritmo do conversor desenvolvido aqui e apelidado de \textit{pyConv}.

Portanto, este trabalho tem como principais objetivos a criação de uma arquitetura física capaz de executar as instruções suportadas pela máquina virtual da linguagem \py{} visando manter a fieldade com a mesma. Além disso, tem-se como objetivo desenvolver um \sw{} conversor, capaz de gerar arquivos de inicialização de memória utilizados por determinadas ferramentas de descrição, simulação e prototipação de \hw{}, tais como \textit{Quartus} e \textit{Modelsim}, que serão abordados no decorrer deste documento. 

E, além disso, visando atender a objetivos previstos o período após este trabalho, os quais não serão abordados amplamente neste documento, tem-se como objetivo desenvolver a arquitetura e o conversor de tal forma que permaneçam abertos a receberem incrementos no número de funcionalidades suportadas. Tal expansão pode ser permitida através de uma organização de projeto visando futura adição de módulos responsáveis de executar funcionalidades específicas, tais como, por exemplo, suporte a vetores e matrizes. 

%Além disso, para que seja possível executar algoritmos com praticidade na arquitetura, tem-se como objetivo o desenvolvimento de um conversor. Assim, poderá ser possível receber o código \as{} da linguagem \py{}, através de uma aplicação em \sw{}, e gerar arquivos de inicialização de memória para arquitetura. Logo, não é necessário que as memórias sejam inicializadas manualmente, o que torna o processo de execução mais eficiente e abre portas para interação \hw{}/\sw{}. 


%Além disso, para que seja possível executar algoritmos com praticidade, uma integração \hw{}/\sw{} torna-se necessária. Assim, poderá ser possível ler os arquivos de \bc{} \py{}, através de uma aplicação em \sw{}, e executá-los diretamente na arquitetura, através da mesma aplicação. Sendo essa aplicação, portanto, o agente intermediário entre o algoritmo \py{}, que deseja-se executar, e a arquitetura, que irá executá-lo.

% A estruturação deste trabalho foi feita com base em etapas de desenvolvimento. Assim, os capítulos \ref{metodologia} e \ref{desenvolvimento} possuem duas seções cada. É possível perceber ainda que as seções \ref{a_requisitos} e \ref{projeto_arq} contêm as mesmas subseções. Isso acontece porque elas abordam os mesmos assuntos, porém sob diferentes focos. A primeira, lista os componentes necessários para a arquitetura consiga executar as instruções de cada classe. Já a segunda apresenta conexões que geram arquiteturas parciais das mesmas classes de instruções.

Este documento, então, apresenta informações sobre todo o processo de desenvolvimento deste projeto, desde o estudo da linguagem \py{} e escolha das instruções até a implementação propriamente dita. Os capítulos a seguir mostram, respectivamente, informações sobre a linguagem, os métodos utilizados para o desenvolvimento do projeto e o desenvolvimento propriamente dito. 

Além disso, pode ser encontrado um capítulo que abordará as modificações de projeto que ocorreram durante o desenvolvimento. Este capítulo existe pois foi de interesse do autor manter a sequência de passos de implementação, incluindo a fase de aprimoramento de modificações. Esse capítulo, ainda, utiliza detalhes do próprio projeto para explicar decisões que geraram modificações drásticas na implementação.

Já a parte final deste documento refere-se, primeiramente, à implementação do conversor \textit{pyConv}, o qual se tornou uma ferramenta fundamental para inicializar a arquitetura. E, após, a apresentação dos resultados obtidos durante todo o projeto, incluindo dados técnicos da arquitetura e analises sobre simulações que provam o funcionamento do \hw{}.