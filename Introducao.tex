Indubitavelmente, a tecnologia está se expandindo e evoluindo cada vez mais. Inúmeras empresas trabalham para, a cada dia, surgirem novos serviços e funcionalidades que visam simplificar tarefas, divertir, informar, entre outros objetivos. Um dos pilares fundamentais para todas estas possibilidades tecnológicas é a programação.

A programação é a base para de muitos sistemas que vemos no dia a dia, tanto programação com linguagens de alto nível quanto programação utilizando linguagens de baixo nível. Um exemplo de linguagem de alto nível, sobre a qual trata este trabalho, é o \py{}. 

A linguagem \py{} foi lançada em 1991 pelo programador holandês Guido van Rossum. Ela é compilada e executada utilizando uma implementação criada e mantida por Rossum. Tal algoritmo, chamado de \textit{CPython} \cite{insidePVM}, é escrito em C e executa os \textit{bytecodes} (códigos binários utilizados para execução e gerados pelo compilador ao ler o código de alto nível) gerados pelo compilador \textit{Python} tal como uma máquina virtual, não permitindo, portanto, que o código rode diretamente no processador físico da máquina. Ele funciona de modo similar à máquina virtual responsável por executar implementações feitas através da linguagem \java{}, sendo responsável pela execução do algoritmo.

A grande vantagem de se utilizar linguagens interpretadas, assim como a linguagem \py{}, está na portabilidade \cite{Watters1996}. A portabilidade é a capacidade do algoritmo ser utilizado em inúmeros sistemas diferentes. Assim, um algoritmo escrito em \py{} criado para \textit{Windows}, por exemplo, também é capaz de ser executado em um sistema \textit{Linux} sem precisar ser recompilado para o último. Isso acontece pelo fato da máquina virtual \py{} já possuir uma implementação \textit{Linux}. Então, ao invés de recompilar cada um dos algoritmos para que consigam rodar em um sistema diferente, existe uma máquina virtual que já suporta os diferentes sistemas e é capaz de ler o algoritmo. O mesmo acontece com \java{} e também explica o motivo de \java{} ser uma tão amplamente utilizada no mundo inteiro.

A linguagem \textit{Python} possui um compilador \cite{designCompiler} que gera, como resultado, um arquivo contendo os \textit{bytecodes} de determinada implementação feita através da linguagem. Após tal arquivo ser obtido, pode-se iniciar a execução dos \textit{bytecodes} através do interpretador. A Figura \ref{INTRO_diagCompilacao} demonstra um fluxo básico de compilação, onde tem-se como entrada um código qualquer escrito em \textit{Python}, passando por um compilador que gerará, como resultado, um arquivo contendo os \textit{bytecodes} que serão lidos pelo interpretador posteriormente. Podemos perceber que, de posse do compilador citado anteriormente, é, de certa forma, simples obter o arquivo contendo os \textit{bytecodes}. 

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=1]{images/INTRO_Compilacao.png}
	\caption{Fluxo básico de compilação.}
	\label{INTRO_diagCompilacao}
\end{figure}

Este trabalho visa, então, desenvolver uma arquitetura em \textit{hardware}, utilizando a linguagem de descrição de \hw{} \textit{VHDL}, que seja capaz de executar algoritmos escritos originalmente em \textit{Python} e, posteriormente, convertidos para um arquivo de \textit{bytecodes}. Tendo como premissa o fato de uma arquitetura física, desenvolvida para uma funcionalidade específica, conseguir obter melhor desempenho do que a mesma aplicação executada em \sw{}, espera-se a possibilidade de acelerar a execução de algoritmos \py{}, assim como reduzir o consumo de memória e energia para suportar a máquina virtual \py{}. 

Sabe-se, contudo, que a máquina virtual \py{} é eficiente e apenas tem suas perdas de desempenho em aplicações que demandam muita capacidade de execução, executando sequências complexas de cálculos e repetições, necessitando, muitas vezes, obter um dado em um exato momento para ser utilizado imediatamente (algoritmos de tempo real). Assim, para esse tipo de aplicação, é interessante que se consiga melhorar o desempenho, utilizando uma implementação em \hw{}, fazendo com que seja possível atender a todas as instruções da melhor forma possível. Porém, em virtude do tempo em que este trabalho será executado juntamente com a ausência de trabalhos visando a aceleração da linguagem \py{}, aplicações de cunho mais complexo e que demandam um extenso conjunto de instruções não serão cobertas na arquitetura. Assim, neste trabalho, será apresentada uma proposta de arquitetura capaz de executar instruções consideras básicas, por aparecerem na imensa maioria dos algoritmos. Essas instruções, que serão apresentadas nos capítulos subsequentes, serão divididas em classes, as quais serão abordadas individualmente.

Espera-se, ao final desse trabalho, que seja obtida uma descrição de uma arquitetura física funcional e que ela possa ser prototipada, utilizando-se \textit{FPGA} (\textit{Field Programmable Gate Array}). A Figura \ref{INTRO_diagFPGA} demonstra o fluxo que se pretende implementar para execução de um programa \textit{Python} em um FPGA. Quando uma arquitetura funcional for obtida, pretende-se criar um \textit{software} de apoio que será responsável por gerar arquivos de inicialização de memória com os \bc{} da aplicação, os quais serão transferidos para a memória interna do FPGA. Desse modo, a arquitetura pode, subsequentemente, iniciar a execução desta aplicação. Com as instruções encontradas no arquivo já presentes na memória do FPGA, esse executará cada uma delas, na ordem em que aparecem, sendo capaz de executar desvios (\textit{jumps}) entre elas.

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.6]{images/INTRO_fluxo_entrada_FPGA.png}
	\caption{Fluxo básico que se planeja implementar para execução de um arquivo com \textit{bytecodes Python} em um FPGA.}
	\label{INTRO_diagFPGA}
\end{figure}

Além disso, para que seja possível executar algoritmos com praticidade na arquitetura, tem-se como objetivo o desenvolvimento de um conversor. Assim, poderá ser possível receber o código \as{} da linguagem \py{}, através de uma aplicação em \sw{}, e gerar arquivos de inicialização de memória para arquitetura. Logo, não é necessário que as memórias sejam inicializadas manualmente, o que torna o processo de execução mais eficiente e abre portas para interação \hw{}/\sw{}. 

%Além disso, para que seja possível executar algoritmos com praticidade, uma integração \hw{}/\sw{} torna-se necessária. Assim, poderá ser possível ler os arquivos de \bc{} \py{}, através de uma aplicação em \sw{}, e executá-los diretamente na arquitetura, através da mesma aplicação. Sendo essa aplicação, portanto, o agente intermediário entre o algoritmo \py{}, que deseja-se executar, e a arquitetura, que irá executá-lo.

% A estruturação deste trabalho foi feita com base em etapas de desenvolvimento. Assim, os capítulos \ref{metodologia} e \ref{desenvolvimento} possuem duas seções cada. É possível perceber ainda que as seções \ref{a_requisitos} e \ref{projeto_arq} contêm as mesmas subseções. Isso acontece porque elas abordam os mesmos assuntos, porém sob diferentes focos. A primeira, lista os componentes necessários para a arquitetura consiga executar as instruções de cada classe. Já a segunda apresenta conexões que geram arquiteturas parciais das mesmas classes de instruções.