\documentclass[tcc,baec]{unipampa}

\usepackage[T1]{fontenc}        % pacote para conj. de caracteres correto
\usepackage[latin1]{inputenc}   % pacote para acentuação
\usepackage{graphicx}           % pacote para importar figuras
\usepackage{times}              % pacote para usar fonte Adobe Times
\usepackage{mathptmx}           % pacote usar fonte Adobe Times nas fórmulas
\usepackage[final]{pdfpages}

\usepackage[alf,abnt-emphasize=bf]{abntex2cite}	% pacote para usar citações abnt

\title{Implementação de um processador, em VHDL, para executar algoritmos escritos em Python}

\author{Bitencourt}{Tulio Pereira}


\advisor[Prof.~Dr.]{Neves}{Bruno Silveira}

\cutter{---} 											            % número de catalogação da biblioteca, na versão final do trabalho; 
                                              % deixar em branco antes de produzir a versão final ou se a versão
                                              % final não for registrada na biblioteca
                                              % na versão final, gerar o código no sistema GURI


\newcommand{\as}{\textit{Assembly}}
\newcommand{\vm}{máquina virtual}
\newcommand{\py}{\textit{Python}}
\newcommand{\pvm}{máquina virtual \textit{Python}}
\newcommand{\tos}{topo da pilha}
\newcommand{\cpy}{\textit{CPython}}
\newcommand{\asp}{\textit{Assembly Python}}
\newcommand{\hw}{\textit{hardware}}
\newcommand{\sw}{\textit{software}}
\newcommand{\bc}{\textit{bytecodes}}
\newcommand{\by}{\textit{byte}}
\newcommand{\bys}{\textit{bytes}}
\newcommand{\bi}{\textit{bit}}
\newcommand{\bis}{\textit{bits}}
\newcommand{\isa}{conjunto de instruções}
\newcommand{\jumps}{\textit{jumps}}
\newcommand{\jump}{\textit{jump}}
\newcommand{\aloop}{\textit{loop}}
\newcommand{\aloops}{\textit{loops}}
\newcommand{\pc}{contador de programa}
\newcommand{\java}{\textit{Java}}
\newcommand{\mux}{\textit{mux}}
\newcommand{\enable}{\textit{enable}}
\newcommand{\clock}{\textit{clock}}
\newcommand{\mif}{\textit{.mif}}
\newcommand{\mem}{\textit{.mem}}
\newcommand{\modelsim}{\textit{Modelsim}}
\newcommand{\quartus}{\textit{Quartus}}

                                                  
%%%% Se não colocar a banca, a folha de aprovação não aparece                                                  

\banca[Prof.~Me.]{Nunes}{Gerson Alberto Leiria}			% membro da banca de defesa (orientador não entra)
\inst{Universidade Federal do Pampa}							% instituição do membro da banca

\banca[Prof.~Me.]{Junior}{Julio Saraçol Domingues}       % membro da banca de defesa 
\inst{Universidade Federal do Pampa}							% instituição do membro da banca

%\banca[Dr.]{Perez}{Naylor}                        % membro da banca de defesa 
%\inst{EMBRAPA Pecuária Sul}							          % instituição do membro da banca

\defesa{8}{dezembro}{2018}                       % data da defesa - dia, mês e ano

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% A data deve ser a da defesa ou a da geração do documento, o que vier primeiro; 
% se nao especificada, são gerados mês e ano correntes. Use somente se for gerar 
% novamente o documento após a defesa.
%\date{maio}{2001}

% O local de realização do trabalho deve ser especificado 
% com o comando \location. 
\location{Bagé}{RS}

%
% Palavras-chave para o resumo (na língua do documento)
%
% Iniciar todas com a primeira legra maiúscula e as demais letras minúsculas, 
% exceto no caso de abreviaturas.
%
\keyword{VHDL}
\keyword{FPGA}
\keyword{Python}
\keyword{Processador}
\keyword{Circuitos Integrados}
\keyword{Máquina virtual}

\sloppy % para o texto não ficar esquisito quando se usar elementos muito compridos que não podem ser separados.


%
% Início do documento
%

\begin{document}



\maketitle

%
% Dedicatoria (opcional)
%

%\begin{dedicatoria}
%Dedico este trabalho ao meu gato, ao meu cachorro e ao meu papagaio.
%\end{dedicatoria}

%
% Agradecimentos (opcional)
%
% Se você tiver muito a agradecer, pode usar um arquivo à parte e incluí-lo
% no texto, por meio do comando \input{meus-agradecimenos}. O compilador
% LaTeX buscará o arquivo meus-agradecimentos.tex e incluirá o texto do mesmo
% neste local. Isso ajuda a tornar o arquivo principal do trabalho (este)
% mais limpo, claro e conciso.
%

%\chapter*{Agradecimento}
%Agradeço à Antarctica pelas Brahminhas que eles mandaram.

%
% Epígrafe (opcional)
%
%\begin{epigrafe}
%``If I have seen farther than others, it is because I stood on the shoulders of giants.''\\
%--- Sir~Isaac Newton
%\end{epigrafe}

%
% Resumo na língua do documento (obrigatório). Segundo o manual da UNIPAMPA, deve ser escrito em um único parágrafo:
%

\begin{abstract}
Esta monografia apresenta a estratégia adotada para implementação de um processador, criado em VHDL, capaz de executar algoritmos escritos em \py{}. % e, futuramente, a conexão diretamente com o compilador nativo da linguagem Python.

Para isso, inicialmente, foi realizada uma análise de requisitos, ou seja, uma definição de quais seriam as instruções do código \as{} da linguagem \py{} seriam implementadas na arquitetura, tendo como objetivo listar as instruções básicas da linguagem, as quais podem ser encontradas na grande maioria dos algoritmos implementados em \py{}.

Após definição, foi feito outro levantamento de requisitos. Nesse caso, para identificar os componentes físicos necessários para dar suporte ao conjunto de instruções. Para fazer isso, todas as instruções escolhidas foram separadas quanto as suas classes: acesso à memória, operações aritméticas ou lógicas e controle de fluxo.
 
Então, com posse da lista de componentes a serem utilizados na arquitetura, foram realizadas as criações de arquiteturas parciais, as quais foram desenvolvidas especificamente para cada uma das classes de instruções. Ao final deste fragmento de implementação, todas as arquiteturas foram integradas em apenas uma e foram inseridos multiplexadores para que fosse possível que o mesmo componente, presente no desenho de mais uma arquitetura parcial, pudesse ser compartilhado, a fim de atender a mais de uma classe de instruções.

Por último, foi feito o projeto de uma unidade de controle, sendo, para este fim, criadas máquinas de estados individuais para cada uma das instruções, as quais foram posteriormente integradas gerando uma única máquina de estados. %Com exceção das instruções BINARY\_, todas as instruções possuem uma máquina de estados única e independente. Foi definido, ainda, que o primeiro estado de todas as máquinas seria o mesmo.

Portanto, ao final deste trabalho parcial, foi possível obter uma arquitetura funcional, a qual consegue executar todas as instruções listadas e analisadas no decorrer do trabalho. Contudo, essa arquitetura ainda não é integrada com o compilador Python, não executando, por ora, os \bc{} da linguagem. 

A próxima parte deste trabalho, então, será focada na integração da arquitetura com o compilador \py{}. Nessa, também espera-se fazer melhorias significativas na arquitetura, melhorando sua frequência de operação (atualmente 89,29 MHz), área ocupada no chip (atualmente equivalente a 409 elementos lógicos de um dispositivo Ciclone III) e eficiência energética (não mensurada neste estudo parcial). 
\end{abstract}

%
% Resumo na outra língua - se o texto for em Português, o abstract é em Inglês e vice-versa - 
% como parâmetros devem ser passadas as palavras-chave na outra língua, separadas por vírgulas:
%

\begin{englishabstract}{VHDL, FPGA, Python, Processor, Integrated Circuits, Virtual Machine.

This monograph presents the strategy of a processor implementation, created in VHDL, able to execute algorithms written in Python, and, in the future, a directly connection with the native Python compiler. 

To do this, as first step, it was realized an analyze of requirements, or in other words, a definition of Python Assembly code instructions to be implemented in the architecture, had as objective to list the basic instructions of the language, that are used in the majority of algorithms implemented in Python.

After definition, another requirement gathering was done. In this case, to identify the necessary physical components required to support the instruction set. To do this, all chosen instructions were divided in classes based in their functionalities: memory access, logical or arithmetical operations and flow control. 

Then, with the list of components that would be used in the architecture, it was projected the partial architectures, which were developed specifically to each class of instructions. In the end of this implementation fragment, all architectures were integrated in only one and were inserted multiplexers, turning able the same component, present in more than one partial architecture design, could be shared, with the purpose of attend more than one instruction class. 

At last, it was made the project of the control unit, being, to this purpose, created individual state machines to each instruction chosen, which was, posteriorly, integrated, generation only one state machine. %With the only one exception, BINARY\_ instructions, every instruction have a unique state machine. It was defined that the first state of each state machine would be the same. 

Therefore, in the end of this first step, it was possible to obtain a functional architecture, which is able to execute all the instructions listed and analyzed during the work. However, this architecture is not integrated yet with the Python compiler, not executing directly the Python bytecodes. 

The next step of this project will focus on the integration between the architecture created and the Python compiler. It is also expected the architecture to be improved, including the operation frequency (actually 89.29 MHz), chip occupation area (actually equivalent of 409 logical elements of a Cyclone III device) and energetic efficiency (not measured in this partial study).

}
\end{englishabstract}

%
% Lista de figuras
%
% Todas as figuras declaradas no texto dentro de um ambiente figure serão numeradas apropriadamente e
% colocadas automaticamente nesta lista, com o número de página onde aparecem correto:
%
\listoffigures

%
% Lista de tabelas
%
% Todas as tabelas declaradas no texto dentro de um ambiente table serão numeradas apropriadamente e
% colocadas automaticamente nesta lista, com o número de página onde aparecem correto:
%

\listoftables

% Listas de definições e teoremas, para quem usar o pacote formais, para trabalhos que possuam definições formais e teoremas

%\listofdefinitions
%\listoftheorems

%
% Lista de abreviaturas e siglas
%
% O parâmetro deve ser a abreviatura mais longa. Essa lista é opcional, mas é muito conveniente.
% Só não abuse. use somente siglas consagradas. Se quiser economizar na escrita, use o comando
% \newcommand{\MT}{Máquina de Turing} e use \MT sempre que quiser que o termo apareça completo.
% Isso torna a leitura do texto mais fluente.
\begin{listofabbrv}{UNIPAMPA}
		%\item[ACM]      	\textit{Association for Computing Machinery}
        %\item[IEEE]     	\textit{Institute of Electrical and Electronics Engineers} 
		\item[FPGA]			\textit{Field Programmable Gate Arrays}
		\item[HTML]			\textit{HiperText Makeup Language}	
        \item[ISA]			\textit{Instructions Set Architecture}
        \item[memExt]		Memória Externa
		\item[memInstr]		Memória de Instruções        
        \item[muxOp1]		Multiplexador do Operando 1
        \item[muxOp2]		Multiplexador do Operando 2
        \item[muxPilha]		Multiplexador da Pilha
        \item[muxRegOp1]	Multiplexador do Registrador de Operando 1     
        \item[PC]			\textit{Program Counter}
		\item[PVM]			\textit{Python Virtual Machine}
        \item[regArg]		Registrador de Argumento
        \item[regComp]		Registrador de Comparação
        \item[regEnd]		Registrador de Endereço
        \item[regInstr]		Registrador de Instrução
        \item[regMemExt]	Registrador de Memória Externa
        \item[regOp1]		Registrador de Operando 1
        \item[regOp2] 		Registrador de Operando 2
        \item[regOverflow]	Registrador de \textit{Overflow}
        \item[regPc]		Registrador de Program counter
        \item[regPilha]		Registrador de Pilha
        \item[regTos]		Registrador de topo da pilha
		\item[RISC]			\textit{Reduced Instruction Set Computer}
        \item[TOS]     		\textit{Top Of the Stack}
        \item[ULA]			Unidade Lógica Aritmética
        \item[UNIPAMPA] 	Universidade Federal do Pampa
		\item[VHDL]			\textit{Vhsic Hardware Description Language}
		\item[VM]			\textit{Virtual Machine}
   
\end{listofabbrv}

% Lista de símbolos
%\begin{listofsymbols}{$\alpha\beta\pi\omega$}
%       \item[$\sum{\frac{a}{b}}$] Somatório do produtório
%       \item[$\alpha\beta\pi\omega$] Fator de inconstância do resultado
%\end{listofsymbols}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% Sumário - elemento obrigatório do trabalho - gerado automaticamente com
%           o comando abaixo.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% Aqui comeca o texto propriamente dito. O texto pode ser todo escrito neste 
% mesmo arquivo, mas pode-se separar o texto em diversos arquivos, que podem
% ser incluídos com o comando \input{nome-do-arquivo} (inclui o arquivo com
% nome nome-do-arquivo.tex), que deve estar no mesmo diretório do texto
% principal. Se estiver em outro diretório, pode ser incluído também, usando
% \input{Textos/nome-do-arquivo}. Dessa forma, o arquivo será buscado no
% subdiretório Textos; se quiser usar caminhos na árvore de diretórios, use
% \input{../Textos/nome-do-arquivo}, que procura o arquivo que está no diretório
% Textos, um nível acima na estrutura.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% E aqui vai a parte principal:

\chapter{Introdução}
\label{cap-introducao}
\input{Introducao}

\chapter{Referencial Teórico}
\label{ref-teorico}
\input{Referencial_Teorico}

\chapter{Metodologia}
\label{metodologia}
%\input{Metodologia}
\input{nova_metodologia}

\chapter{Desenvolvimento}
\label{desenvolvimento}
\input{Desenvolvimento}

\chapter{Modificações}
\label{modificacoes}
\input{Modificacoes}

\chapter{Conversor \textit{pyConv}} % dar um nome para o conversor
\label{conversor}
\input{conversor}

\chapter{Resultados}
\input{Resultados}

\chapter{Considerações Finais}
\label{consideracoes-finais}
\input{ConsideracoesFinais}

% \chapter{A minha contribuição}
% \label{cap-minha-contribuicao}
% \input{MeuTrabalho}

% \chapter{Prova de que a minha contribuição é válida}
% \label{cap-minha-contribuicao}
% \input{Resultados}

% \chapter{Conclusão} % A normatização da biblioteca diz que em TCC este capítulo deve ser chamado de "Considerações Finais".
% \label{cap-conclusao-e-trabalhos-futuros}
% \input{Conclusao}

%
% O arquivo de formatação abntex2-alf.bst coloca todas as entradas no formato correto.
%

%\nocite{icgt04}
%\nocite{nagl86set}
%\nocite{microsoft05Csharp}
%\nocite{meinke92universal}
%\nocite{marchi04verificacao}
%\nocite{biberstein97coopnthesis}
%\nocite{anderson96model}
%\nocite{alur01partial}
%\nocite{abramski94domain}
%\nocite{abadi97alogic}

\bibliographystyle{abntex2-alf}
\bibliography{bibliografia}

%\chapter*{Glossário}
%
%O glossário é opcional. Se precisar, consulte o manual sobre o seu formato adequado.


\appendix

\chapter{Análise das Instruções}
\label{analise_instr}
\input{apendice/ap_analiseInstr}

\chapter{Análise dos Componentes Necessários}
\label{analise_componentes}
\input{apendice/ap_analiseComponentes}

\chapter{Esboço da Arquitetura Completa}
\label{apendice_arq}
\input{apendice/apArq}

\chapter{Máquinas de Estados}
\label{apendice_maqEst}
\input{apendice/ap1}

%\includepdf[pages=-]{apendice/apendice_maquinasEstados.pdf}

%\annex

%\chapter{Nome do Anexo}
%
%Depois do termo ``annex'', qualquer capítulo aparecerá na forma correta, com o termo ``Anexo'' no título. Use anexos quando se tratar de material não produzido pelo autor, mas necessário no entendimento do trabalho. Por exemplo, definições matemáticas, sintaxe formal de linguagens de programação, trechos de manuais, etc.

%
% Finalização do documento. A partir desse comando qualquer coisa escrita será ignorada:
%

\end{document}
