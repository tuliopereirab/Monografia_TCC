Para iniciar o desenvolvimento do sistema, foi necessário, anteriormente, definir o conjunto de instruções básico que seria implementado. Isso porque, para propor uma arquitetura funcional e que atenda todos os requisitos, é preciso já possuir o conjunto de instruções básico a ser implementado. Dessa forma, é possível fazer uma análise concreta dos componentes necessários na arquitetura.

A seção \ref{a_instrucoes} apresenta detalhadamente como foi escolhido o conjunto de instruções a ser implementado nesse trabalho. Após a escolha do mesmo, foi feita uma análise de requisitos do sistema, onde todas as instruções escolhidas foram analisas e foi projetado o que deveria estar contido na arquitetura final. Esta parte do projeto está detalhada na seção \ref{a_requisitos}.

Somente após os dois primeiros passos, pode-se começar a projetar a arquitetura final. Para isso foram necessários conhecimentos técnicos e mais análises das instruções e seus funcionamentos, detalhadamente. Na seção \ref{projeto_arq} são apresentadas as análises feitas e são comentadas as decisões tomadas.

Para completar o projeto da arquitetura e colocá-la para funcionar, foi necessário desenvolver o módulo de controle, o qual é responsável por gerenciar todos os componentes que compõem a arquitetura, permitindo que todos funcionem coordenadamente com o objetivo de executar as instruções. A seção \ref{projeto_control} apresenta detalhadamente o controle e comenta seus atributos.

\section{Análise das instruções}
\label{a_instrucoes}

Antes de começarmos, então, a pensar e desenvolver a arquitetura propriamente dita, com seu desenho e controle, foi preciso definir o que a arquitetura seria capaz de fazer. Como o tempo para o desenvolvimento deste trabalho não permite que todas as instruções presentes na máquina virtual da linguagem \textit{Python} sejam implementadas, foi preciso definir um conjunto de instruções que possam ser implementadas dentro do prazo e que permitam que algoritmos simples sejam executados. 

\subsection{Análise de algoritmos simples}
\label{a_algo_sim}
Para escolher as instruções, foi necessária uma análise de diversos algoritmos implementados na linguagem \textit{Python} e que são considerados simples. Tais algoritmos servem como base para diversos outros algoritmos, já que são operações matemáticas básicas, gerenciamento de dados e pulos (\textit{jumps}). 

Então, foram definidos 12 algoritmos que seriam utilizados como base para projetar a arquitetura, já que os trechos que código que os compõem estão presentes em praticamente todos os algoritmos \textit{Python} mais complexos. Os algoritmos escolhidos são:

\begin{description}
	\item[Criação de variáveis numéricas]: é um algoritmo que simplesmente cria uma variável \textit{Python} e atribui um valor numérico a ela, podendo ser qualquer valor. O propósito desse algoritmo é entender como uma variável é salva na memória externa (\textit{RAM}) do sistema.
	\item[Comparação simples]: criou-se um algoritmo que continha uma comparação \textit{if} simples, a qual seria executada, caso a afirmação fosse verdadeira, ou seria ignorada por completo. Ela foi criada para que fosse possível entender como é feita uma comparação dentro do código \textit{Assembly Python}.
	\item[Comparação com \textit{else}]: é um algoritmo que contém uma chamada \textit{if} e, após, uma chamada \textit{else}. Este algoritmo foi utilizado para analisar como funciona, do ponto de vista do código \textit{Assembly}, o uso de um \textit{else}, indicando que, caso a afirmação contida no \textit{if} não fosse verdadeira, o trecho de código interno ao \textit{else} seria executado. 
	\item[Comparação com \textit{elif} e \textit{else}]: algoritmo que contém, além do \textit{if} e \textit{else} inicial e final, um intermediário chamado, chamado na linguagem \textit{Python} de \textit{elif}, que possui uma segunda comparação para ser executada caso a primeira seja falsa. Tal algoritmo foi utilizado para verificar a existência de diferenças entre o uso do \textit{elif} e os outros algoritmos de comparação apresentados anteriormente.
	\item[Estrutura de repetição \textit{while}]: foi criado um algoritmo que implementa uma estrutura de repetição \textit{while}. Seu uso foi necessário para que fosse possível evidenciar os diferentes pulos que são usados no código \textit{Assembly Python} ao se utilizar diferentes estruturas de repetição.
	\item[Estrutura de repetição \textit{for}]: algoritmo idêntico ao anterior, porém utilizando, no lugar do \textit{while}, a estrutura \textit{for}. Foi possível analisar as diferenças entre os dois algoritmos.
	\item[Operação aritmética de soma simples]: foi criada uma operação aritmética de soma simples, a qual foram somados dois valores constantes salvos em uma variável. 
	\item[Operação aritmética de soma de constante com variável]: algoritmo executa uma soma de uma variável previamente salva com uma constante, salvando o resultado em outra variável. Foi possível perceber como são feitos os carregamentos de dados já existentes e os dados chamados como constantes, sem estarem salvos.
	\item[Operação aritmética de soma com duas variáveis]: algoritmo executa a soma de duas variáveis previamente salvas na memória e armazena o resultado em outra variável.
	\item[Operação aritmética de subtração]: algoritmo executa a subtração de dois valores. Sua implementação foi influenciada pelo fato de ser possível analisar quais tipos de operações aritméticas a máquina virtual \textit{Python} é capaz de executar nativamente.
	\item[Operação aritmética de multiplicação]: executa a multiplicação de dois valores. Foi necessário para entender se, dentro da máquina virtual \textit{Python}, uma multiplicação era feita por uma sequência de somas separadas, definidas no código \textit{Assembly}, ou se existia uma instrução específica para executar a multiplicação.
	\item[Operação aritmética de divisão]: implementa uma divisão entre dois valores. Foi utilizado para entender, igualmente à multiplicação, se existia uma instrução específica para tal operação ou se eram feitas subtrações sucessívas.  
\end{description}

De posse dos algoritmos, implementados na linguagem \textit{Python}, foi utilizada uma ferramenta presente no próprio compilador \textit{Python}, capaz de mostrar o código \textit{Assembly} do algoritmo implementado. Então, colocando os algoritmos prontos na ferramenta, ela retornava o código \textit{Assembly} referente ao algoritmo. Tal código é o que é enviado para a máquina virtual para ser executado.

A Figura \ref{img_1_simple} apresenta o código \textit{Assembly} do primeiro algoritmo apresentado. Ele cria uma variável e salva o valor na memória. Após, ele carrega o valor novamente para a pilha e imprime na tela. Todos os algoritmos apresentados aqui contém as instruções de impressão na tela \textit{PRINT\_ITEM} e \textit{PRINT\_NEWLINE}, porém elas não serão importantes para o projeto da arquitetura, já que elas serão implementadas diretamente em \textit{software}.

Então, com a análise da Figura \ref{img_1_simple}, é possível perceber instruções básicas para um código \textit{Assembly Python}, tais como LOAD\_CONST, STORE\_FAST e LOAD\_FAST. A primeira é responsável por encaminhar para a pilha um valor constante, passado como argumento. Tal valor será salvo no TOS e será manipulado de acordo com a próxima instrução. A segunda instrução encontrada salva o TOS na memória principal do sistema, definindo o endereço onde ele será salvo. O endereço definido será o mesmo utilizado para acessar tal variável futuramente. Então, ao dizermos que determinada variável terá o nome de "\textit{variavel}", definimos o endereço desta variável e, toda vez que ela precisar ser acessada, será o endereço dela que será passado como parâmetro, não o nome da variável diretamente. Por fim, a terceira instrução executa um carregamento de uma variável diretamente da memória principal para a o TOS. O endereço onde a variável foi salva na memória será informado no argumento. 

A definição dos argumentos de cada instrução cabe ao compilador, então ele deverá escolher um endereço onde a variável será salva e passar tal endereço para todas as vezes em que a mesma variável precisar ser acessada ou modificada. Uma variável, por exemplo, de nome "\textit{var}" recebe o endereço de 8 \textit{bits} 00001100. Logo, ao ser salva na memória, ela será salva na posição de memória referente a este endereço e, ao ser acessada com um futuro LOAD\_FAST, deverá ser passado como argumento da instrução o mesmo endereço 00001100. 

Podemos perceber, ainda, através da análise da Figura \ref{img_1_simple}, que um valor precisa ser carregado na pilha antes de se tornar uma variável. Isso acontece porque a instrução encarregada por salva determinado valor na memória principal age sobre a pilha. Ou seja, a instrução sempre executará tendo como foco salvar o TOS na memória principal. Logo, a criação de uma variável, que em alto nível é feita simplesmente utilizando "\textit{var = 10}", em baixo nível utiliza duas instruções: LOAD\_CONST e STORE\_FAST.

\begin{figure}[htp]
\centering
\includegraphics{images/1_simple.png}
\caption{Código \textit{Assembly} de uma criação de variável.}
\label{img_1_simple}
\end{figure}

A análise da Figura \ref{img_2_if} nos permite entender como é feita uma comparação na linguagem \textit{Assembly}. O algoritmo apresentado nela implementa uma chamada \textit{if} sozinha, sem acompanhamento de \textit{elif} ou \textit{else}. Isso significa que o trecho de código contido no interior da comparação somente irá impactar na execução do sistema se a comparação for verdadeira, não tendo, portanto, nenhuma execução caso a primeira afirmação for falsa. Em outras palavras, caso a primeira afirmação seja falsa, a chamada \textit{if} será completamente ignorada, diferente do que acontece nas Figuras \ref{img_2_if_else} e \ref{img_2_if_elif_else}.

Então, ao analisarmos a Figura \ref{img_2_if}, podemos perceber que acontece o que já foi visto na Figura \ref{img_1_simple} no que diz respeito ao salvamento de uma variável na memória principal. Então, após salvar uma variável, que será utilizada para fazer a comparação, na memória principal, ela é carregada para a pilha novamente para ser comparada. Contudo, é preciso realizar uma operação que depende de outro valor que ainda não está na pilha, mas precisa estar. Então é feito um carregamento de uma constante diretamente para a pilha. Tal constante é o valor que será comparado com a variável e resultará em um resultado afirmativo ou negativo. 

Com os dois operandos carregados (variável e constante), podemos perceber a existência de uma nova instrução, a qual ainda não foi analisada. Tal instrução é chamada de COMPARE\_OP e ela é encarregada por executar uma comparaçã entre o TOS e a posição logo abaixo. Ela define o tipo de comparação através dos valores passados como argumento. No caso da Figura \ref{img_2_if}, está sendo executada uma comparação "maior que" (>). O compilador define que tal comparação recebe o valor 4 em decimal e o coloca como argumento. 

Após a comparação, pode ser encontrada uma instrução chamada POP\_JUMP\_IF\_FALSE, que executa um pulo caso a compação seja falsa. Para entender melhor isso, vamos pensar diretamente em um algoritmo de alto nível. Em um algoritmo de alto nível, ao ser chamado um \textit{if}, logo abaixo é escrito o trecho de código que será executado caso a afirmação seja verdadeira. Contudo, caso seja falsa, esse código não deverá ser executado. Então, quando estamos falando em \textit{Assembly}, para não executar determinado trecho de código, precisamos pulá-lo. Portanto, a instrução POP\_JUMP\_IF\_FALSE executa um pulo, caso a afirmação do \textit{if} seja falsa, com o intuito de pular o trecho de código que só deve ser executado quando a afirmação for verdadeira.

Ainda na mesma figura, podemos ver que aparece outra instrução que ainda não foi apresentada, chamada JUMP\_FORWARD. Tal instrução executa um pulo incondicional, ou seja, sem depender de uma comparação feita anteriormente. Tal pulo sempre acontecerá quando a instrução for lida, diferentemente da instrução anterior, onde o pulo só acontecerá se a comparação anterior for falsa. A instrução JUMP\_FORWARD executa um pulo em que o valor atual do contador de programa (PC) é incrementado com um valor fixo. É importante observar que o valor de PC não é substituído por completo pelo novo valor, mas sim é feita uma soma entre o valor de PC atual e o valor, que é chamado de \textit{delta}. O resultado da soma será o novo valor de PC.

Finalizando a análise do código \textit{Assembly} da Figura \ref{img_2_if}, podemos perceber que após a comparação, então, é feito um pulo condicional para a linha de código após o trecho de código interno ao \textit{if}. Então, caso não seja feito o pulo, é executada uma chamada de constante e uma impressão na tela. Após, executa-se um pulo sem condição para fora do \textit{if}.

\begin{figure}[htp]
\centering
\includegraphics{images/2_if.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if} simples.}
\label{img_2_if}
\end{figure}

A Figura \ref{img_2_if_else} apresenta um código quase igual ao apresentado na Figura \ref{img_2_if}. Contudo, ele acrescenta um trecho de código que deverá ser executado caso a afirmação do \textit{if} seja falsa. Então, não podemos dizer que a estrutura \textit{if} será completamente ignorada caso sua comparação retorne falsa. 

Porém, do ponto de vista do código \textit{Assembly}, não é adicionada nenhuma instrução nova. A grande diferença dos dois códigos \textit{Assembly} é que o pulo condicional de quando a comparação é retornada como sendo falsa direciona o PC para executar o trecho de código responsável pela saída alternativa ao \textit{if}. Na imagem anterior, não existia tal saída, portanto, o pulo direcionava o contado para fora da estrutura \textit{if} e, como o algoritmo só possuia tal estrutura, para o final da execução. 

Continuamos tendo um pulo incondicional idêntico ao da figura anterior, o qual direciona o programa para o final da sua execução. Podemos observar que só existe pulo incondicional após o trecho de código executado caso a comparação seja verdadeira. No trecho executado caso ela seja, falsa, não temos um pulo pois é esperado que esse trecho somente seja executado como última instância, não sendo preciso realizar nenhum pulo após ele.

\begin{figure}[htp]
\centering
\includegraphics{images/2_if_else.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if} contendo \textit{else}.}
\label{img_2_if_else}
\end{figure}

Na Figura \ref{img_2_if_elif_else}, seguimos a mesma lógica vista nas Figuras \ref{img_2_if} e \ref{img_2_if_else}, porém com a adição de uma nova comparação após a primeira. Como neste algoritmo implementamos uma estrutura \textit{if} que contém duas comparações e uma saída padrão, que será executada caso as duas sejam falsas, podemos ver isso no código \textit{Assembly} também. 

Igual a Figura anterior, não é possível verificar nenhuma instrução diferente das que já vimos até o momento. Contudo, a estrutura do código \textit{Assembly} é levemente diferente. Após executarmos a primeira comparação e estarmos no primeiro pulo, seramos direcionados diretamente para a segunda comparação, caso a primeira retorne falsa. Caso a segunda retorne falsa, seramos direcionados para o trecho de código padrão, que será executado somente se as duas retornarem falsas. 

Com a inserção de uma nova comparação, agora também possuímos mais de um pulo incondicional. Podemos observar, também, que continuamos sem encontrar um pulo incondicional após a segunda comparação. O motivo para isso é o mesmo apresentado anteriormente. 

\begin{figure}[htp]
\centering
\includegraphics{images/2_if_elif_else.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if}, contendo \textit{elif} e \textit{else}.}
\label{img_2_if_elif_else}
\end{figure}

A Figura \ref{img_3_while} é a primeira que apresenta a implementação de uma estrutura de repetição em \textit{Assembly}. Através de sua análise, podemos perceber a inserção de algumas novas instruções. Porém, mantém-se a sequência de chamada de instruções para executar operações mais simples, tais como comparações, onde as constantes a serem comparadas são carregadas para a pilha antes de executar a instrução COMPARE\_OP. 

Analisando este código, podemos perceber que, primeiramente, ocorre a criação de uma variável na memória. Tal variável será utilizada para gerenciar a estrutura de repetição. Ela será iniciada com um valor, no caso da Figura zero, e irá receber uma sequência de somas. Quando seu valor exceder um valor pré-definido, no caso 10, a estrutura será finalizada. 

Após a criação e atribuição de valor à variável, é chamada a primeira instrução nova, SETUP\_LOOP. Tal instrução é responsável por inicializar um bloco, responsável pela estrutura de repetição (\textit{loop}) na pilha. A instrução seguinte inicia um procedimento de comparação, onde os dois valores a serem comparados são carregados para a pilha. O primeiro valor, a variável a ser comparada, e o segundo, o valor que define o final da execução da estrutura, serão os operandos da instrução COMPARE\_OP, executada exatamente na sequência dos dois carregamentos. 

Assim como em uma instrução \textit{if}, existe um trecho de código que só deverá ser executado enquanto o programa estiver sendo rodado dentro do \textit{loop}. Logo, após a comparação, existe um POP\_JUMP\_IF\_FALSE, que visa evitar a execução de tal trecho caso o valor da variável seja maior que 10. Então, o pulo é feito diretamente para a instrução que define a retirada do bloco da pilha, a qual falaremos a seguir. 

Caso o programa siga sendo executado dentro do \textit{loop}, o trecho de código será executado e, após, é feito um incremento ao valor da variável, o qual será salvo exatamente na mesma posição. Para essa operação, é utilizada a instrução INPLACE\_ADD. Sua execução é similar às operações BINARY\_, que veremos a seguir. Contudo, ela permite que o resultado seja o valor original da variável. Para reiniciar a estrutura de repetição, é feito um JUMP\_ABSOLUTE, onde o valor do contador de programa é completamente substituído pelo valor que aponta para a primeira linha de execução do \textit{loop}, no caso linha 9. 

\begin{figure}[htp]
\centering
\includegraphics{images/3_while.png}
\caption{Código \textit{Assembly} de uma estrtutura de repetição \textit{while}.}
\label{img_3_while}
\end{figure}

A Figura \ref{img_4_for} apresenta a segunda estrutura de repetição implementada, a qual é chamada de \textit{for}. Tal instrução apresenta algumas instruções novas, porém sua execução é bem similar à vista na Figura \ref{img_3_while}. 

\textbf{Exatamente como a análise anterior, podemos ver que a estrutura de repetição começa salvando a variável que irá gerenciar o \textit{loop} e, após, aloca um bloco na pilha, com a instrução SETUP\_LOOP. A adição de uma nova instrução à nossa lista se dá na linha exatamente abaixo a essa, na qual é chamada a instrução LOAD\_GLOBAL. Tal instrução é responsável por carregar um alcance para a estrutura de repetição, o que dirá qual será a última vez que o \textit{loop} será executado.} 

\textbf{Diferentemente da estrutura \textit{while}, a estrutura \textit{for} define os parâmetros de execução antes mesmo de realizar o início do \textit{loop}. Então, são carregados para a pilha como constantes o valor inicial, zero, e o valor final, cinco. Após, é feita uma chamada de função, realizada pela instrução CALL\_FUNCTION, onde o número de parâmetros serão passados como argumento. Ao realizar a chamada desta instrução, é o número de parâmetros é analisado pelo sistema e é realizado o carregamento destes parâmetros, para que possam ser utilizados na execução do \textit{loop}. É então feita as chamadas das instruções GET\_ITER e FOR\_ITER, que criam os blocos de \textit{loop} dentro da pilha. Tais blocos serão utilizados para que as chamadas de instruções internas ao \textit{loop} possam utilizar variáveis sem que as variáveis iniciais sejam perdidas.}

Para finalizar a execução do \textit{loop}, é executado o trecho de código interior à estrutura, é realizado um incremento à variável que gerencia o \textit{loop} e, então, é feito um pulo para a primeira linha da estrutura. Note que, no caso do \textit{for}, a primeira linha considerada não é a chamada de variáveis para realizar a comparação inicial, mas sim a linha 22, onde se encontra a instrução FOR\_ITER. Isso se deve ao fato de que tal instrução gerencia a saída do \textit{loop} ao seu final, e não uma comparação, como no \textit{while}. 

\begin{figure}[htp]
\centering
\includegraphics{images/4_for.png}
\caption{Código \textit{Assembly} de uma estrutura de repetição \textit{for}.}
\label{img_4_for}
\end{figure}

A próxima imagem, Figura \ref{img_5_add}, apresenta a primeira operação aritmética realizada. Através dela, é possível perceber como é feita a conversão de um código alto nível, escrito em \textit{Python}, por parte do compilador, que realiza uma atribuição de variáveis com soma. 

Analisando-a, podemos perceber que mantém-se a estrutura de operações já vista anteriormente com as comparações, onde os dois operandos são carregados para a pilha na ordem inversão em que serão executados. No caso deste algoritmo, em que é feita uma soma simples, a ordem em que os operandos são carregados para a pilha não é importante, visto que o resultado da operação será o mesmo sempre. Contudo, em operações como a que veremos à seguir, onde é feita uma subtração, é importante saber qual será o operando que será carregado antes para a pilha. 

Porém, como podemos perceber na Figura \ref{img_5_add}, só existe uma instrução de carregamento para a pilha. Tal instrução, LOAD\_CONST, pega o valor 15, e o carrega para a pilha. Contudo, ao escrever o código em alto nível, foi definido que o valor a ser salvo na pilha seria \(10 + 5\). Então, podemos concluir que o compilador, visando simplificar a operação e retirar linha de códigos, realizou a soma antes de definir qual seria o argumento da instrução LOAD\_CONST. 


\begin{figure}[htp]
\centering
\includegraphics{images/5_add.png}
\caption{Código \textit{Assembly} de uma operação aritmética de soma com duas constantes.}
\label{img_5_add}
\end{figure}


\begin{figure}[htp]
\centering
\includegraphics{images/5_add_var_int.png}
\caption{Código \textit{Assembly} de uma operação de soma com uma variável e uma constante.}
\label{img_5_add_var_int}
\end{figure}

Diferentemente da Figura \ref{img_5_add}, a Figura \ref{img_5_add_var_int} mostra um código \textit{Assembly} que vem de um algoritmo \textit{Python} que realiza a soma de uma variável com um a constante e armazena o resultado em outra variável. Então, primeiramente, como já visto nas figuras anteriores, existe a criação da primeira variável, onde ela é carregada como constante para a pilha e, após, é salva na memória em um endereço que é referenciado como sendo a primeira variável ("\textit{val1}").

Logo após, carrega-se a variável novamente para a pilha, com a instrução responsável por executar um carregamento de uma variável previamente criada, e carrega-se também a segunda constante, a qual será somada à "\textit{val1}". Com os dois operandos dispostos nas duas posições mais superiores à pilha, executa-se a primeira instrução responsável por executar uma operação aritmética. 

Tal instrução, chamada de BINARY\_ADD, executa uma soma entre dois operandos. Os dois operandos utilizados vêm da primeira e da segunda posição da pilha, respectivamente. Essa instrução não necessita de valores no \textit{byte} de argumentos, visto que seus operandos serão sempre os mesmos e que a operação também será sempre a mesma. Então, seu campo pode aparecer com qualquer valor, pois ele será ignorado. No caso da Figura \ref{img_5_add_var_int}, o campo aparece em branco.

A execução de todas as operações aritméticas, as quais estão sendo mostradas também nas Figuras \ref{img_5_add_var_var}, \ref{img_5_sub}, \ref{img_5_multi} e \ref{img_5_div}, se dá de maneira semelhante. As duas posições topo da pilha, aqui chamadas de TOS e TOS1, sendo a segunda considerada a posição logo abaixo ao topo, são retiradas da pilha e carregadas para uma unidade que realizará a operação aritmética. Tal unidade, por se tratar de uma máquina virtual, é simplesmente simulada e, possivelmente, não exista. Contudo, em uma arquitetura física, uma unidade do tipo se torna indispensável. 

Então, ao serem carregados os dois operandos, executa-se a operação definida pela instrução, que pode ser soma, subtração, multiplicação ou divisão. Ao realizar tal operação, o resultado dela é armazenado no lugar antes ocupado pelo operando TOS1. Então, considera-se, do ponto de vista de posições na pilha, que a operação acontece tal como a Equação \ref{eq_arit_pilha} mostra.

\begin{equation} \label{eq_arit_pilha}
	TOS1 = TOS + TOS1
\end{equation}

Todas as operações aritméticas acontecem da mesma forma, onde a primeira variável a ser carregada (TOS1) se torna o primeiro operando da equação e, a segunda (TOS), o segundo operando. O resultado é salvo no lugar onde estava TOS1.

\begin{figure}[htp]
\centering
\includegraphics{images/5_add_var_var.png}
\caption{Código \textit{Assembly} de uma operação aritmética de soma com duas variáveis.}
\label{img_5_add_var_var}
\end{figure}

A Figura \ref{img_5_add_var_var} realiza a mesma operação aritmética mostrada na Figura \ref{img_5_add_var_int}, com a diferença apenas nas origens dos operandos. Invés da ser executada a soma entre uma variável e uma constante, é executada a soma entre duas variáveis. Então, para isso, é preciso que as duas variáveis tenham sido salvas na memória e, então, carregadas novamente para a pilha. Tal procedimento faz necessário o uso das instruções STORE\_FAST 
e LOAD\_FAST uma vez a mais do que o que foi visto anteriormente.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_sub.png}
\caption{Código \textit{Assembly} de uma operação aritmética de subtração.}
\label{img_5_sub}
\end{figure}

Já as Figura \ref{img_5_sub}, \ref{img_5_multi} e \ref{img_5_div} seguem a mesma lógica empregada na Figura \ref{img_5_add_var_var}, com a diferença de que realizam operações aritméticas diferentes, sendo elas subtração, multiplicação e divisão, respectivamente. Perceba que as instruções aritméticas de cada uma delas estão destacadas nas figuras.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_multi.png}
\caption{Código \textit{Assembly} de uma operação aritmética de divisão.}
\label{img_5_multi}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_div.png}
\caption{Código \textit{Assembly} de uma operação aritmética de divisão.}
\label{img_5_div}
\end{figure}

\subsection{Definição das instruções escolhidas}
\label{def_inst_esc}
Baseados nas análises de algoritmos simples e sabendo que tais algoritmos estão presentes em praticamente 100\% dos algoritmos escritos em \textit{Python}, foi possível definir o conjunto de instruções mínimo para a arquitetura cobrir. As instruções escolhidas para serem executadas deverão possuir suporte na arquitura e serem executadas completamente em \textit{hardware}.

Para iniciar a lista, podemos começar com as instruções de manipulação de dados. Tais instruções são responsáveis por definir quais dados entram e saem da pilha, assim como a ordem que eles entram e o endereço onde o TOS é salvo na memória principal. As instruções dessa categoria que serão implementadas são:

\begin{description}
	\item[LOAD\_CONST]: carregamento de um valor constante, passado por argumento, para o topo da pilha. Tal valor ocupa a posiçao de \textit{opArg} e, portanto, deverá conter 8 \textit{bits}. Tal instrução pode ser considerada a maior importante do código \textit{Assembly}, pois ela é a única que permite a entrada de um valor externo no sistema. Sem ela, nenhum valor poderia ser salvo na memória ou sequer utilizado no sistema.
	\item[LOAD\_FAST]: é a instrução que permite a existência de variáveis. Na programação em qualquer linguagem, a utilização de variáveis é extremamente necessária e importante, para que os valores sejam manipulados dentro dos programas. Quando estamos falando de uma arquitetura física, possuímos números limitados de registradores e memória utilizável pelo sistema, então precisamos salvar os valores que não estão sendo utilizados no momento em algum lugar onde eles possam ser recuperados posteriormente. Tal lugar é a memória principal. Essa instrução é a única que permite a recuperação de um valor previamente salvo na memória principal. Sem ela, seria impossível a existência e manipulação de variáveis dentro de uma arquitetura física. Portanto, ela é de vital importância para o sistema e deverá ser suportada na arquitetura.
	\item[STORE\_FAST]: a instrução anterior, LOAD\_FAST, é de extrema importância para a manipulação de variáveis. Porém ela só atende um lado da manipulação de variáveis, que é o carregamento da memória para a pilha. Contudo, uma variável precisa ser salva na memória principal anteriormente para, então, poder ser carregada. O salvamento de uma variável na memória é feito por essa instrução, sendo, portanto, de extrema importância para a existência de variáveis na arquitetura.
	\item[LOAD\_GLOBAL]: ...............
\end{description}

As quatro instruções de manipulação de dados apresentadas acima possuem total importância para o sistema uma arquitetura física, por ela deverá ser capaz de suprir uma necessidade básica da linguagem \textit{Python}, que é a manipulação de variáveis e dados. Então, a escolha delas é justificada pela extrema importância e pela elevada taxa de utilização delas, que estão presentes em 100\% dos algoritmos, desde os mais simples até os mais complexos. 

Das instruções analisadas na subseção \ref{a_algo_sim}, foi definido que as quatro operações básicas da matemática seriam suportadas na arquitetura física. Para isso, o código \textit{Assembly Python} possui uma instrução específica para cada operação. São elas:

\begin{description}
	\item[BINARY\_ADD]: executa uma soma binária, ou seja, entre dois valores. Os valores escolhidos para tal operação são o TOS e a posição exatamente abaixo dele, salvando o resultado na posição desta última. A operação de soma é uma das operações mais importantes de um sistema, pois ela é necessária para definir-se o topo da pilha e para avançar para outra instrução, incrementando o contador de programa. Contudo, tais operações são operações básicas do sistema e que não dependem desta instrução. Mas, como elas deverão ser implementadas, adicionar também uma instrução que execute uma operação de soma entre dois operandos reaproveitará componentes da arquitetura. As operações aritméticas são de extrema importância, visto que a maioria dos algoritmos executam uma hora ou outra uma manipulação de valores.
	\item[BINARY\_SUBTRACT]: é a instrução responsável por executar uma subtração entre dois operandos. Assim como a instrução anterior, ela executa tal operação entre o TOS e TOS-1, e salva o resultado em TOS-1. 
	\item[BINARY\_MULTIPLY]: é a instrução responsável por executar uma multiplicação entre dois operandos. Caso ela não fosse implementada, sempre que uma operação de multiplicação fosse solicitada na linguagem de alto nível, ela deveria ser realizada através de uma soma sucessiva manualmente (contendo cada instrução de soma no código \textit{Assembly}).
	\item[BINARY\_DIVIDE]: realiza uma divisão entre dois operandos. Sua implementação, assim como a multiplicação, se faz necessária para simplificar o código \textit{Assembly} e acelerar a execução dentro da arquitetura.
\end{description}

Portanto, as instruções responsáveis por operações aritméticas são de extrema importância, visto que a existência de manipulação de números dentro de algoritmos escritos em qualquer linguagem é uma exigência básica. Para viabilizar a utilização de tais operações dentro da arquitetura física, as operações mais importantes foram definidas e receberão suporte na arquitetura.

Podemos ainda citar instruções que executam pulos (\textit{jumps}). Elas são de vital importância, pois nenhum algoritmo de programação executa em uma sequência estática. Muitas vezes, os trechos de código que serão executados dependem de resultados anteriores, podendo pulas trechos e voltar para executar novamente um trecho. As instruções do código \textit{Assembly Python} escolhidas para serem suportadas dentro da arquitetura aqui proposta foram:

\begin{description}
	\item[POP\_JUMP\_IF\_FALSE]: é a instrução utilizada, principalmente, em estruturas \textit{if}, onde se precisa executar um trecho de código escrito logo após uma comparação, quando ela é falsa. Ela executa um pulo onde o valor do contador de programa (PC) é completamente substituido pelo valor contido no argumento (\textit{opArg}) da chamada desta instrução. Porém, só ocorrerá a substituição caso o resultado de uma comparação executada anteriormente seja negativo. Ela é extremamente importante para facilitar a tomada de decisão dentro de um algoritmo.
	\item[POP\_JUMP\_IF\_TRUE]: é exatamente a operação inversa à instrução anterior. Ela não aparece em nenhum dos algoritmos apresentados na subseção \ref{a_algo_sim}, porém sua implementação utiliza a mesma base da instrução anterior. Logo, sua implementação simplesmente precisa ser executada caso a comparação retorne como sendo positiva.
	\item[JUMP\_FORWARD]: é a instrução utilizada, principalmente, para executar a saída do trecho executado em uma comparação, quando a mesma retorna como sendo positiva. Ela realiza um incremento do valor do contador de programa, substituindo-o pelo novo valor. Seu argumento é chamado de \textit{delta} e é o valor usado para ser somado a PC. Ela é utilizada dentro das estruturas \textit{if} porque seu funcionamento permite que o compilador simplesmente veja quantas linhas de código devem ser executadas quando a comparação for positiva e, então, incrementar o valor do contador com esse valor. Isso acontece porque, quando tal instrução é escrita pelo compilador, ainda não foi definido qual será o primeiro valor de PC que estará fora da estrutura \textit{if}. Sendo assim, se torna difícil utilizar a próxima instrução.
	\item[JUMP\_ABSOLUTE]: é a instrução responsável por substituir completamente o valor de PC pelo seu argumento. Ela é utilizada, principalmente, em estruturas de repetição, pois é preciso retornar ao início da estrutura sem realizar nenhuma comparação prévia. Então, salva-se como \textit{OpArg} desta instrução o valor da primeira linha da estrutura e, ao ser executada essa instrução, o valor de PC é substituído e reinicia-se a repetição.
\end{description}


\begin{description}
	\item[COMPARE\_OP]
	\item[SETUP\_LOOP]
	\item[GET\_ITER]
	\item[FOR\_ITER]
\end{description}


\begin{description}
	\item[CALL\_FUNCTION]
	\item[RETURN\_VALUE]
	\item[POP\_BLOCK]
\end{description}


\section{Análise de requisitos para a arquitetura}
\label{a_requisitos}

Após realizadas as análises de quais serão as instruções a serem implementadas, inicialmente, na arquitetura, é preciso projetar a arquitetura de forma que consiga atender a todos os requisitos necessários. Para isso, atender a todas as instruções acima descritas se torna necessário. 

Para iniciar tal análise, foram separadas em subseções diferentes os diferentes tipos de instruções, tais como foram separadas na subseção \ref{def_inst_esc}. Isso se deve ao fato de que analisar, inicialmente, a arquitetura como um todo é inviável, visto que sua complexidade é considerável.

\subsection{Conceitos básicos}
\label{a_requisitos_basicos}

Antes de iniciar a análise das instruções propriamente ditas, é necessário que a arquitetura consiga suportar a entrada e o gerenciamento delas. Para isso, é preciso que conceitos básicos de execução de algoritmos sejam analisados. \textbf{CITAR REFERENCIA DE EXECUÇÃO DE ALGORITMOS PC+1} 

Ao executar-se um algoritmo, as instruções \textit{Assembly} são salvas em uma memória específica para elas e, então, são percorridas sequencialmente, podendo haver pulos entre elas. Então, o primeiro componente que deve ser adicionado na nossa arquitetura é uma memória de instruções, chamada de \textit{memInstr}. Ela será responsável por salvar os argumentos e instruções, tais como foram apresentados na seção \ref{rf_modos_enderecamento}. Então, cada posição de sua memória deverá receber uma instrução, juntamente com seu argumento (mesmo que ele seja dispensável). 

Porém, para manter essa funcionalidade, serão necessários ainda três outros componentes. O primeiro deles, o qual irá gerenciar qual será a instrução lida no momento, será um registrador de contador de programa, chamado de \textit{regPc}. Tal registrador irá apontar para o endereço na memória de instrução que está sendo executado a cada instante. Então, quando \textit{regPc} possuir como saída o valor binário 00000000, indicará que essa posição na memória de instruções está sendo lida e, por conseguinte, sendo executada pela arquitetura. 

A cada instrução executada no processador, o valor de saída do \textit{regPc} será atualizado com a soma do valor um. Assim sendo, o programa irá ser executado sequencialmente. Contudo, existe a possibilidade de serem realizados pulos, que será apresentados na subseção \ref{a_requisitos_jump}. Esses pulos substituirão o valor de \textit{regPc}, redirecionando, então, para a execução de uma instrução fora de ordem.

O segundo componente responsável pela execução básica do programa é um registrador que salvará a instrução de 8 \textit{bits} que está sendo executada no momento. Tal registrador, chamado de \textit{regInstr}, irá receber um valor diretamente da memória de instruções e o passará diretamente para o controle, o qual será apresentado na seção \ref{projeto_control} e será responsável por tomar todas as decisões de execução. 

O último componente apresentado nesta subseção é o registrador que salvará os argumentos das instruções executadas. Esse registrador, chamado de \textit{regArg}, manterá os valores dos argumentos estáveis para que possam ser utilizados a qualquer momento durante a execução. Instruções como COMPARE\_OP e LOAD\_CONST utilizam seus argumentos em diferentes momentos. Logo, é necessário que o argumento se mantenha estável durante toda a execução de uma instrução. O \textit{regArg} terá ligação direta com o registrador de endereços e registrador de pilha, apresentados na subseção \ref{a_requisitos_dados}.

Então, os componentes básicos para que a arquitetura consiga executar códigos são uma memória de instruções, \textit{memInstr}, um registrador para o contador de programa, \textit{regPc}, e dois registradores para instruções e argumentos, \textit{regInstr} e \textit{regArg}, respectivamente. Com todos esses componentes básicos de execução, é possível que um código \textit{Assembly} seja executado por completo, realizando pulos e executando sequencialmente. 

A Figura \ref{img_analisebasicos} apresenta os componentes apresentados nessa subseção e que são utilizados para a realização da execução básica de qualquer algoritmo no processador. Nela, é possível perceber uma memória de instruções (\textit{memInstr}) que possui uma entrada, que é o valor de PC, e duas saídas, que são o valor de \textit{opCode} e \textit{opArg}, apresentados na seção \ref{rf_modos_enderecamento}. Além da memória, existem três registradores, considerados simples, pois possuem uma entrada de dados, uma saída de dados e uma entrada de controle, chamada de "\textit{ctrl}". Contudo, ainda existe uma outra entrada, a qual não foi mostrada na Figura, que recebe o valor do \textit{clock} do processador. Os três registradores são, então, os registradores o de contador de programa (\textit{regPc}), o de argumento (\textit{regArg}) e o de instruções (\textit{regInstr}). 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_basicos.png}
\caption{Componentes utilizados o funcionamento básico do processador.}
\label{img_analisebasicos}
\end{figure}


\subsection{Instruções de gerenciamento de dados}
\label{a_requisitos_dados}

O primeiro conjunto de instruções engloba as instruções responsáveis pelo gerenciamento de dados e variáveis dentro da arquitetura. As instruções escolhidas para esta área, tal como foi dito anteriormente, foram: LOAD\_CONST, LOAD\_FAST, LOAD\_GLOBAL e STORE\_FAST.

Iniciando, então, uma análise de requisitos para essa área, percebemos que serão necessárias, além da memória de instruções, apresentada na subseção \ref{arq_basico}, mais duas memórias. A primeira memória e, igualmente importante à segunda, será a pilha. Dentro dela serão encontrados todos os dados que estão em uso durante a execução de um algoritmo \textit{Python}. Logo, será possível encontrar no seu interior dados como operandos de uma operação aritmética, dados que estão aguardando para serem salvos na memória e dados que estão entrando no sistema como constantes.

Como tal componente é uma pilha, pressupõe-se que todos os dados que o último dado que entrar nela será o primeiro a sair. Este trabalho não abordará profundamente conceitos de pilha. Tais conceitos podem ser encontrados em \cite{Aho}.

Então, sabendo que a saída de uma pilha deverá ser sempre o último valor que entrou, ou seja, seu topo, é necessário que exista um valor que controle qual é o valor que está saindo a cada instante. Para isso, será necessária a utilização de um registrador de topo, chamado de \textit{regTos}, que estará ligado diretamente com a entrada de endereços da pilha. Sempre que for realizada uma entrada de dados, o valor presente no registrador deverá ser atualizado com o acrescimento de uma unidade. Quando existir uma retirada de dados, o ponteiro deverá apontar para a posição logo abaixo do dado retirado, ou seja, dever-se-a subtrair uma unidade do valor.

Juntamente a pilha, é necessário que exista um componente que irá armazenar valores de entrada e de saída da pilha para que eles fiquem estáveis enquanto são utilizados por outros componentes. Para tal finalidade, foi incluído o registrador de pilha, chamado de \textit{regPilha}, responsável por salvar dados que entrarão na pilha e dados que estão saindo da pilha. Esse registrador permite que os dados fiquem estáveis por tempo suficiente, permitindo que outros componentes ou a pilha realize as operações utilizando sua saída.

O \textit{regPilha} possui duas entradas e duas saídas. O primeiro par será para os dados que irão ser salvos na pilha, então, com um sinal de controle definido para escrita na pilha, a entrada de escrita (\textit{entrada\_write}) terá permissão para salvar seu valor na saída de escrita (\textit{saída\_write}). O dado escrito nessa saída terá como destino a entrada de escrita da pilha. 

O outro par de pinos do \textit{regPilha} é utilizado para dados que estão saindo da pilha. Então, ao ler-se um dado da pilha, é necessário salvá-lo no \textit{regPilha} na saída de operandos, nome dado à esse pino. Tal pino terá como destino final as entradas de operandos da unidade lógica aritmética (ULA), que será abordada em detalhes na subseção \ref{a_requisitos_arith}, e a entrada de escrita na memória externa, que será abordada ainda nesta subseção.

Definidos os dois componentes responsáveis pelo pleno funcionamento do componente pilha (\textit{regPilha} e \textit{regTos}), passamos então para a memória externa. Tal memória terá o mesmo funcionamento de uma memória RAM comum, onde os dados serão salvos em um endereço específico dentro da memória e só poderão ser acessados posteriormente com a utilização do mesmo endereço. Para maiores informações sobre o funcionamento básico de uma memória RAM, recomenda-se a leitura de (\textbf{CITAR ARTIGO SOBRE FUNCIONAMENTO DA MEMÓRIA RAM}).

A memória externa possui como característica principal o fato de estar sempre lendo um de seus endereços. Tendo, portanto, uma saída durante todo o período de execução, mesmo que ela não seja utilizada para nada. Porém, a escrita no seu interior depende de um sinal de controle específico que permitirá que exista uma escrita na próxima borda de relógio (\textit{clock}).

Contudo, juntamente com a memória, deverão existir dois sistemas que salvarão informações essenciais para o correto funcionamento da memória. O primeiro, chamado de registrador de endereço, \textit{regEnd}, é responsável por manter estável o endereço que está sendo lido a cada instante na memória. Sua atualização é feita através da entrada do registrador de argumentos, \textit{regArg}, apresentado em detalhes na subseção \ref{a_requisitos_basicos}. 

Além do \textit{regArg}, dever-se-á existir um registrador semelhante ao \textit{regPilha}, o qual será responsável por manter estáveis dados lidos da memória e dados que serão escritos nela. Seu funcionamento é similar ao funcionamento do registrador de pilha, o qual possui dois pinos de entrada e dois de saída, divididos em pares. O pino que permitirá a escrita na memória receberá dados diretamente do \textit{regPilha}. Já o pino que permitirá a leitura de dados da memória passará os dados para o mesmo registrador, porém em outra entrada. O registrador de memória externa recebe o nome de \textit{regMemExt}.

A Figura \ref{img_analisedados} apresenta todos os componentes utilizados para manipulação de dados dentro do processador. Nela, aparecem os componentes pilha, memória externa (\textit{memExt}), registrador de pilha (\textit{regPilha}), registrador de endereço (\textit{regEnd}), registrador de \tos (\textit{regTos}) e o registrador de memória externa (\textit{regMemExt}). É possível ver, na imagem, todas as entradas e saídas previstas para esses componentes. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_dados.png}
\caption{Componentes utilizados para instruções de gerenciamento de dados.}
\label{img_analisedados}
\end{figure}


\subsection{Instruções de operações aritméticas e comparações}
\label{a_requisitos_arith}

As instruções de aritméticas e de comparações utilizam praticamente os mesmos componentes. Porém, a grande diferença é que cada uma delas salva o resultado em locais diferentes. 

O componente principal desta área é a unidade lógica aritmética (ULA), que será responsável por executar as operações propriamente ditas. Contudo, para que as operações consigam chegar na ULA e sair dela, são necessários outros componentes auxiliares. Os dois primeiros componentes, responsáveis elas entradas dos operandos a serem executados na ULA, são os registradores de operandos, \textit{regOp1} e \textit{regOp2}. Eles possuem ligações com as entradas de operandos do componente. Suas finalidades são menter os valores que serão utilizados nos calculos da ULA estáveis até que o resultado seja salvo.

Isso acontece porque a unidade lógica não utiliza períodos de relógio para gerar resultados nem armazena nada em seu interior. Assim sendo, quando há uma mudança ou instabilidade na entrada da ULA, tal acontecimento reflete diretamente no resultado. Daí a importância de manter as entradas estáveis durante todo o período entre a entrada dos dados na ULA e o salvamento do resultado.

Posicionado do outro lado da ULA, estão os componentes de saída. Eles somam, ao todo, três, sendo que um deles já foi apresentado na seção anterior. Começando pelo componente que já foi apresentado na subseção \ref{a_requisitos_dados}, temos o \textit{regPilha}, o qual é responsável por salvar o resultado de dados. Isso acontece porque o resultado da ULA em operações aritméticas é salvo diretamente na pilha. Logo, é possível aproveitar o mesmo componente para salvar diretamente na pilha.

O segundo componente, chamado de registrador de \textit{overflow} ou \textit{regOverflow}, é o registrador que salvará um sinal indicando se o resultado da ULA ultrapassou o número de \textit{bits} suportado pelo sistema ou não. Então, quando tem-se que a saída deve possuir o mesmo número de \textit{bits} que as entradas, operações como multiplicação e soma podem gerar valores que não podem ser salvos. Quando é feita uma multiplicação em valores binários, o resultado possui o tamanho de \(t1 + t2\), sendo \textit{t1} o tamanho do primeiro operando e \textit{t2} o do segundo. \textbf{CITAR REFERÊNCIA DE MULTIPLICAÇÃO BINÁRIA} Logo, em uma operação com dois operandos de mesmo tamanho, o resultado é um valor com o dobro do tamanho. 

Contudo, caso a primeira metade do resultado possua apenas zeros, eles podem ser descartados e a saída da ULA será do mesmo tamanho das entradas. Nesse caso, o valor salvo no \textit{regOverflow} será zero, pois o valor salvo como resultado não possuiu nenhuma alteração forçada pelo número de \textit{bits}. Já quando o resultado de uma operação multiplicação, por exemplo, possuir um valor 1 presente na metade mais significativa do valor, apenas a parte menos significativa será considerada. Logo, haverá uma alteração no resultado final forçada pela quantidade de \textit{bits}. Nesse caso, considera-se que houve um excesso de valores (\textit{overflow}) e é salvo, em \textit{regOverflow}, o valor 1. 

O último componente desta classe de instruções é o registrador responsável por salvar o resultado da comparação, sendo ele verdadeiro ou falso. Chamado de \textit{regComp}, tal registrador é ligado quando há a execução da instrução COMPARE\_OP e recebe 0 ou 1, sendo o segundo referente à uma comparação verdadeira e o outro falsa. Esse registrador se faz necessário visto que a pilha não possui ligações com a unidade de controle, logo, as instruções de pulos, que serão vistas na subseção \ref{a_requisitos_jump}, não poderam ser executadas. 

Então, nesta classe de instruções, temos uma unidade lógica aritmética (ULA), dois registradores de operandos (\textit{regOp1} e \textit{regOp2}) e três registradores de saída (\textit{regPilha}, \textit{regOverflow} e \textit{regComp}).  

A Figura \ref{img_analisearith} apresenta todos os componentes utilizados para a realização de operações aritméticas no processador. Os componentes nela presentes são a unidade lógica arimética (ULA), dois registradores de operandos (\textit{regOp1} e \textit{regOp2}), o registrador de comparação (\textit{regComp}) e o registrador de \textit{overflow} (\textit{regOverflow}).

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_aritmeticas.png}
\caption{Componentes utilizados para instruções que realizam operações aritméticas e comparações.}
\label{img_analisearith}
\end{figure}

\subsection{Instruções de pulos}
\label{a_requisitos_jump}

A classe de instruções responsáveis por executar pulos dentro do código \textit{Assembly} salvo na memória de instruções não necessita de nenhum componente específico para ela. Todas as operações realizadas por ela utiliza componentes que já foram citados nas subseções anteriores.

Então, para executar uma instrução que substitui o valor de \textit{regPc} seu argumento, tal como JUMP\_ABSOLUTE, utiliza-se a unidade lógica aritmética (ULA), que tem seu resultado diretamente ligado à entrada do registrador e sua entrada ligada, também, ao registrador de argumento. A seção \ref{projeto_arq} irá mostrar com mais detalhes as ligações necessárias para que se utilize os mesmos componentes para diferentes funções. Contudo, para se utilizar a ULA, precisa-se realizar uma operação lógica ou aritmética entre dois operandos. Como temos um valor que deverá substituir o valor de \textit{regPc}, a operação ideial é uma soma por zero. 

Em uma instrução onde se realiza um pulo controlado por um \textit{delta}, o qual será somado no valor de \textit{regPc} atual, utiliza-se, também, a ULA. Então, é necessário utilizar a saída de \textit{regPc} em uma entrada da ULA (que ela naturalmente é) e utilizar em outra entrada da ULA o valor que deverá ser somado ao PC. Após obter-se o resultado, ele é salvo no \textit{regPc} e a instrução é finalizada.

Nas instruções que necessitam de uma comparação anterior para serem executadas, utilizar-se-á o registrador de comparação. Tal registrador, ligado ao controle, o fará decidir se realizar-se-á a substituição do valor de \textit{regPc} pelo valor do argumento da instrução ou não. Caso a substituição seja feita, ela ocorre exatamente como foi detalhado na explicação da instrução JUMP\_ABSOLUTE. Caso ela seja ignorada, simplesmente soma-se o valor um ao valor de PC atual e segue-se executando as próximas instruções. As instruções que realizam pulos conforme o resultado de uma comparação são POP\_JUMP\_IF\_TRUE e POP\_JUMP\_IF\_FALSE.

Como dito anteriormente, para a realização de pulos não é necessário incluir nenhum novo componente, já que tais instruções utilizam componentes básicos e de operações aritméticas, apresentados nas Figuras \ref{img_analisebasicos} e \ref{img_analisearith}, respectivamente. 

\section{Projeto da arquitetura}
\label{projeto_arq}

Após realizar uma analise de todos os componentes necessários para que todos os tipos de instruções escolhidas sejam executados, é preciso fazer um projeto de arquitetura que consiga ligar todos eles e que seja eficiente. Porém, não é só eficiência que é necessário, mas também economia de componentes, adicionando o mínimo de componentes possível e reutilizando o que puder ser reutilizado. 

Essa seção, então, apresentará como foi realizado o projeto da arquitetura, visando a correta execução de todas as instruções até aqui apresentadas. Para melhor entendimento, ela foi dividida em tópicos seguindo o mesmo padrão da seção \ref{a_requisitos}, sendo que cada um tratará de um tipo de instrução específico. Ao final, é possível encontrar uma subseção responsável pro realizar a interligação entre todas as arquiteturas propostas nas subseções anteriores. 

Assim, seguindo a mesma ordem da seção \ref{a_requisitos}, a primeira subseção sobre projeto, subseção número \ref{pArq_basicos}, será sobre os conceitos de funcionamento básico da arquitetura. Logo após, pode ser encontradas as subseções de gerenciamento de dados, operações aritméticas e comparações, e pulos, com números \ref{pArq_dados}, \ref{pArq_arith} e \ref{pArq_pulos}, respectivamente. Finalizando esta seção, está a subseção \ref{pArq_geral}, que apresenta todas as ligações unidas e a adição de componentes visando o reaproveitamento de componentes. 

\subsection{Conceitos Básicos}
\label{pArq_basicos}

Como dito na subseção \ref{a_requisitos_basicos}, os componentes aqui presentes e apresentados terão como propósito a execução básica de um algoritmo, executando a movimentação entre as instruções e leitura das mesmas. Esse tipo de arquitetura dispõe dos registradores de contador de programa (\textit{regPc}), de instrução (\textit{regInstr}) e de argumento (\textit{regArg}). Além disso, existe uma memória de instruções. 

Na Figura \ref{img_analisebasicos}, lá na subseção \ref{a_requisitos_basicos}, podemos ver que a memória de instruções possui uma entrada e duas saídas. Começando então por ela, o componente mais importante desta nossa arquitetura parcial, podemos perceber que a sua entrada é um endereço de memória. Como é necessário que a posição de memória da instrução que está sendo executada a cada instante permaneça sempre salva, existe o \textit{regPc}. Então, a entrada da memória de instruções deverá ser ligada no registrador capaz de salvar o endereço de memória da instrução lida. 

Assim, fazemos nossa primeira ligação, que será a entrada da memória de instrução com o registrador PC (\textit{regPc}), como poderá ser visto na Figura \ref{img_pArq_basicos}. Mas a figura só será apresentada e explicada detalhadamente ao final desta subseção. 

Então, o \textit{regPc} é o registrador responsável por indicar a posição da memória de instrução que deverá ser lida. Como a cada instrução lida deve-se incrementar o registrador PC em 1 (caso não seja uma instrução de pulo, que será abordada na subseção \ref{pArq_pulos}), então a entrada do registrador PC deverá estar ligada na saída da unidade lógica aritmética, assim como a saída de \textit{regPc} deverá estar ligada em uma das entradas da ULA. Como veremos na subseção \ref{pArq_arith}, a ULA deverá ter diversas entradas diferentes dependendo do que está sendo executado, então dever-se-á adicionar um multiplexador \textbf{CITAR REFERENCIA DE MUX}.

Um multiplexador, chamado também de \textit{mux}, é um componente de seleção, capaz de receber diversas entradas e selecionar uma delas para sair em sua única saída. A insersão de multiplexadores na arquitetura será apresentada na subseção \ref{pArq_geral}. Por ora, basta saber que a entrada de \textit{regPc} é um resultado vindo de uma operação na unidade lógica aritmética.

Até agora, portanto, definimos que a entrada de \textit{regPc} é ligada à saída da ULA e sua saída é ligada à entrada da ULA e à entrada da memória de instruções. Passaremos então para os dois registradores remanescentes. Para entender o funcionamento dos dois registradores, é preciso entender que cada bloco de memória presente na memória de instrução possui 16 \textit{bits}. Assim, ao ler o bloco que \textit{regPc} está apontando, quebra-se ele em dois valores de 8 \textit{bits} e os encaminha para cada uma das saídas da memória de instrução. Como apresentados na seção \ref{rf_modos_enderecamento}, os primeiros 8 \textit{bits} são identificados como o argumento da instrução e, portanto, são enviados para o registrador de argumento (\textit{regArg}). Já os 8 \textit{bits} finais são o código identificador de instrução (que mostram qual instrução deve ser executada) e são enviados para o registrador de instrução (\textit{regInstr}). 

Tendo as entradas dos registradores de argumento e instrução, veremos então suas saídas. O primeiro registrador tem sua saída ligada a uma das entradas do controle, ao registrador de endereço e ao multiplexador do registrador de pilha (mostrados na subseção \ref{pArq_dados}). O motivo pelo qual sua saída está ligado ao controle é a instrução de comparação, que tem seu tipo de comparação definido como argumento. Sendo assim, o controle precisa saber qual é a comparação que deve ser executada para que consiga selecionar a operação correta na ULA. Já o motivo para a saída de \textit{regArg} está ligada ao multiplexador do registrador de pilha é a instrução de carregamento de constante (LOAD\_CONST), que deve salvar o valor do argumento diretamente na pilha. Enquanto isso, os motivos para a mesma saída estar ligada ao registrador de endereço são as instruções de carregamento e salvamento na memória externa (LOAD\_FAST e STORE\_FAST), que salva e carrega diretamente em um endereço da memória, especificado por argumento.

A Figura \ref{img_pArq_basicos}, como dito anteriormente, apresenta as ligações mensionadas acima. Na extrema esquerda, podemos encontrar o registrador PC (\textit{regPc}), ligado à entrada da memória de instruções (\textit{memInstr}). Já à direita, podemos encontrar os dois registradores, argumento (\textit{regArg}) e instrução (\textit{regArg}), ligados às duas saídas da memória de instruções.  

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_basicos.png}
\caption{Arquitetura parcial responsável pela funcionalidade básica.}
\label{img_pArq_basicos}
\end{figure}

\subsection{Gerenciamento de Dados}
\label{pArq_dados}

Falando, então, sobre a arquitetura parcial responsável pelas instruções de gerenciamento de dados, realizaremos a conexão dos componentes apresentados na subseção \ref{a_requisitos_dados}. Tais componentes são: uma pilha, uma memória externa (\textit{memExt}), um registrador de pilha (\textit{regPilha}), um registrador de memória externa (\textit{regMemExt}), um registrador de \tos (\textit{regTos}) e, por último, um registrador de endereço (\textit{regEnd}). 

Partindo então do registrador de pilha (\textit{regPilha}), podemos perceber, através da imagem (Figura \ref{img_analisedados}) apresentada na subseção \ref{a_requisitos_dados}, que ele possui duas entradas e duas saídas. Tal registrador poderia ser dividido em dois registradores diferentes: o primeiro responsável por escrita na pilha e o segundo responsável por leitura da pilha. Porém, não foi realizada essa divisão visando economizar em um componente e permitindo que a arquitetura ficasse mais limpa. 

As primeiras entrada e saída do \textit{regPilha} que falaremos são as responsável por operações de escritas na pilha. Denominadas "\textit{entradaWrite}" e "\textit{saídaWrite}", elas possuem conexão direta entre elas. A entrada é conectada ao multiplexador que gerencia suas entradas, o qual será comentado na subseção \ref{pArq_geral}. Já a saída está conectada diretamente na entrada de escrita da pilha, denominada "\textit{entradaWrite}".

O segundo par de entrada e saída são os de leitura da pilha. O pino de entrada, denominado "\textit{entradaDados}" está conectado ao pino de saída de leitura da pilha, chamado de "\textit{saidaRead}". Já o pino de saída está conectado aos dois operandos da ULA e ao registrador de memória externa. Além dos dois pares de pinos deste registrador, ainda existe mais um pino, denominado "\textit{ctrl}" e com nome formal de "controle". Este pino se divide em dois pinos de entrada de controle, cada um para controlar um par de entrada e saída, e ambos são conectados em saídas diferentes da unidade de controle. Os sinais recebidos do controle servirão para habilitar ou desabilitar a escrita nos pinos de saída de ambos os pares. 

Passando para o próximo componente, temos a pilha, que já teve um par de entrada e saída conectados ao \textit{regPilha} e, agora, falta só o último pino. Tal pino está conectado à saída do registrador de topo, \textit{regTos}, e é responsável por indicar qual posição da pilha está sendo lido. Sempre que é feito uma operação de escrita ou leitura da pilha, o valor deste registrador, por meio da ULA, é atualizado e sempre guardará a posição que está sendo lida na saída de leitura da pilha. 

Além dos três pinos aqui citados, existe um quarto pino, o qual não está presente na Figura \ref{a_requisitos_dados}, mas é necessário. Este pino é o de controle de escrita. Uma memória que possui dois pinos (entrada e saída) pode ter a propriedade de estar sempre lendo, mas precisa de um comando para saber quando deve salvar determinado valor. Então, no pino de saída da pilha, sempre existe um valor (o qual é apontado pelo valor de \textit{regTos}). Já o valor presente no pino de entrada da pilha só será aproveitado caso o controle da pilha esteja ativo. Caso contrário, o valor é ignorado. 

O próximo trio de componentes (memória externa, registrador de memória externa e registrador de endereço) possui seu funcionamento parecido com o que já foi apresentado aqui. A memória externa tem seu funcionamento idêntico à pilha e o registrador de memória externa também possui funcionamento similar ao registrador de pilha. A grande diferença, e o que define que o primeiro trio possui uma pilha o segundo não, é o registrador de endereço. A função é a mesma do registrador de topo (\textit{regTos}), porém, invés de ter seu valor atualizado a cada operação, sua saída é atualizada conforme o valor do registrador de argumento. Isso faz com que uma posição de memória especifica possa ler lida a qualquer momento, sem a necessidade de executar leituras sucessivas para conseguir acessar um dado que foi carregado no inicio da execução, como é o caso da pilha, que sempre lê o último dado carregado. 

A Figura \ref{img_pArq_dados} apresenta todas as conexões citadas acima. Nela, podemos ver os seis componentes conectados entre si. Porém, como já foi dito, vemos somente uma entrada de controle (\textit{ctrl}) nos registradores de memória externa e pilha, porém dividimos essa entrada em duas. O motivo de estar aparecendo somente um pino foi para evitar que a imagem ficasse sobrecarregada de informações.  

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_dados.png}
\caption{Arquitetura parcial responsável pela execução de instruções de gerenciamento de dados.}
\label{img_pArq_dados}
\end{figure}

\subsection{Operações Aritméticas e Comparações}
\label{pArq_arith}

A arquitetura parcial responsável por realizar operações aritméticas e comparações, como dito na subseção \ref{a_requisitos_arith}, possui cinco componentes básicos: uma unidade lógica aritmética (ULA), dois registradores de operandos (\textit{regOp1} e \textit{regOp2}), um registrador de comparação (\textit{regComp}) e um registrador de \textit{overflow} (\textit{regOverflow}). Todos os componentes são conectados entre si, mas possuem suas entradas externas, como no caso dos operandos, e suas saídas para fora da arquitetura parcial, como é o caso dos registradores de \textit{overflow} e comparação.

Iniciando nossa análise sobre os dois registradores de operandos, ambos possuem suas entradas conectadas à saída de leitura do registrador de pilha, que foi explicado na subseção \ref{pArq_dados}. O registrador de pilha, então, lerá cada um dos operandos da pilha e os salvará, em instantes diferentes, em cada um dos registradores de operandos. O primeiro que receberá o operando, conforme apresentado na subseção \ref{a_algo_sim}, é o registrador operando 1 (\textit{regOp1}), que será o segundo operando da operação, conforme equação \ref{eq_pArq_arith}. O segundo a receber seu valor é o \textit{regOp2}, que será o primeiro operando da ULA.

\begin{equation}
\label{eq_pArq_arith}
	RESULTADO = OP2 + OP1
\end{equation}

Ambos os registradores estão conectados diretamente nas entradas de operandos da ULA, a qual é responsável pela execução das operações aritméticas e comparações. Para definir o que será executado, é utilizado um seletor, vindo do controle, que entrará através do pino denominado "\textit{entradaSeletor}". Esse seletor possui 3 \textit{bits} e pode escolher uma entre as quatro operações aritméticas previstas para serem implementadas nesse trabalho, assim como uma das três comparações possíveis. Sendo assim, existe uma posição de operação vazia, pois o mesmo seletor poderia selecionar entre oito diferentes tipos de operações.

Ainda na ULA, existem três saídas, as quais são responsáveis por apresentar os resultados das operações para componentes externos. As duas primeiras, as quais seus registradores estão presentes nesta arquitetura parcial, são as de comparação e \textit{overflow}. A primeira, conectada no \textit{regComp}, define se determinada operação de comparação é verdadeira ou falsa, salvando 0 ou 1 no registrador de comparação, que por sua vez estará conectado ao controle. 

Já a saída de \textit{overflow}, conectada ao \textit{regOverflow}, é utilizada apenas em operações de multiplicação. Como operações de multiplicação possuem a quantidade de \textit{bits} definida como a soma o número de \textit{bits} dos dois operandos, espera-se que o resultado tenha 16 \textit{bits}. Contudo, só serão aproveitados os 8 \textit{bits} à direita. Então, sempre que existir um \textit{bit} com valor 1 entre os 8 \textit{bits} à esquerda, o registrador de \textit{overflow} salvará o valor 1, indicando que houve \textit{overflow} e que o resultado da ULA pode estar comprometido. O \textit{regOverflow}, assim como o \textit{regComp}, é conectado a uma entrada da unidade de controle. 

Por último, temos a saída de resultado normal, utilizada para todas as operações aritméticas. Nas comparações, essa saída sairá zerada. Ela é conectada diretamente ao registrador PC (\textit{regPc}), ao registrador de \tos (\textit{regTos}) e ao registrador de pilha (\textit{regPilha}).

A Figura \ref{img_pArq_arith} apresenta um esboço da arquitetura parcial responsável pela execução das instruções aritméticas e comparação. Nela, podem ser vistos os cinco componentes conectados entre si e pinos de entrada e saída deles, que são conectados a componentes externos a essa arquitetura. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_aritmeticas.png}
\caption{Arquitetura parcial responsável pela execução de instruções de operações aritméticas e comparação.}
\label{img_pArq_arith}
\end{figure}

\subsection{Instruções de Pulos}
\label{pArq_pulos}

\subsection{Arquitetura Geral}
\label{pArq_geral}

\section{Projeto do controle}
\label{projeto_control}