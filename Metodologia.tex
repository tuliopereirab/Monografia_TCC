Para iniciar o desenvolvimento do sistema, foi necessário, anteriormente, definir o conjunto de instruções básico que seria implementado. Isso porque, para propor uma arquitetura funcional e que atenda todos os requisitos, é preciso já possuir o conjunto de instruções básico que deve ser implementado. Dessa forma, é possível fazer uma análise concreta dos componentes necessários na arquitetura.

A seção \ref{a_instrucoes} apresenta detalhadamente como foi escolhido o conjunto de instruções a ser implementado nesse trabalho. Após a escolha do mesmo, foi feita uma análise de requisitos do sistema, onde todas as instruções escolhidas foram analisas e foram definidos os componentes que devem estar presentes na arquitetura final. Esta parte do projeto está detalhada na seção \ref{a_requisitos}.

\section{Análise das instruções}
\label{a_instrucoes}

Antes de começar, então, o planejamento para desenvolvimento da arquitetura propriamente dita, com suas ligações entre componentes e seu controle, foi preciso definir o que a arquitetura seria capaz de fazer. Como o tempo para o desenvolvimento deste trabalho não permite que todas as instruções presentes na máquina virtual da linguagem \textit{Python} sejam implementadas, foi preciso definir um conjunto de instruções que possa ser implementado dentro do prazo e que permita que algoritmos simples sejam executados. 

A subseção \ref{a_algo_sim} apresenta alguns algoritmos simples que foram implementados em alto nível e, após, foram obtidos seus códigos \as{}. De posse desses códigos, foi feita, na subseção \ref{a_instrucoes_algo}, uma análise dos resultados obtidos e, portanto, uma seleção das instruções a serem implementadas diretamente na arquitetura.

\subsection{Apresentação dos algoritmos utilizados}
\label{a_algo_sim}
Para escolher as instruções, foi necessária uma análise de diversos algoritmos implementados em \textit{Python} e que são considerados simples. Tais algoritmos servem como base para diversos outros algoritmos, já que são operações matemáticas básicas, manipulação de dados dados e pulos (\textit{jumps} ou desvios). 

Então, foram definidos 12 algoritmos que seriam utilizados como base para projetar a arquitetura, já que os trechos que código que os compõem estão presentes em praticamente todos os algoritmos \textit{Python} mais complexos. Os algoritmos escolhidos são:

\begin{description}
	\item[Criação de variáveis numéricas]: é um algoritmo que simplesmente cria uma variável \textit{Python} e atribui um valor numérico a ela, podendo ser qualquer valor. O propósito desse algoritmo é entender como uma variável é salva na memória externa (\textit{RAM}) do sistema.
	\item[Comparação simples]: criou-se um algoritmo que continha uma comparação \textit{if} simples com um bloco de instruções internas que seria executado caso a afirmação feita na comparação fosse verdadeira, ou então seria ignorado por completo. A comparação foi criada para que fosse possível entender como é feita uma comparação dentro do código \textit{Assembly Python} e entender quais as instruções encarregadas por desvios, comparação e carregamento de variáveis da memória para a pilha.
	\item[Comparação com \textit{else}]: é um algoritmo que contém uma chamada \textit{if} e, após, uma chamada \textit{else}. Este algoritmo foi utilizado para analisar como funciona, do ponto de vista do código \textit{Assembly}, o uso de um \textit{else}, indicando que, caso a afirmação contida no \textit{if} retorne como sendo falsa, o trecho de código interno ao \textit{else} seria executado. 
	\item[Comparação com \textit{elif} e \textit{else}]: é o algoritmo que contém, além do \textit{if} e \textit{else} no início e no final, respectivamente, uma comparação intermediária chamada, na linguagem \textit{Python}, de \textit{elif}. Essa segunda comparação será executada caso ela seja verdadeira e a primeira seja falsa. Esse algoritmo foi utilizado para verificar a existência de diferenças entre o uso do \textit{elif} e os outros algoritmos de comparação apresentados anteriormente.
	\item[Estrutura de repetição \textit{while}]: foi criado um algoritmo que implementa uma estrutura de repetição \textit{while}. Sua criação foi necessária para que fosse possível evidenciar os diferentes pulos que são utilizados no código \textit{Assembly Python} ao se utilizar diferentes estruturas de repetição.
	\item[Estrutura de repetição \textit{for}]: algoritmo idêntico ao anterior, porém utilizando, no lugar do \textit{while}, a estrutura de repetição \textit{for}. Foi possível analisar, com ele, as diferenças entre os dois algoritmos.
	\item[Operação aritmética de soma simples]: foi criada uma operação aritmética de soma simples, a qual foram somados dois valores constantes e, após, seu resultado foi salvo em uma variável. 
	\item[Operação aritmética de soma de constante com variável]: algoritmo executa uma soma de uma variável previamente salva na memória com uma constante, salvando o resultado em outra variável. Esse algoritmo foi criado para permitir a análise de como são feitos os carregamentos de dados já existentes e os dados chamados como constantes, sem estarem salvos e como são manipulados dentro de uma operação aritmética.
	\item[Operação aritmética de soma com duas variáveis]: algoritmo executa a soma de duas variáveis previamente salvas na memória e armazena o resultado em outra variável. Com ele, é possível entender como são feitos os carregamentos das variáveis e a ordem em que é feito.
	\item[Operação aritmética de subtração de variáveis]: algoritmo executa a subtração de dois valores salvos na memória. Sua implementação foi influenciada pelo fato de ser possível analisar quais tipos de operações aritméticas a máquina virtual \textit{Python} é capaz de executar nativamente, sem a necessidade de quebrar uma operação em pequenas operações internas.
	\item[Operação aritmética de multiplicação de variáveis]: executa a multiplicação de dois valores salvos em variáveis. Foi necessário para entender se, dentro da máquina virtual \textit{Python}, uma multiplicação era feita por uma sequência de somas separadas, definidas no código \textit{Assembly}, ou se existia uma instrução específica para executar a multiplicação.
	\item[Operação aritmética de divisão de variáveis]: implementa uma divisão entre dois valores. Sua necessidade de implementação vem do fato de ser preciso entender, assim como na multiplicação, se existia uma instrução específica para tal operação ou se eram feitas subtrações sucessívas.  
\end{description}

\subsection{Análise dos algoritmos utilizados}
\label{a_instrucoes_algo}


De posse dos algoritmos acima apresentados, foi utilizada uma ferramenta presente no próprio compilador \textit{Python}, chamada \textit{dis} (fazendo referência à \textit{disassembler}), capaz de mostrar o código \textit{Assembly} do algoritmo implementado em alto nível. Então, colocando os algoritmos prontos na ferramenta, ela retornava o código \textit{Assembly} referente ao algoritmo. Tal código é o que é enviado para a máquina virtual para ser executado.

A Figura \ref{img_1_simple} apresenta o código \textit{Assembly} do primeiro algoritmo apresentado. Ele cria uma variável, salvando o valor em um endereço de memória específico. Após, ele carrega o valor novamente para a pilha e imprime na tela. Todos os algoritmos apresentados aqui contém as instruções de impressão na tela \textit{PRINT\_ITEM} e \textit{PRINT\_NEWLINE}, porém elas não são o foco para o projeto da arquitetura, já que elas serão implementadas diretamente em \textit{software}, não em \hw{}.

Então, com a análise da Figura \ref{img_1_simple}, é possível perceber instruções básicas para um código \textit{Assembly Python}, tais como LOAD\_CONST, STORE\_FAST e LOAD\_FAST. A primeira é responsável por encaminhar para a pilha um valor constante, passado como argumento. Tal valor será salvo no \tos{} e será manipulado de acordo com a próxima instrução. A segunda instrução encontrada salva o valor encontrado no \tos{} na memória externa do sistema, definindo o endereço onde ele será salvo e o passando como argumento. O endereço definido será o mesmo utilizado para acessar tal variável futuramente. Então, ao se afirmar que determinada variável terá o nome de "\textit{variavel}", define-se o endereço desta variável e, toda vez que ela precisar ser acessada, será o endereço dela que será passado como parâmetro da instrução STORE\_FAST e não o nome da variável diretamente. Por fim, a terceira instrução executa um carregamento de uma variável diretamente da memória principal para a o \tos{}. O endereço onde a variável foi salva na memória será informado no argumento. 

A definição dos argumentos de cada instrução cabe ao compilador, então ele deverá escolher um endereço onde a variável será salva e passar tal endereço todas as vezes em que a mesma variável precisar ser acessada ou modificada. Uma variável, por exemplo, de nome "\textit{var}" recebe o endereço de 8 \textit{bits} 00001100. Logo, ao ser salva na memória, ela será salva na posição de memória referente a este endereço utilizando STORE\_FAST e, ao ser acessada com um futuro LOAD\_FAST, deverá ser passado como argumento da instrução o mesmo endereço 00001100. 

É possível perceber, ainda, através da análise da Figura \ref{img_1_simple}, que um valor precisa ser carregado na pilha antes de se tornar uma variável. Isso acontece porque a instrução encarregada por salvar determinado valor na memória principal age apenas na pilha. Ou seja, a instrução sempre executará tendo como foco salvar o \tos{} na memória principal. Logo, a criação de uma variável, que em alto nível é feita simplesmente utilizando "\(var = 10\)", em baixo nível utiliza duas instruções: LOAD\_CONST e STORE\_FAST.

Por último, após a execução de todo o código, é feita uma chamada da instrução RETURN\_VALUE, que finaliza a execução dessa função. Como o algoritmo só tinha essa função, finalizar a execução dela significa finalizar a execução do algoritmo por completo.

\begin{figure}[htp]
\centering
\includegraphics{images/1_simple.png}
\caption{Código \textit{Assembly} de uma criação de variável.}
\label{img_1_simple}
\end{figure}

A análise da Figura \ref{img_2_if} nos permite entender como é feita uma comparação em código \textit{Assembly} da linguagem \py{}. O algoritmo apresentado nela implementa uma chamada \textit{if} sozinha, sem acompanhamento de \textit{elif} ou \textit{else}. Isso significa que o trecho de código contido no corpo do \textit{if} somente irá impactar na execução do sistema se a comparação for verdadeira, não tendo, portanto, nenhuma execução caso a primeira afirmação seja falsa. Em outras palavras, caso a afirmação retorne como sendo falsa, a chamada \textit{if} será completamente ignorada, diferente do que acontece nas Figuras \ref{img_2_if_else} e \ref{img_2_if_elif_else}.

\begin{figure}[htp]
\centering
\includegraphics{images/2_if.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if} simples.}
\label{img_2_if}
\end{figure}

Então, ao analisar-se a Figura \ref{img_2_if}, pode-se perceber que acontece o que já foi visto na Figura \ref{img_1_simple} no que diz respeito ao armazenamento de uma variável na memória principal. Então, após salvar uma variável que será utilizada para fazer a comparação na memória principal, ela é carregada para a pilha novamente para que seja efetuada a comparação. Contudo, é preciso realizar uma operação que depende de outro valor, uma constante, que ainda não está na pilha, mas precisa estar. Então é feito um carregamento da constante diretamente para a pilha. Tal constante é o valor que será comparado com a variável e resultará em um resultado afirmativo ou negativo para a comparação. 

Com os dois operandos carregados (variável e constante), é possível notar a existência de uma nova instrução, a qual ainda não foi analisada. Tal instrução é chamada de COMPARE\_OP e ela é encarregada por executar uma comparaçã entre o \tos{} e a posição logo abaixo dele. Ela define o tipo de comparação que será feita através dos valores passados como argumento. No caso da Figura \ref{img_2_if}, está sendo executada uma comparação "maior que" (>). O compilador define que tal comparação recebe o valor 4, em decimal, indicando a chamada do "maior que", e o coloca como argumento. 

Após a comparação, pode ser encontrada uma instrução chamada POP\_JUMP\_IF\_FALSE, que executa um pulo caso a comparação anterior seja falsa. Para entender melhor isso, é necessário pensar diretamente em um algoritmo de alto nível. Em um algoritmo de alto nível, ao ser chamado um \textit{if}, logo abaixo, sequencialmente, é escrito o trecho de código que será executado caso a afirmação seja verdadeira. Contudo, caso seja falsa, esse código não deverá ser executado. Então, quando se fala de um código \textit{Assembly}, para não executar determinado trecho de código, precisa-se pulá-lo/desviá-lo. Portanto, a instrução POP\_JUMP\_IF\_FALSE executa um desvio, caso a afirmação feita no \textit{if} seja falsa, com o intuito de pular o trecho de código que deveria ser executado apenas quando a afirmação fosse verdadeira.

Ainda na mesma figura, pode-se ver que aparece outra instrução que ainda não foi apresentada, chamada JUMP\_FORWARD. Tal instrução executa um pulo incondicional, ou seja, sem depender de uma comparação prévia. Esse pulo sempre acontecerá quando a instrução for lida, diferentemente da instrução anterior, onde o pulo só acontecerá se a comparação anterior for falsa. A instrução JUMP\_FORWARD executa um pulo em que o valor atual do contador de programa (PC) é incrementado com um valor fixo, chamado de "\textit{delta}". É importante observar que o valor de PC não é substituído por completo pelo novo valor, mas sim é feita uma soma entre o valor de PC atual e o \textit{delta}. O resultado da soma será o novo valor de PC.

Finalizando a análise do código \textit{Assembly} da Figura \ref{img_2_if}, pode-se perceber que após a comparação, então, é feito um pulo condicional para a linha de código após o trecho de código interno ao \textit{if}. Isso porque o desvio incondicional só é executado caso o bloco de código encontrado no corpo do \textit{if} seja executado, fazendo com que o algoritmo finalize após sua execução. O destino deste pulo, então, são as linhas de código que finalizam o algoritmo. 

A Figura \ref{img_2_if_else} apresenta um código quase igual ao apresentado na Figura \ref{img_2_if}. Contudo, ele acrescenta um trecho de código que deverá ser executado caso a afirmação feita no \textit{if} seja falsa. Então, não se pode dizer que a estrutura \textit{if} será completamente ignorada nesse caso. 

\begin{figure}[htp]
\centering
\includegraphics{images/2_if_else.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if} contendo \textit{else}.}
\label{img_2_if_else}
\end{figure}

Porém, do ponto de vista do código \textit{Assembly}, não é adicionada nenhuma instrução nova. A grande diferença dos dois códigos \textit{Assembly}, portanto, é que o pulo condicional de quando a comparação resulta como sendo falsa direciona o \pc{} para executar o trecho de código responsável pela saída alternativa ao \textit{if}. Na imagem anterior, não existia tal saída, portanto, o pulo direcionava o contador para fora da estrutura \textit{if} e, como o algoritmo só possuia tal estrutura, para o final da sua execução. 

Continua-se tendo um pulo incondicional idêntico ao da figura anterior, o qual direciona o programa para o final da sua execução. Pode-se observar que só existe pulo incondicional após o trecho de código executado caso a comparação seja verdadeira. No trecho executado caso ela seja falsa, não se tem um pulo pois é esperado que esse trecho somente seja executado como última instância, não sendo preciso realizar nenhum pulo após ele, já que ao finalizar sua execução já estar-se-á fora da estrutura \textit{if}. 

Nesse algoritmo, fica claro o motivo de se utilizar um desvio incondicional relacionado a um \textit{delta} e não um desvio absoluto, que será visto a seguir e que substitui o valor do \pc{} por um valor. O motivo, então, é que o compilador calcula a quantidade de linhas necessárias para pular completamente o trecho de código contido em \textit{else} e o adiciona ao \pc{}, fazendo com que o algoritmo seja executado uma linha após a última linha do trecho. Um pulo absoluto não seria ideal, pois o valor deveria ser exatamente o valor da última linha de \textit{else} somado com um, se tornando, portanto, mais difícil e custoso para o compilador montar o código \as{}.

Na Figura \ref{img_2_if_elif_else}, segue-se a mesma lógica vista nas Figuras \ref{img_2_if} e \ref{img_2_if_else}, porém com a adição de uma nova comparação após a primeira. Como neste algoritmo implementa-se uma estrutura \textit{if} que contém duas comparações e uma saída padrão, que será executada caso as duas sejam falsas, é possível perceber isso também no código \textit{Assembly}. 

\begin{figure}[htp]
\centering
\includegraphics{images/2_if_elif_else.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if}, contendo \textit{elif} e \textit{else}.}
\label{img_2_if_elif_else}
\end{figure}

Assim como na Figura anterior, não é possível verificar nenhuma instrução diferente das que já foi visto até o momento. Contudo, a estrutura do código \textit{Assembly} é levemente diferente. Após executar-se a primeira comparação e o \pc{} estar apontando para o primeiro pulo, ele é então direcionado diretamente para a segunda comparação, caso a primeira retorne falsa. Caso a segunda retorne falsa também, o valor de PC recebe a linha de código inicial do trecho de código padrão, que será executado somente se as duas retornem falsas. 

Com a inserção de uma nova comparação, agora também pode ser visto mais de um pulo incondicional. Pode-se observar, também, que ainda não é encontrado um pulo incondicional após a segunda comparação, somente após o trecho de código presente no seu corpo. O motivo para isso é o mesmo apresentado anteriormente.  

A Figura \ref{img_3_while} é a primeira que apresenta a implementação de uma estrutura de repetição em \textit{Assembly}. Através de sua análise, pode-se perceber a inserção de algumas novas instruções. Porém, mantém-se a sequência de chamada de instruções para executar operações mais simples, tais como comparações, onde as constantes a serem comparadas são carregadas para a pilha antes de executar a instrução COMPARE\_OP. 

\begin{figure}[htp]
\centering
\includegraphics{images/3_while.png}
\caption{Código \textit{Assembly} de uma estrtutura de repetição \textit{while}.}
\label{img_3_while}
\end{figure}

Analisando este código, pode-se perceber que, primeiramente, ocorre a criação de uma variável na memória. Tal variável será utilizada para gerenciar a estrutura de repetição. Ela será iniciada com um valor, no caso da Figura o valor é zero, e irá receber uma sequência de somas. Quando seu valor exceder um valor pré-definido, no caso 10, a estrutura será finalizada. 

Após a criação e atribuição de valor à variável, é chamada a primeira instrução nova, SETUP\_LOOP. Tal instrução é encarregada por inicializar um bloco, responsável pela estrutura de repetição (\textit{loop}) na pilha. Um bloco na pilha nada mais é do que uma região de posições de memória, ao topo da pilha, com variáveis que são modificadas. Ao finalizar-se um \aloop{}, o bloco é retirado da pilha e a pilha volta ao que era. 

A instrução seguinte inicia um procedimento de comparação, onde os dois valores a serem comparados são carregados para a pilha. O primeiro valor, a variável a ser comparada, e o segundo, o valor que define o final da execução da estrutura, serão os operandos da instrução COMPARE\_OP, executada exatamente na sequência dos dois carregamentos. 

Assim como em uma instrução \textit{if}, existe um trecho de código que só deverá ser executado enquanto o programa estiver rodando dentro do \textit{loop}. Logo, após a comparação, existe um POP\_JUMP\_IF\_FALSE, que visa evitar a execução de tal trecho caso o valor da variável seja maior que 10. Então, o pulo é feito diretamente para a instrução que define a retirada do bloco da pilha. Essa instrução, chamada POP\_BLOCK, retira o bloco do \aloop{} da pilha e finaliza, então, a execução dele. Ou seja, foram separadas posições da pilha para receberem as variáveis do \aloop{} e, ao utilizar-se POP\_BLOCK, esse bloco é excluído, fazendo com que a pilha retorne a ter o seu topo antigo, sem nenhum bloco.

Caso o programa siga sendo executado dentro do \textit{loop}, o trecho de código presente no corpo da repetição será executado e, após, é feito um incremento ao valor da variável, o qual será salvo exatamente na mesma posição de memória que define a variável. Para essa operação, é utilizada a instrução INPLACE\_ADD. Sua execução é similar às operações BINARY\_, que será visto a seguir. Contudo, ela permite que o resultado seja salvo em uma das variáveis utilizadas como operando. Essa instrução executa a funcionalidade \(i = i+1\) ou \(i++\).

Para reiniciar a estrutura de repetição, é feito um JUMP\_ABSOLUTE, onde o valor do contador de programa é completamente substituído pelo valor que aponta para a primeira linha de execução do \textit{loop}, no caso linha 9. 

A Figura \ref{img_4_for} apresenta a segunda estrutura de repetição implementada, a qual é chamada de \textit{for}. Tal instrução apresenta algumas instruções novas, porém sua execução é bem similar à vista na Figura \ref{img_3_while}. 

\begin{figure}[htp]
\centering
\includegraphics{images/4_for.png}
\caption{Código \textit{Assembly} de uma estrutura de repetição \textit{for}.}
\label{img_4_for}
\end{figure}

Exatamente como a análise anterior, pode-se observar que a estrutura de repetição começa salvando a variável que irá gerenciar o \textit{loop} e, após, aloca-se um bloco de repetição na pilha, com a instrução SETUP\_LOOP. A adição de uma nova instrução à lista de instruções escolhidas se dá na linha exatamente abaixo a essa, na qual é chamada a instrução LOAD\_GLOBAL. Tal instrução é responsável por carregar um alcance para a estrutura de repetição, o qual dirá qual será a última vez que o \textit{loop} será executado.

Diferentemente da estrutura \textit{while}, a estrutura \textit{for} define os parâmetros de execução antes mesmo de realizar o início do \textit{loop}. Então, são carregados para a pilha como constantes o valor inicial, zero, e o valor final, cinco. Após, é feita uma chamada de função, realizada pela instrução CALL\_FUNCTION, onde o número de parâmetros serão passados como argumento. Ao realizar a chamada desta instrução, o número de parâmetros é analisado pelo sistema e é realizado o carregamento destes parâmetros, para que possam ser utilizados na execução do \textit{loop}. É então feita as chamadas das instruções GET\_ITER e FOR\_ITER, que criam os blocos de \textit{loop} dentro da pilha. Tais blocos serão utilizados para que as chamadas de instruções internas ao \textit{loop} possam utilizar variáveis sem que as variáveis iniciais sejam perdidas.

Para finalizar a execução do \textit{loop}, é executado o trecho de código interior à estrutura, após é realizado um incremento na variável que gerencia o \textit{loop} e, então, é feito um pulo para a primeira linha da estrutura. Note que, no caso do \textit{for}, a primeira linha considerada não é a chamada de variáveis para realizar a comparação inicial, mas sim a linha 22, onde se encontra a instrução FOR\_ITER. Isso se deve ao fato de que tal instrução gerencia a saída do \textit{loop} ao seu final, e não uma comparação, como no \textit{while}. Essa instrução executa o que seria feito por uma repetição em conjunto com um \textit{jump}, comparando se o final do \aloop{} já foi alcançado ou não. 

A próxima imagem, Figura \ref{img_5_add}, apresenta a primeira operação aritmética realizada. Através dela, é possível perceber como é feita a conversão de um código alto nível, escrito em \textit{Python}, feita pelo compilador, que realiza uma atribuição de variáveis com soma. 

\begin{figure}[htp]
\centering
\includegraphics{images/5_add.png}
\caption{Código \textit{Assembly} de uma operação aritmética de soma com duas constantes.}
\label{img_5_add}
\end{figure}

Pode-se perceber, porém, que na Figura, só existe uma instrução de carregamento para a pilha, diferentemente das outras operações aritméticas. Tal instrução, LOAD\_CONST, pega o valor 15, e o carrega para a pilha. No entanto, ao escrever o código em alto nível, foi definido que o valor a ser salvo na pilha seria \(10 + 5\). Logo, pode-se concluir que o compilador, visando simplificar a operação e retirar linha de códigos de baixo nível, realizou a soma antes de definir qual seria o argumento da instrução LOAD\_CONST, definindo, então, como sendo o resultado da soma. 

\begin{figure}[htp]
\centering
\includegraphics{images/5_add_var_int.png}
\caption{Código \textit{Assembly} de uma operação de soma com uma variável e uma constante.}
\label{img_5_add_var_int}
\end{figure}

Diferentemente da Figura \ref{img_5_add}, a Figura \ref{img_5_add_var_int} mostra um código \textit{Assembly} que vem de um algoritmo \textit{Python} que realiza a soma de uma variável com uma constante e armazena o resultado em outra variável. Para isso, primeiramente, como já visto nas figuras anteriores, existe a criação da primeira variável, onde ela é carregada como constante para a pilha e, após, é salva na memória em um endereço que é referenciado como sendo a primeira variável ("\textit{val1}").

Logo após, carrega-se a variável novamente para a pilha, com a instrução responsável por executar um carregamento de uma variável previamente criada, e carrega-se também o segundo operando, a constante, a qual será somada à "\textit{val1}". Com os dois operandos dispostos nas duas posições mais superiores à pilha, executa-se a primeira instrução responsável por executar uma operação aritmética. 

No caso de uma soma, as instruções que carregam os operandos para a pilha podem ser executadas em qualquer ordem, já que o resultado será o mesmo. Contudo, ao realizar-se uma subtração ou divisão, os resultados obtidos poderiam diferentes dependendo da ordem dos operandos. Para garantir a ordem, o operando encontrado à esquerda da operação (operando 1) seria o primeiro a ser carregado e, em seguida, carrega-se o operando 2. Assim, quando os dados são lidos para ser somados, o \tos{} é lido primeiro e, nessa posição, encontra-se o operando 2. Portanto, pode-se considerar que a leitura dos operandos na pilha é inversa à ordem em que eles devem ser posicionados na operação, já que o operando 1 é o segundo a ser carregado.

A instrução aritmética é então, chamada para realizar a operação. Tal instrução recebe o nome de BINARY\_ADD e executa uma soma entre dois operandos. Os dois operandos utilizados vêm das posições na pilha apontadas por \(TOS-1\) e TOS, respectivamente. Essa instrução não necessita de valores presentes no \textit{byte} de argumento, visto que seus operandos serão sempre os mesmos e que a operação também será sempre a mesma. Para realizar-se outra operação aritmética, utiliza-se códigos de instrução diferentes. Então, seu campo de argumento pode aparecer qualquer valor, pois ele será completamente ignorado. No caso da Figura \ref{img_5_add_var_int}, o campo aparece em branco, mas ao se converter para um código binário, ele precisa aparecer, mesmo que seja aleatório.

A execução de todas as operações aritméticas, as quais estão sendo mostradas também nas Figuras \ref{img_5_add_var_var}, \ref{img_5_sub}, \ref{img_5_multi} e \ref{img_5_div}, se dá de maneira semelhante. As duas posições topo da pilha, aqui chamadas de TOS e TOS1, sendo a segunda considerada a posição logo abaixo ao topo, são retiradas da pilha e carregadas para uma unidade que realizará a operação aritmética dentro da \pvm{}, que por sua vez usará a unidade arimética da máquina física subjacente.

Então, ao serem carregados os dois operandos, executa-se a operação definida pela instrução, que pode ser soma, subtração, multiplicação ou divisão. Ao realizar tal operação, o resultado dela é armazenado no lugar antes ocupado pelo operando TOS1. Então, considera-se, do ponto de vista de posições na pilha, que a operação acontece tal como a Equação \ref{eq_arit_pilha} mostra.

\begin{equation} \label{eq_arit_pilha}
	TOS1 = TOS1 + TOS
\end{equation}

Todas as operações aritméticas acontecem da mesma forma, onde a primeira variável a ser carregada (TOS) se torna o segundo operando da equação e, a segunda (TOS1), o primeiro operando. O resultado é salvo no lugar onde estava TOS1.

\begin{figure}[htp]
\centering
\includegraphics{images/5_add_var_var.png}
\caption{Código \textit{Assembly} de uma operação aritmética de soma com duas variáveis.}
\label{img_5_add_var_var}
\end{figure}

A Figura \ref{img_5_add_var_var} realiza a mesma operação aritmética mostrada na Figura \ref{img_5_add_var_int}, com a diferença apenas nas origens dos operandos. Ao invés de ser executada a soma entre uma variável e uma constante, é executada a soma entre duas variáveis. Então, para isso, é preciso que as duas variáveis tenham sido salvas na memória e, então, carregadas novamente para a pilha. Para tal procedimento, é necessário o uso das instruções STORE\_FAST e LOAD\_FAST uma vez a mais do que o que foi visto anteriormente, na Figura \ref{img_5_add_var_int}.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_sub.png}
\caption{Código \textit{Assembly} de uma operação aritmética de subtração.}
\label{img_5_sub}
\end{figure}

Já as Figura \ref{img_5_sub}, \ref{img_5_multi} e \ref{img_5_div} seguem a mesma lógica empregada na Figura \ref{img_5_add_var_var}, com a diferença de que realizam operações aritméticas diferentes, sendo elas subtração, multiplicação e divisão, respectivamente. Perceba que as instruções aritméticas de cada uma delas estão destacadas nas figuras.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_multi.png}
\caption{Código \textit{Assembly} de uma operação aritmética de divisão.}
\label{img_5_multi}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_div.png}
\caption{Código \textit{Assembly} de uma operação aritmética de divisão.}
\label{img_5_div}
\end{figure}

\subsection{Definição das instruções escolhidas}
\label{def_inst_esc}

Baseados nas análises de algoritmos simples e sabendo que tais algoritmos estão presentes, por tendência, na maioria dos programas escritos em \textit{Python}, foi possível definir o conjunto de instruções mínimo para a arquitetura cobrir. As instruções escolhidas para serem implementadas deverão possuir suporte na arquitura e serem executadas completamente em \textit{hardware}.

Para iniciar a lista, começar-se-á com as instruções de manipulação de dados. Estas instruções são responsáveis por definir quais dados entram e saem da pilha, assim como a ordem que eles entram e o endereço onde o \tos{} será salvo na memória principal. As instruções dessa categoria que serão implementadas são:

\begin{description}
	\item[LOAD\_CONST]: carregamento de um valor constante, passado por argumento, para o topo da pilha. Tal valor ocupa a posição de \textit{opArg} e, portanto, deverá conter 8 \textit{bits}. Esta instrução é a única que permite a entrada de um valor externo no sistema. Sem ela, nenhum valor poderia ser salvo na memória ou sequer utilizado no sistema.
	\item[LOAD\_FAST]: é a instrução que permite a existência de variáveis. Quando se fala de uma arquitetura física, possui-se números limitados de registradores e palavras que podem ser salvas na pilha, então precisa-se salvar os valores que não estão sendo utilizados no momento em algum lugar onde eles possam ser recuperados posteriormente, sem serem perdidos. Este lugar é a memória principal. Portanto, esta instrução é a única que permite a recuperação de um valor previamente salvo na memória principal. Sem ela, seria impossível a existência e manipulação de variáveis dentro de uma arquitetura física. Portanto, ela é de grande importância para o sistema e deverá ser suportada na arquitetura.
	\item[STORE\_FAST]: a instrução anterior, LOAD\_FAST, é de extrema importância para a manipulação de variáveis. Porém ela só atende um lado dessa manipulação de variáveis, que é o carregamento da memória para a pilha. Contudo, uma variável precisa ser salva na memória principal previamente para, então, poder ser carregada. O salvamento de uma variável na memória é feito por essa instrução, sendo, portanto, também fundamental para a existência de variáveis na arquitetura.
	\item[LOAD\_GLOBAL]: essa é a instrução presente, até o que foi analisado, nas estruturas \textit{for}. Ela realiza o carregamento de um \textit{range} (alcance) que a estrutura terá para dentro do sistema. Ou seja, quando se executa um \textit{for}, tem-se um valor inicial e um valor final. O \textit{range} é a "distância" entre esses dois valores, indicando quantas vezes dever-se-á executar o código interno à estrutura.
\end{description}

As quatro instruções de manipulação de dados apresentadas acima possuem grande importância para uma arquitetura física, porque ela deverá ser capaz de suprir uma necessidade básica da linguagem \textit{Python}, que é a manipulação de variáveis e dados. Então, a escolha delas é justificada pela grande importância e pela elevada taxa de utilização destas instruções, que estão presentes praticamente todos os algoritmos, desde os mais simples até os mais complexos. 

Das instruções analisadas na subseção \ref{a_instrucoes_algo}, foi definido que as quatro operações aritméticas elementares da matemática seriam suportadas na arquitetura física. Para isso, o código \textit{Assembly Python} possui uma instrução específica para cada uma das operações. São elas:

\begin{description}
	\item[BINARY\_ADD]: executa uma soma binária, ou seja, entre dois valores. Os valores escolhidos para tal operação são o TOS e a posição exatamente abaixo dele, salvando o resultado na posição desta última. A operação de soma é uma das operações mais importantes de um sistema, pois ela é necessária para definir-se o topo da pilha e para avançar para outra instrução, incrementando o contador de programa. Contudo, tais operações são operações básicas do sistema e que não dependem desta instrução, apenas dessa funcionalidade. Mas, como elas deverão ser implementadas, adicionar também uma instrução que execute uma operação de soma entre dois operandos reaproveitará os mesmos componentes da arquitetura. As operações aritméticas são importantes, visto que a maioria dos algoritmos executam uma hora ou outra uma manipulação de valores.
	\item[BINARY\_SUBTRACT]: é a instrução responsável por executar uma subtração entre dois operandos. Assim como a instrução anterior, ela executa tal operação entre o TOS e TOS-1, e salva o resultado em TOS-1. 
	\item[BINARY\_MULTIPLY]: é a instrução responsável por executar uma multiplicação entre dois operandos. Caso ela não fosse implementada, sempre que uma operação de multiplicação fosse solicitada na linguagem de alto nível, ela deveria ser realizada através de uma soma sucessiva manualmente (contendo cada instrução de soma no código \textit{Assembly}).
	\item[BINARY\_DIVIDE]: realiza uma divisão entre dois operandos. Sua implementação, assim como a multiplicação, se faz necessária para simplificar o código \textit{Assembly} e acelerar a execução dentro da arquitetura.
\end{description}

Em anexo às instruções de operações aritméticas, pode-se incluir da instrução INPLACE\_ADD, que possui seu funcionamento muito semelhante à instrução BINARY\_ADD, porém com a diferença de aceitar que o resultado da operação seja salvo diretamente em um dos operandos. Ela é utilizada principalmente na estrutura de repetição \textit{while}, quando executa-se um incremento de um em um valor (\(i = i+1\)).

Portanto, as instruções responsáveis por operações aritméticas são importantes, visto que a existência de operações com números dentro de algoritmos escritos em qualquer linguagem é uma exigência mínima. Para viabilizar a utilização de tais operações dentro da arquitetura física, as operações principais foram definidas e receberão suporte na arquitetura.

Pode-se citar ainda instruções que executam pulos (\textit{jumps}). Elas são importantes, pois nenhum algoritmo de programação executa em uma sequência estática. Muitas vezes, os trechos de código que serão executados dependem de resultados anteriores, podendo, então, pular trechos e voltar para executar novamente outros. As instruções do código \textit{Assembly Python} escolhidas para serem suportadas dentro da arquitetura aqui proposta foram:

\begin{description}
	\item[POP\_JUMP\_IF\_FALSE]: é a instrução utilizada, principalmente, em estruturas \textit{if}, onde se precisa executar um trecho de código escrito logo após uma comparação, quando ela é falsa. Ela executa um pulo onde o valor do contador de programa (PC) é completamente substituido pelo valor contido no argumento (\textit{opArg}) da chamada desta instrução. Porém, só ocorrerá a substituição caso o resultado de uma comparação executada anteriormente seja negativo. Ela é extremamente importante para facilitar a tomada de decisão dentro de um algoritmo.
	\item[POP\_JUMP\_IF\_TRUE]: é exatamente a operação inversa à instrução anterior. Ela não aparece em nenhum dos algoritmos apresentados na subseção \ref{a_algo_sim}, porém sua implementação utiliza a mesma base da instrução anterior. Logo, sua implementação simplesmente precisa ser executada caso a comparação retorne como sendo positiva.
	\item[JUMP\_FORWARD]: é a instrução utilizada, principalmente, para executar a saída do trecho executado em uma comparação, quando a mesma retorna como sendo positiva. Ela realiza um incremento do valor do contador de programa, substituindo-o pelo novo valor. Seu argumento é chamado de \textit{delta} e é o valor usado para ser somado a PC. Ela é utilizada dentro das estruturas \textit{if} porque seu funcionamento permite que o compilador simplesmente veja quantas linhas de código devem ser executadas quando a comparação for positiva e, então, incrementar o valor do contador com esse valor. Isso acontece porque, quando tal instrução é escrita pelo compilador, ainda não foi definido qual será o primeiro valor de PC que estará fora da estrutura \textit{if}. Sendo assim, se torna difícil utilizar a próxima instrução.
	\item[JUMP\_ABSOLUTE]: é a instrução responsável por substituir completamente o valor de PC pelo seu argumento. Ela é utilizada, principalmente, em estruturas de repetição, pois é preciso retornar ao início da estrutura sem realizar nenhuma comparação prévia. Então, salva-se como \textit{OpArg} desta instrução o valor da primeira linha da estrutura e, ao ser executada essa instrução, o valor de PC é substituído e reinicia-se a repetição.
\end{description}

\begin{description}
	\item[COMPARE\_OP]: é a instrução responsável por realizar uma comparação entre dois valores. Ela possui um formato semelhante às instruções aritméticas, porém seu argumento contém o tipo de comparação que deverá ser feito (>, <, =). Após ser executada, ela gera um sinal (\textit{flag}) indicando que seu resultado foi verdadeiro ou falso para que possa-se executar um desvio condicional na sequência.
	\item[SETUP\_LOOP]: inicia, na pilha, um bloco de repetição. Esse bloco guardará os valores envolvidos diretamente na repetição. 
	%\item[GET\_ITER]: .........
	%\item[FOR\_ITER]: .........
\end{description}


\begin{description}
	\item[CALL\_FUNCTION]: é a instrução responsável por inicializar uma função. Sua chamada causa o salvamento do valor de PC+1 (indicando o ponto de volta da instrução a seguir), um desvio para o bloco de código que deve ser executado e uma alocação de um bloco de função na pilha, o qual receberá os valores manipulados dentro da função e, após seu fim, os apagará.
	\item[RETURN\_VALUE]: é a instrução que define o final de uma função. Ela retorna o valor no \tos{} presente no bloco da função para a função anterior, a qual chamou essa função. Ao executar essa instrução, o valor de PC é atualizado com o valor salvo na chamada da função e, portanto, realiza-se um desvio para que o código siga executando a função antiga de onde parou. 
	\item[POP\_BLOCK]: retira um bloco completo da pilha. É utilizado ao final de uma função, para retirar o bloco que foi adicionado na pilha para a execução da função. Então, o \tos{} retorna para o TOS anterior à chamada da função. 
\end{description}


\section{Análise de requisitos para a arquitetura}
\label{a_requisitos}

Após realizadas as análises sobre quais serão as instruções a serem implementadas, inicialmente, na arquitetura, é preciso projetar a arquitetura de forma que consiga atender a todos os requisitos de cada instrução.

Para iniciar tal análise, foram separadas em diversas subseções os diferentes tipos de instruções, tais como foram separadas na subseção \ref{def_inst_esc}. Isso se deve ao fato de que analisar a arquitetura como um todo, em uma só subseção, é inviável, visto poderia ficar uma leitura massante e confusa.

\subsection{Conceitos básicos}
\label{a_requisitos_basicos}

Antes de iniciar a análise das instruções propriamente ditas, é necessário que a arquitetura consiga suportar a entrada e, ainda, consiga percorrer através delas. Para isso, é preciso que conceitos básicos de execução de algoritmos sejam analisados. %\textbf{CITAR REFERENCIA DE EXECUÇÃO DE ALGORITMOS PC+1} 

Ao executar-se um algoritmo, as instruções \textit{Assembly} são salvas em uma memória específica para elas e, então, são percorridas sequencialmente, podendo haver desvios (pulos) entre elas ou não. Assim, o primeiro componente que deve ser adicionado à arquitetura é uma memória de instruções, chamada de \textit{memInstr}. Ela será responsável por salvar os argumentos (\textit{OpArg}) e os códigos de instruções (\textit{OpCode}), tais como foram apresentados na seção \ref{rf_modos_enderecamento}. Então, cada posição de sua memória deverá receber uma instrução, juntamente com seu argumento (mesmo que ele seja dispensável, como nas instruções BINARY\_). Desta forma, torna-se necessário que cada bloco da memória de instruções possua 2 \bys{}, já que tanto \textit{OpCode} quanto \textit{OpArg} possuem 8 \bis{}.

Porém, para manter essa funcionalidade, serão necessários ainda três outros componentes. O primeiro deles, o qual será responsável por gerenciar qual será a instrução lida a cada momento, será um registrador de contador de programa, chamado de \textit{regPc}. Tal registrador irá apontar para o endereço na memória de instrução que está sendo executado a cada instante. Então, quando \textit{regPc} possuir como saída o valor binário referente ao decimal zero, indicará que a primeira posição na memória de instruções está sendo lida e, por conseguinte, sendo executada pela arquitetura. 

A cada instrução executada no processador, o valor de saída do \textit{regPc} será atualizado com a soma do valor um. Assim sendo, o programa irá ser executado sequencialmente. Contudo, existe a possibilidade de serem realizados pulos, que serão apresentados na subseção \ref{a_requisitos_jump}. Esses pulos substituirão o valor de \textit{regPc} por um valor passado nos seus argumentos, redirecionando, então, para a execução de uma instrução fora da ordem localmente adjacente.

O segundo componente responsável pela execução básica do programa é um registrador que salvará o tipo de instrução (\textit{OpCode}), contendo 8 \textit{bits}, que está sendo executado no momento. Tal registrador, chamado de \textit{regInstr}, irá receber um valor diretamente da memória de instruções e o passará diretamente para o controle, o qual será apresentado na seção \ref{projeto_control} e será responsável por tomar todas as decisões de execução necessárias. Esse valor de 8 \bis{} vem da segunda metade do endereço de 16 \bis{} contido no bloco da memória que está sendo lido no momento. 

O último componente apresentado nesta subseção é o registrador que salvará os argumentos das instruções executadas. Esse registrador, chamado de \textit{regArg}, manterá os valores dos argumentos estáveis para que possam ser utilizados a qualquer momento durante a execução de uma mesma instrução. Instruções como COMPARE\_OP e LOAD\_CONST utilizam seus argumentos em diferentes momentos. Logo, é necessário que o argumento se mantenha estável durante toda a execução de uma instrução. O \textit{regArg} receberá a outra metade do endereço vindo da \textit{memInstr}, o qual se referente aos primeiros 8 \bis{} do bloco de memória lido.

Então, os componentes básicos para que a arquitetura consiga executar códigos são uma memória de instruções, \textit{memInstr}, um registrador para o contador de programa, \textit{regPc}, e dois registradores para instruções e argumentos, \textit{regInstr} e \textit{regArg}, respectivamente. Com todos esses componentes básicos de execução, é possível, até agora, receber uma sequência de códigos \as{}, lê-los de uma memória e armazená-los durante a execução. Contudo, ainda falta uma unidade lógica aritmética, que adicionará a funcionalidade de avançar entre as instruções, através da execução de \(PC+1\).

A Figura \ref{img_analisebasicos} apresenta os componentes citados nessa subseção e que são utilizados o recebimento e leitura de instruções no processador. Nela, é possível perceber a memória de instruções (\textit{memInstr}) que possui uma entrada, que é o valor de PC, e duas saídas, que são o valor de \textit{OpCode} e \textit{OpArg}. Além da memória, existem três registradores, considerados simples, já que possuem uma entrada de dados, uma saída de dados e uma entrada de controle, chamada de "\textit{ctrl}" (que define o momento em que um registrador deverá armazenar o que está entrando através do pino de entrada). Contudo, ainda existe uma outra entrada em cada um deles, a qual não foi inserida na Figura, que recebe o valor referente ao \textit{clock} do processador. Os três registradores são, então, os registradores o de contador de programa (\textit{regPc}), o de argumento (\textit{regArg}) e o de instruções (\textit{regInstr}). 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_basicos.png}
\caption{Componentes utilizados o funcionamento básico do processador.}
\label{img_analisebasicos}
\end{figure}


\subsection{Instruções de carga e armazenamento de dados}
\label{a_requisitos_dados}

O primeiro conjunto de instruções engloba as instruções responsáveis pelo gerenciamento de dados dentro da arquitetura. As instruções escolhidas para esta área, tal como foi dito anteriormente, foram: LOAD\_CONST, LOAD\_FAST, LOAD\_GLOBAL e STORE\_FAST.

Iniciando, então, uma análise de requisitos para essa área, percebe-se que serão necessárias, além da memória de instruções, apresentada na subseção \ref{a_requisitos_basicos}, mais duas memórias. A primeira delas, e igualmente importante à segunda, será a pilha. Dentro dela, serão encontrados todos os dados que estão em uso durante a execução de um algoritmo \textit{Python}. Logo, será possível encontrar no seu interior dados como operandos de uma operação aritmética iminente, dados que estão aguardando para serem salvos na memória e dados que estão entrando no sistema como constantes e ainda não foram salvos. A pilha tem como característica principal possuir 8 \bis{} em cada uma de suas palavras, contendo 256 posições de memória, que podem ser endereçadas com também 8 \bis{}.

Como tal componente é uma pilha, pressupõe-se que os dados que entraram por último sejam os primeiros a serem lidos. Este trabalho não abordará profundamente conceitos de pilha. Tais conceitos podem ser encontrados em \cite{Aho}.

Contudo, sabendo que a saída de uma pilha deverá ser sempre o último valor que entrou, ou seja, seu topo, é necessário que exista ponteiro que informe a posição de leitura na pilha a cada instante. Para isso, será necessária a utilização de um registrador de topo (posição ocupada pelo dado adicionado por último), chamado de \textit{regTos}, que estará diretamente conectado à entrada de endereços da pilha. Ele deve conter a mesma quantidade de \bis{} necessária para realizar o endereçamento da pilha, ou seja, 8 \bis{}. Sempre que for realizada uma entrada de dados, o valor presente nesse registrador deverá ser atualizado com o acrescimento de uma unidade, indicando que o topo foi modificado. Quando existir uma retirada de dados, o ponteiro deverá apontar para a posição logo abaixo do dado retirado, ou seja, dever-se-á subtrair uma unidade do valor de \textit{regTos}.

Além de uma pilha, é necessário que exista um componente que irá armazenar valores de entrada e de saída da pilha para que eles fiquem estáveis enquanto são utilizados por outros componentes ou salvos na pilha. Para tal finalidade, foi incluído o registrador de pilha, chamado de \textit{regPilha}, responsável por salvar dados que entrarão na pilha e dados que estão saindo da pilha. Esse registrador permite que os dados fiquem estáveis por tempo suficiente, permitindo que outros componentes ou a pilha realize as operações utilizando sua saída.

O \textit{regPilha} possui duas entradas e duas saídas, ambas com largura de 8 \bis{}. Na realidade, o registrador de pilha pode ser considerado a junção de dois registradores simples, porém foi definido que ele seria apenas um registrador duplo para melhor apresentação e utilização. O primeiro par de entrada e saída será utilizado para os dados que irão ser salvos na pilha, então, com um sinal de controle definido para escrita na pilha, a entrada de escrita (\textit{entrada\_write}) terá permissão para salvar seu valor na saída de escrita (\textit{saída\_write}). O dado escrito nessa saída terá como destino a entrada de escrita da pilha. A Figura \ref{img_analisedados}, que será apresentada e explicada na sequência, apresenta exatamente o que foi explicado aqui.

O outro par de pinos do \textit{regPilha} é utilizado para dados que estão saindo da pilha. Então, ao ler-se um dado da pilha, é necessário salvá-lo no \textit{regPilha} utilizando a saída de operandos, nome dado à esse pino. Tal pino terá como destino final as entradas de operandos da unidade lógica aritmética (ULA), que será abordada em detalhes na subseção \ref{a_requisitos_arith}, e a entrada de escrita na memória externa, que será abordada ainda nesta subseção.

Definidos os dois componentes responsáveis pelo pleno funcionamento do componente pilha (\textit{regPilha} e \textit{regTos}), passa-se então para a memória externa. Essa memória terá o mesmo funcionamento de uma memória comum, onde os dados serão salvos em um endereço específico dentro da memória e só poderão ser acessados, posteriormente, com a utilização do mesmo endereço. Para maiores informações sobre o funcionamento básico de uma memória, recomenda-se a leitura de \cite{Stallings2002}.

A memória externa possui como característica principal, assim como a pilha, o fato de estar sempre lendo um de seus endereços. Tendo, portanto, uma saída durante todo o período de execução, exceto quando não existe nenhum dado salvo na posição apontada pelo endereço. Porém, a escrita no seu interior depende de um sinal de controle específico que permitirá que ela exista na próxima borda de relógio (\textit{clock}), de modo idêntico ao funcionamento da pilha. Ela possui, assim como a pilha, largura de bloco de 8 \bis{} e 256 posições, que podem ser endereçadas com os 8 \bis{} recebidos como argumento em uma instrução de acesso a dados.

Contudo, juntamente com a memória, deverão existir dois componentes que manterão estáveis informações essenciais para o correto funcionamento da memória. O primeiro, chamado de registrador de endereço, \textit{regEnd}, é responsável por manter estável o endereço do bloco de memória que está sendo lido. Sua atualização é feita através da entrada do registrador de argumentos, \textit{regArg}, apresentado em detalhes na subseção \ref{a_requisitos_basicos}. O registrador \textit{regEnd} deve conter, assim como o registrador \textit{regArg}, 8 \bis{} de largura e sua funcionalidade pode ser comparada à do registrador de \tos{}, porém com atualização de seu valor sendo inteiramente feita pelo argumento recebido.

Além do \textit{regEnd}, dever-se-á existir um registrador semelhante ao \textit{regPilha}, o qual será responsável por manter estáveis dados lidos da memória e dados que serão escritos nela. Ele recebe o nome de \textit{regMemExt} e seu funcionamento é similar ao funcionamento do registrador de pilha, o qual possui dois pinos de entrada e dois de saída, divididos em pares. O par que permitirá a escrita na memória receberá dados diretamente do \textit{regPilha}. Já o par que permitirá a leitura de dados da memória passará os dados para o mesmo registrador, porém em outra entrada.

A Figura \ref{img_analisedados} apresenta todos os componentes utilizados para acesso de dados dentro do processador. Nela, aparecem os componentes pilha, memória externa (\textit{memExt}), registrador de pilha (\textit{regPilha}), registrador de endereço (\textit{regEnd}), registrador de \tos (\textit{regTos}) e o registrador de memória externa (\textit{regMemExt}). É possível ver, na imagem, todas as entradas e saídas previstas para esses componentes. É necessário destacar que aparecem os mesmos pinos de controle nos registradores \textit{regPilha} e \textit{regMemExt}, mas na realidade ambos os registradores possuem duas entradas de controle, uma para cada par. Logo, entenda-se "\textit{ctrl}" como sendo o necessário para controlar cada registrador, podendo ser mais de um pino ou um pino com largura maior.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_dados.png}
\caption{Componentes utilizados para instruções de gerenciamento de dados.}
\label{img_analisedados}
\end{figure}


\subsection{Instruções de operações aritméticas e comparações}
\label{a_requisitos_arith}

As instruções responsáveis por operações aritméticas e comparações utilizam praticamente os mesmos componentes. Porém, a grande diferença entre elas é que cada uma salva o resultado em locais diferentes. 

O componente principal desta área é a unidade lógica aritmética (ULA), que será responsável por executar as operações propriamente ditas. Contudo, para que as operações consigam chegar à ULA e seus resultados serem armazenados, são necessários outros componentes auxiliares. 

Como as instruções responsáveis por operações aritméticas da linguagem \py{} sempre são executadas com dois operandos. Por esse motivo, em seus nomes, está a palavra "\textit{binary}", que pode ser livremente traduzida para "binário", indicando uma operação entre dois elementos. Isto posto, os dois primeiros componentes, responsáveis pelas entradas dos operandos a serem operados na ULA, são os registradores de operandos, \textit{regOp1} e \textit{regOp2}. Eles possuem ligações com as duas entradas de operandos do componente ULA. Suas finalidades são manter os valores que serão utilizados nos calculos da ULA estáveis até que o resultado seja salvo.

Isso acontece porque a unidade lógica não utiliza períodos de relógio para gerar resultados nem armazena nada em seu interior. Assim sendo, quando há uma mudança ou instabilidade na entrada da ULA, tal acontecimento reflete diretamente na sua saída. Por esse motivo, é de grande importância manter as entradas estáveis durante todo o período entre a entrada dos dados na ULA e o salvamento do resultado.

Também conectados à ULA, estão os componentes de saída. Eles somam, ao todo, três, sendo que um deles já foi apresentado na seção anterior. Começando pelo componente que já foi apresentado na subseção \ref{a_requisitos_dados}, tem-se o \textit{regPilha}, o qual é responsável por salvar o resultado de dados. Isso acontece porque o resultado da ULA em operações aritméticas é salvo diretamente na pilha. Logo, é possível aproveitar o mesmo componente para salvar diretamente na pilha, assim como ele também é aproveitado para outras funcionalidade que já foram mostradas.

O segundo componente, chamado de registrador de \textit{overflow} ou \textit{regOverflow}, é o registrador que salvará um sinal indicando se o resultado da ULA ultrapassou o número de \textit{bits} suportado pelo sistema ou não. Então, tem-se que a saída de resultados da ULA deve possuir o mesmo número de \textit{bits} que as entradas do componente, ou seja 8 \bis{}. Porém, operações como multiplicação e soma podem gerar valores que não podem ser salvos, visto que excedem esse valor. Quando é feita uma multiplicação em valores binários, o resultado possui o tamanho de \(t1 + t2\), sendo \textit{t1} o tamanho do primeiro operando e \textit{t2} o do segundo. Logo, em uma operação de multiplicação com dois operandos de mesmo tamanho, o resultado é um valor com o dobro do tamanho. 

Contudo, caso a metade mais significativa do resultado possua apenas zeros, eles podem ser descartados e a saída da ULA será do mesmo tamanho das entradas. Nesse caso, o valor salvo no \textit{regOverflow} será zero, pois o valor salvo como resultado não possuiu nenhuma alteração forçada pelo número de \textit{bits}. Já quando o resultado de uma operação multiplicação, por exemplo, possuir um valor 1 presente na metade mais significativa do valor, apenas a parte menos significativa será considerada. Logo, haverá uma alteração no resultado final forçada pela quantidade de \textit{bits}. Nesse caso, considera-se que houve um excesso de valores (\textit{overflow}) e é salvo, em \textit{regOverflow}, o valor 1. 

O último componente desta classe de instruções é o registrador responsável por salvar o resultado de uma comparação, sendo ele verdadeiro ou falso. Chamado de \textit{regComp}, tal registrador tem sua escrita ativa quando há a execução da instrução COMPARE\_OP e recebe 1 referente à uma comparação verdadeira e 0 a uma falsa. O uso desse registrador se faz necessário visto que a pilha não possui ligações com a unidade de controle, logo, as instruções de pulos, que serão vistas na subseção \ref{a_requisitos_jump}, não poderiam ser executadas. Consequentemente, a saída do componente \textit{regComp} precisa estar conectada ao controle.

A Figura \ref{img_analisearith} apresenta todos os componentes utilizados para a realização de operações aritméticas no processador. Os componentes nela presentes são a unidade lógica arimética (ULA), dois registradores de operandos (\textit{regOp1} e \textit{regOp2}), o registrador de comparação (\textit{regComp}) e o registrador de \textit{overflow} (\textit{regOverflow}).

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_aritmeticas.png}
\caption{Componentes utilizados para instruções que realizam operações aritméticas e comparações.}
\label{img_analisearith}
\end{figure}

\subsection{Instruções de pulos}
\label{a_requisitos_jump}

A classe de instruções responsáveis por executar pulos/desvios dentro do código \textit{Assembly} salvo na memória de instruções não necessita de nenhum componente específico para funcionar. Todas as operações realizadas por ela utilizam componentes que já foram citados nas subseções anteriores.

Então, para executar uma instrução que substitui o valor do registrador \textit{regPc} por seu argumento, tal como JUMP\_ABSOLUTE, utiliza-se a unidade lógica aritmética (ULA), que tem seu resultado ligado à entrada do registrador PC e sua entrada ligada, também, ao registrador de argumento. A seção \ref{projeto_arq} irá mostrar com mais detalhes as ligações necessárias para que se utilize os mesmos componentes para diferentes funções. Contudo, para se utilizar a ULA, precisa-se realizar uma operação lógica ou aritmética entre dois operandos. Como tem-se um valor que deverá substituir o valor de \textit{regPc}, a operação ideal a ser realizada na ULA é uma soma por zero. 

Em uma instrução onde se realiza um pulo controlado por um \textit{delta}, o qual seu valor será somado no valor de \textit{regPc} atual, utiliza-se também a ULA. Para isso, é necessário conectar a saída de \textit{regPc} à uma das entrada da ULA (que ela naturalmente já é conectada) e utilizar na outra entrada o valor que deverá ser somado ao PC, o qual virá do registrador \textit{regArg}. Após obter-se o resultado, ele é salvo em \textit{regPc} e a instrução é finalizada.

Nas instruções que necessitam de uma comparação anterior para serem executadas, utilizar-se-á o registrador de comparação. Tal registrador, ligado ao controle, o permitirá decidir se será realizada a substituição do valor de \textit{regPc} pelo valor do argumento da instrução ou não. Caso a substituição seja feita, ela ocorre exatamente como foi detalhado na explicação da instrução JUMP\_ABSOLUTE, nesta mesma seção. Caso ela seja ignorada, simplesmente soma-se o valor um ao valor de PC (PC+1) atual e segue-se executando as próximas instruções. As instruções que realizam pulos conforme o resultado de uma comparação são POP\_JUMP\_IF\_TRUE e POP\_JUMP\_IF\_FALSE.

Como dito anteriormente, para a realização de desvios não é necessário incluir nenhum novo componente, já que tais instruções utilizam componentes básicos e de operações aritméticas, apresentados nas Figuras \ref{img_analisebasicos} e \ref{img_analisearith}, respectivamente. 

\subsection{Instruções de chamada e retorno de funções}
\label{a_requisitos_funcoes}

As instruções responsáveis por chamar uma função e retornar da mesma são chamadas CALL\_FUNCTION e RETURN\_VALUE, respectivamente. Elas são de importantes quando se precisa reutilizar um trecho de código para mais de uma finalidade. A primeira, realiza uma chamada de função, salvando o valor de PC atual, incrementado em um, e realizando um desvio incondicional. Nela, ainda é preciso salvar o valor do ponteiro de \tos{} atual, visto que a chamada de uma função adiciona um bloco de dados na pilha, sendo necessário excluí-lo no retorno. Já a segunda obtém os valores salvos pela primeira, guarda o valor do topo atual da pilha. Após, retorna o valor de \textit{regPc} para PC+1, salvo anteriormente, e de \textit{regTos} para TOS+1, para que seja salvo um valor sem interferir nos dados já existentes na pilha. Após o retorno, o valor salvo do \tos{}, que era o topo do bloco da função na pilha, é salvo no topo da pilha atual, já sem o bloco.

Para melhor entendimento, pode-se utilizar um exemplo simples. A Figura \ref{img_analise_exemplo_funcoes} apresenta três pilhas listadas com suas letras. Em (a), pode-se perceber que existe um valor na primeira (e única) posição da pilha ocupada. Após, em (b), é chamada uma função que realiza uma operação entre os três valores carregados posteriormente, já dentro da função. No \tos{}, obtém-se um valor que é considerado o resultado da função. Quando a função é encerrada com a instrução RETURN\_VALUE, o valor presente no \tos{} é salvo no registrador de retorno de dados (\textit{regDataReturn}), o bloco da função, ou seja, a sequência de posições alocadas na pilha para receber os dados relativos a uma função, é excluído e esse mesmo valor retorna como sendo o valor do novo \tos{}. A pilha final, após a chamada e o retorno da função, pode ser vista na pilha (c). 

Vale lembrar que os valores não são fisicamente excluídos da pilha, somente são ignorados, pois para a arquitetura, os únicos valores que importam são os que estão abaixo do ponteiro que aponta para o \tos{}. Na Figura \ref{img_analise_exemplo_funcoes} os espaços aparecem em branco para melhor entendimento, mas na realidade o valores estão fisicamente lá, e só serão substituídos quando forem feitas novas escritas em suas posições.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_exemplo_funcoes.png}
\caption{Exemplo de comportamento de uma pilha ao ser manipulada por funções.}
\label{img_analise_exemplo_funcoes}
\end{figure}

Então, para realizar todas essas operações, são necessários novos componentes na arquitetura. Necessita-se salvar os valores de \textit{regPc} e de \textit{regTos} antigos, logo, a ideia inicial seria utilizar um registrador. Porém, como uma linguagem como \py{} permite que sejam chamadas inúmeras funções, umas dentro das outras, um registrador somente conseguiria retornar para a função imediatamente anterior à chamada atual. 

Assim, fá-se necessário o uso de uma pilha, que conseguiria guardar na ordem correta todos os valores de retornos. Assim, foram adicionadas, como mostra a Figura \ref{img_analise_funcoes}, as pilhas de função (\textit{pilhaFuncao}) e retorno de TOS (\textit{pilhaTosRetorno}), que guardam \textit{regPc} e \textit{regTos}, respectivamente.

Como toda pilha, ela tem seu próprio indicador de topo. Logo, necessita um registrador para salvar esse indicador. Então, adiciona-se um registrador chamado \textit{regTosFuncao}. Ele indicará o topo das duas pilhas que foram adicionadas, visto que elas trabalham juntas e devem estar na mesma posição sempre para que estejam sincronizadas.

Para atualizar o indicador de \tos{} principal, que gerencia a pilha principal, utiliza-se a unidade lógica aritmética. Porém, como ela já é utilizada para diversos fins diferentes, optou-se por adicionar um somador/subtrator, que terá como única função atualizar o valor do registrador \textit{regTosFuncao}, incrementando-o ou decrementando-o conforme a unidade de controle indicar.

Como dito, a Figura \ref{img_analise_funcoes} apresenta todos os componentes necessários para o correto funcionamento das instruções CALL\_FUNCTION e RETURN\_VALUE. Nela, são apresentados os pinos de entradas e saídas de cada componente, assim como seus nomes abaixo.  

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_funcoes.png}
\caption{Componentes utilizados para instruções que permite chamada e retorno de funções.}
\label{img_analise_funcoes}
\end{figure}