Para iniciar o desenvolvimento do sistema, foi necessário, anteriormente, definir o conjunto de instruções básico que seria implementado. Isso porque, para propor uma arquitetura funcional e que atenda todos os requisitos, é preciso já possuir o conjunto de instruções básico que deve ser implementado. Dessa forma, é possível fazer uma análise concreta dos componentes necessários na arquitetura.

A seção \ref{a_instrucoes} apresenta detalhadamente como foi escolhido o conjunto de instruções a ser implementado nesse trabalho. Após a escolha do mesmo, foi feita uma análise de requisitos do sistema, onde todas as instruções escolhidas foram analisas e foram escolhidos os componentes que devem estar presentes na arquitetura final. Esta parte do projeto está detalhada na seção \ref{a_requisitos}.

Somente após os dois primeiros passos, pode-se começar a projetar a arquitetura final. Para isso foram necessários conhecimentos técnicos e mais análises das instruções e seus funcionamentos. Na seção \ref{projeto_arq} são apresentadas as análises feitas e são comentadas as decisões tomadas as ligações internas entre os componentes.

Para completar o projeto da arquitetura e colocá-la em funcionamento, foi necessário desenvolver o módulo de controle, o qual é responsável por gerenciar todos os componentes que compõem a arquitetura, permitindo que todos funcionem coordenadamente com o objetivo de executar as instruções determinadas. A seção \ref{projeto_control} apresenta detalhadamente o controle e comenta seus atributos.

\section{Análise das instruções}
\label{a_instrucoes}

Antes de começar, então, a pensar em desenvolver a arquitetura propriamente dita, com suas ligações entre componentes e seu controle, foi preciso definir o que a arquitetura seria capaz de fazer. Como o tempo para o desenvolvimento deste trabalho não permite que todas as instruções presentes na máquina virtual da linguagem \textit{Python} sejam implementadas, foi preciso definir um conjunto de instruções que possa ser implementado dentro do prazo e que permita que algoritmos simples sejam executados. 

\subsection{Apresentação dos algoritmos utilizados}
\label{a_algo_sim}
Para escolher as instruções, foi necessária uma análise de diversos algoritmos implementados em \textit{Python} e que são considerados simples. Tais algoritmos servem como base para diversos outros algoritmos, já que são operações matemáticas básicas, gerenciamento de dados e pulos (\textit{jumps} ou desvios). 

Então, foram definidos 12 algoritmos que seriam utilizados como base para projetar a arquitetura, já que os trechos que código que os compõem estão presentes em praticamente todos os algoritmos \textit{Python} mais complexos. Os algoritmos escolhidos são:

\begin{description}
	\item[Criação de variáveis numéricas]: é um algoritmo que simplesmente cria uma variável \textit{Python} e atribui um valor numérico a ela, podendo ser qualquer valor. O propósito desse algoritmo é entender como uma variável é salva na memória externa (\textit{RAM}) do sistema.
	\item[Comparação simples]: criou-se um algoritmo que continha uma comparação \textit{if} simples com um bloco de instruções internas que seria executado caso a afirmação feita na comparação fosse verdadeira, ou então seria ignorado por completo. A comparação foi criada para que fosse possível entender como é feita uma comparação dentro do código \textit{Assembly Python} e entender quais as instruções encarregadas por desvios, comparação e carregamento de variáveis da memória para a pilha.
	\item[Comparação com \textit{else}]: é um algoritmo que contém uma chamada \textit{if} e, após, uma chamada \textit{else}. Este algoritmo foi utilizado para analisar como funciona, do ponto de vista do código \textit{Assembly}, o uso de um \textit{else}, indicando que, caso a afirmação contida no \textit{if} retorne como sendo falsa, o trecho de código interno ao \textit{else} seria executado. 
	\item[Comparação com \textit{elif} e \textit{else}]: é o algoritmo que contém, além do \textit{if} e \textit{else} no início e no final, respectivamente, uma comparação intermediária chamada, chamada na linguagem \textit{Python} de \textit{elif}. Essa segunda comparação será executada caso ela seja verdadeira e a primeira seja falsa. Esse algoritmo foi utilizado para verificar a existência de diferenças entre o uso do \textit{elif} e os outros algoritmos de comparação apresentados anteriormente.
	\item[Estrutura de repetição \textit{while}]: foi criado um algoritmo que implementa uma estrutura de repetição \textit{while}. Sua criação foi necessária para que fosse possível evidenciar os diferentes pulos que são utilizados no código \textit{Assembly Python} ao se utilizar diferentes estruturas de repetição.
	\item[Estrutura de repetição \textit{for}]: algoritmo idêntico ao anterior, porém utilizando, no lugar do \textit{while}, a estrutura de repetição \textit{for}. Foi possível analisar, com ele, as diferenças entre os dois algoritmos.
	\item[Operação aritmética de soma simples]: foi criada uma operação aritmética de soma simples, a qual foram somados dois valores constantes e, após, seu resultado foi salvo em uma variável. 
	\item[Operação aritmética de soma de constante com variável]: algoritmo executa uma soma de uma variável previamente salva na memória com uma constante, salvando o resultado em outra variável. Esse algoritmo foi criado para permitir a análise de como são feitos os carregamentos de dados já existentes e os dados chamados como constantes, sem estarem salvos e como são manipulados dentro de uma operação aritmética.
	\item[Operação aritmética de soma com duas variáveis]: algoritmo executa a soma de duas variáveis previamente salvas na memória e armazena o resultado em outra variável. Com ele, é possível entender como são feitos os carregamentos das variáveis e a ordem em que é feito.
	\item[Operação aritmética de subtração de variáveis]: algoritmo executa a subtração de dois valores salvos na memória. Sua implementação foi influenciada pelo fato de ser possível analisar quais tipos de operações aritméticas a máquina virtual \textit{Python} é capaz de executar nativamente, sem a necessidade de quebrar uma operação em pequenas operações internas.
	\item[Operação aritmética de multiplicação de variáveis]: executa a multiplicação de dois valores salvos em variáveis. Foi necessário para entender se, dentro da máquina virtual \textit{Python}, uma multiplicação era feita por uma sequência de somas separadas, definidas no código \textit{Assembly}, ou se existia uma instrução específica para executar a multiplicação.
	\item[Operação aritmética de divisão de variáveis]: implementa uma divisão entre dois valores. Sua necessidade de implementação vem do fato de ser preciso entender, assim como na multiplicação, se existia uma instrução específica para tal operação ou se eram feitas subtrações sucessívas.  
\end{description}

\subsection{Análise dos algoritmos utilizados}
\label{a_instrucoes_algo}


De posse dos algoritmos acima apresentados, foi utilizada uma ferramenta presente no próprio compilador \textit{Python}, chamada \textit{dis} (fazendo referência à \textit{disassembler}), capaz de mostrar o código \textit{Assembly} do algoritmo implementado em alto nível. Então, colocando os algoritmos prontos na ferramenta, ela retornava o código \textit{Assembly} referente ao algoritmo. Tal código é o que é enviado para a máquina virtual para ser executado.

A Figura \ref{img_1_simple} apresenta o código \textit{Assembly} do primeiro algoritmo apresentado. Ele cria uma variável, salvando o valor em um endereço de memória específico. Após, ele carrega o valor novamente para a pilha e imprime na tela. Todos os algoritmos apresentados aqui contém as instruções de impressão na tela \textit{PRINT\_ITEM} e \textit{PRINT\_NEWLINE}, porém elas não serão importantes para o projeto da arquitetura, já que elas serão implementadas diretamente em \textit{software}, não em \hw{}.

Então, com a análise da Figura \ref{img_1_simple}, é possível perceber instruções básicas para um código \textit{Assembly Python}, tais como LOAD\_CONST, STORE\_FAST e LOAD\_FAST. A primeira é responsável por encaminhar para a pilha um valor constante, passado como argumento. Tal valor será salvo no \tos{} e será manipulado de acordo com a próxima instrução. A segunda instrução encontrada salva o valor encontrado no \tos{} na memória externa do sistema, definindo o endereço onde ele será salvo e o passando como argumento. O endereço definido será o mesmo utilizado para acessar tal variável futuramente. Então, ao se afirmar que determinada variável terá o nome de "\textit{variavel}", define-se o endereço desta variável e, toda vez que ela precisar ser acessada, será o endereço dela que será passado como parâmetro da instrução STORE\_FAST e não o nome da variável diretamente. Por fim, a terceira instrução executa um carregamento de uma variável diretamente da memória principal para a o \tos{}. O endereço onde a variável foi salva na memória será informado no argumento. 

A definição dos argumentos de cada instrução cabe ao compilador, então ele deverá escolher um endereço onde a variável será salva e passar tal endereço todas as vezes em que a mesma variável precisar ser acessada ou modificada. Uma variável, por exemplo, de nome "\textit{var}" recebe o endereço de 8 \textit{bits} 00001100. Logo, ao ser salva na memória, ela será salva na posição de memória referente a este endereço utilizando STORE\_FAST e, ao ser acessada com um futuro LOAD\_FAST, deverá ser passado como argumento da instrução o mesmo endereço 00001100. 

É possível perceber, ainda, através da análise da Figura \ref{img_1_simple}, que um valor precisa ser carregado na pilha antes de se tornar uma variável. Isso acontece porque a instrução encarregada por salva determinado valor na memória principal age apenas na pilha. Ou seja, a instrução sempre executará tendo como foco salvar o \tos{} na memória principal. Logo, a criação de uma variável, que em alto nível é feita simplesmente utilizando "\(var = 10\)", em baixo nível utiliza duas instruções: LOAD\_CONST e STORE\_FAST.

Por último, após a execução de todo o código, é feita uma chamada da instrução RETURN\_VALUE, que finaliza a execução dessa função. Como o algoritmo só tinha essa função, finalizar a execução dela significa finalizar a execução do algoritmo por completo.

\begin{figure}[htp]
\centering
\includegraphics{images/1_simple.png}
\caption{Código \textit{Assembly} de uma criação de variável.}
\label{img_1_simple}
\end{figure}

A análise da Figura \ref{img_2_if} nos permite entender como é feita uma comparação em código \textit{Assembly} da linguagem \py{}. O algoritmo apresentado nela implementa uma chamada \textit{if} sozinha, sem acompanhamento de \textit{elif} ou \textit{else}. Isso significa que o trecho de código contido no corpo do \textit{if} somente irá impactar na execução do sistema se a comparação for verdadeira, não tendo, portanto, nenhuma execução caso a primeira afirmação seja falsa. Em outras palavras, caso a afirmação retorne como sendo falsa, a chamada \textit{if} será completamente ignorada, diferente do que acontece nas Figuras \ref{img_2_if_else} e \ref{img_2_if_elif_else}.

Então, ao analisar-se a Figura \ref{img_2_if}, pode-se perceber que acontece o que já foi visto na Figura \ref{img_1_simple} no que diz respeito ao armazenamento de uma variável na memória principal. Então, após salvar uma variável que será utilizada para fazer a comparação na memória principal, ela é carregada para a pilha novamente para que seja efetuada a comparação. Contudo, é preciso realizar uma operação que depende de outro valor, uma constante, que ainda não está na pilha, mas precisa estar. Então é feito um carregamento da constante diretamente para a pilha. Tal constante é o valor que será comparado com a variável e resultará em um resultado afirmativo ou negativo para a comparação. 

Com os dois operandos carregados (variável e constante), é possível notar a existência de uma nova instrução, a qual ainda não foi analisada. Tal instrução é chamada de COMPARE\_OP e ela é encarregada por executar uma comparaçã entre o \tos{} e a posição logo abaixo dele. Ela define o tipo de comparação que será feita através dos valores passados como argumento. No caso da Figura \ref{img_2_if}, está sendo executada uma comparação "maior que" (>). O compilador define que tal comparação recebe o valor 4, em decimal, indicando a chamada do "maior que", e o coloca como argumento. 

Após a comparação, pode ser encontrada uma instrução chamada POP\_JUMP\_IF\_FALSE, que executa um pulo caso a comparação anterior seja falsa. Para entender melhor isso, é necessário pensar diretamente em um algoritmo de alto nível. Em um algoritmo de alto nível, ao ser chamado um \textit{if}, logo abaixo, sequencialmente, é escrito o trecho de código que será executado caso a afirmação seja verdadeira. Contudo, caso seja falsa, esse código não deverá ser executado. Então, quando se fala de um código \textit{Assembly}, para não executar determinado trecho de código, precisa-se pulá-lo/desviá-lo. Portanto, a instrução POP\_JUMP\_IF\_FALSE executa um desvio, caso a afirmação feita no \textit{if} seja falsa, com o intuito de pular o trecho de código que deveria ser executado apenas quando a afirmação fosse verdadeira.

Ainda na mesma figura, pode-se ver que aparece outra instrução que ainda não foi apresentada, chamada JUMP\_FORWARD. Tal instrução executa um pulo incondicional, ou seja, sem depender de uma comparação prévia. Esse pulo sempre acontecerá quando a instrução for lida, diferentemente da instrução anterior, onde o pulo só acontecerá se a comparação anterior for falsa. A instrução JUMP\_FORWARD executa um pulo em que o valor atual do contador de programa (PC) é incrementado com um valor fixo, chamado de "\textit{delta}". É importante observar que o valor de PC não é substituído por completo pelo novo valor, mas sim é feita uma soma entre o valor de PC atual e o \textit{delta}. O resultado da soma será o novo valor de PC.

Finalizando a análise do código \textit{Assembly} da Figura \ref{img_2_if}, pode-se perceber que após a comparação, então, é feito um pulo condicional para a linha de código após o trecho de código interno ao \textit{if}. Isso porque o desvio incondicional só é executado caso o bloco de código encontrado no corpo do \textit{if} seja executado, fazendo com que o algoritmo finalize após sua execução. O destino deste pulo, então, são as linhas de código que finalizam o algoritmo. 

\begin{figure}[htp]
\centering
\includegraphics{images/2_if.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if} simples.}
\label{img_2_if}
\end{figure}

A Figura \ref{img_2_if_else} apresenta um código quase igual ao apresentado na Figura \ref{img_2_if}. Contudo, ele acrescenta um trecho de código que deverá ser executado caso a afirmação feita no \textit{if} seja falsa. Então, não se pode dizer que a estrutura \textit{if} será completamente ignorada nesse caso. 

Porém, do ponto de vista do código \textit{Assembly}, não é adicionada nenhuma instrução nova. A grande diferença dos dois códigos \textit{Assembly}, portanto, é que o pulo condicional de quando a comparação resulta como sendo falsa direciona o \pc{} para executar o trecho de código responsável pela saída alternativa ao \textit{if}. Na imagem anterior, não existia tal saída, portanto, o pulo direcionava o contador para fora da estrutura \textit{if} e, como o algoritmo só possuia tal estrutura, para o final da sua execução. 

Continua-se tendo um pulo incondicional idêntico ao da figura anterior, o qual direciona o programa para o final da sua execução. Pode-se observar que só existe pulo incondicional após o trecho de código executado caso a comparação seja verdadeira. No trecho executado caso ela seja falsa, não se tem um pulo pois é esperado que esse trecho somente seja executado como última instância, não sendo preciso realizar nenhum pulo após ele, já que ao finalizar sua execução já estar-se-á fora da estrutura \textit{if}. 

Nesse algoritmo, fica claro o motivo de se utilizar um desvio incondicional relacionado a um \textit{delta} e não um desvio absoluto, que será visto a seguir e que substitui o valor do \pc{} por um valor. O motivo, então, é que o compilador calcula a quantidade de linhas necessárias para pular completamente o trecho de código contido em \textit{else} e o adiciona ao \pc{}, fazendo com que o algoritmo seja executado uma linha após a última linha do trecho. Um pulo absoluto não seria ideial pois o valor deveria ser exatamente o valor da última linha de \textit{else} somado com um, se tornando, portanto, mais difícil e custoso para o compilador montar o código \as{}.

\begin{figure}[htp]
\centering
\includegraphics{images/2_if_else.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if} contendo \textit{else}.}
\label{img_2_if_else}
\end{figure}

Na Figura \ref{img_2_if_elif_else}, segue-se a mesma lógica vista nas Figuras \ref{img_2_if} e \ref{img_2_if_else}, porém com a adição de uma nova comparação após a primeira. Como neste algoritmo implementa-se uma estrutura \textit{if} que contém duas comparações e uma saída padrão, que será executada caso as duas sejam falsas, é possível perceber isso também no código \textit{Assembly}. 

Assim como na Figura anterior, não é possível verificar nenhuma instrução diferente das que já foi visto até o momento. Contudo, a estrutura do código \textit{Assembly} é levemente diferente. Após executar-se a primeira comparação e o \pc{} estar apontando para o primeiro pulo, ele é então direcionado diretamente para a segunda comparação, caso a primeira retorne falsa. Caso a segunda retorne falsa também, o valor de PC recebe a linha de código inicial do trecho de código padrão, que será executado somente se as duas retornem falsas. 

Com a inserção de uma nova comparação, agora também pode ser visto mais de um pulo incondicional. Pode-se observar, também, que ainda não é encontrado um pulo incondicional após a segunda comparação, somente após o trecho de código presente no seu corpo. O motivo para isso é o mesmo apresentado anteriormente.  

\begin{figure}[htp]
\centering
\includegraphics{images/2_if_elif_else.png}
\caption{Código \textit{Assembly} de uma comparação \textit{if}, contendo \textit{elif} e \textit{else}.}
\label{img_2_if_elif_else}
\end{figure}

A Figura \ref{img_3_while} é a primeira que apresenta a implementação de uma estrutura de repetição em \textit{Assembly}. Através de sua análise, pode-se perceber a inserção de algumas novas instruções. Porém, mantém-se a sequência de chamada de instruções para executar operações mais simples, tais como comparações, onde as constantes a serem comparadas são carregadas para a pilha antes de executar a instrução COMPARE\_OP. 

Analisando este código, pode-se perceber que, primeiramente, ocorre a criação de uma variável na memória. Tal variável será utilizada para gerenciar a estrutura de repetição. Ela será iniciada com um valor, no caso da Figura o valor é zero, e irá receber uma sequência de somas. Quando seu valor exceder um valor pré-definido, no caso 10, a estrutura será finalizada. 

Após a criação e atribuição de valor à variável, é chamada a primeira instrução nova, SETUP\_LOOP. Tal instrução é encarregada por inicializar um bloco, responsável pela estrutura de repetição (\textit{loop}) na pilha. A instrução seguinte inicia um procedimento de comparação, onde os dois valores a serem comparados são carregados para a pilha. O primeiro valor, a variável a ser comparada, e o segundo, o valor que define o final da execução da estrutura, serão os operandos da instrução COMPARE\_OP, executada exatamente na sequência dos dois carregamentos. 

Assim como em uma instrução \textit{if}, existe um trecho de código que só deverá ser executado enquanto o programa estiver rodando dentro do \textit{loop}. Logo, após a comparação, existe um POP\_JUMP\_IF\_FALSE, que visa evitar a execução de tal trecho caso o valor da variável seja maior que 10. Então, o pulo é feito diretamente para a instrução que define a retirada do bloco da pilha. Essa instrução, chamada POP\_BLOCK, retira o bloco do \aloop{} da pilha e finaliza, então, a execução dele. 

Caso o programa siga sendo executado dentro do \textit{loop}, o trecho de código presente no interior da repetição será executado e, após, é feito um incremento ao valor da variável, o qual será salvo exatamente na mesma posição de memória que define a variável. Para essa operação, é utilizada a instrução INPLACE\_ADD. Sua execução é similar às operações BINARY\_, que será visto a seguir. Contudo, ela permite que o resultado seja o valor original da variável. Para reiniciar a estrutura de repetição, é feito um JUMP\_ABSOLUTE, onde o valor do contador de programa é completamente substituído pelo valor que aponta para a primeira linha de execução do \textit{loop}, no caso linha 9. 

\begin{figure}[htp]
\centering
\includegraphics{images/3_while.png}
\caption{Código \textit{Assembly} de uma estrtutura de repetição \textit{while}.}
\label{img_3_while}
\end{figure}

A Figura \ref{img_4_for} apresenta a segunda estrutura de repetição implementada, a qual é chamada de \textit{for}. Tal instrução apresenta algumas instruções novas, porém sua execução é bem similar à vista na Figura \ref{img_3_while}. 

Exatamente como a análise anterior, pode-se observar que a estrutura de repetição começa salvando a variável que irá gerenciar o \textit{loop} e, após, aloca-se um bloco na pilha, com a instrução SETUP\_LOOP. A adição de uma nova instrução à lista se dá na linha exatamente abaixo a essa, na qual é chamada a instrução LOAD\_GLOBAL. Tal instrução é responsável por carregar um alcance para a estrutura de repetição, o qual dirá qual será a última vez que o \textit{loop} será executado.

Diferentemente da estrutura \textit{while}, a estrutura \textit{for} define os parâmetros de execução antes mesmo de realizar o início do \textit{loop}. Então, são carregados para a pilha como constantes o valor inicial, zero, e o valor final, cinco. Após, é feita uma chamada de função, realizada pela instrução CALL\_FUNCTION, onde o número de parâmetros serão passados como argumento. Ao realizar a chamada desta instrução, o número de parâmetros é analisado pelo sistema e é realizado o carregamento destes parâmetros, para que possam ser utilizados na execução do \textit{loop}. É então feita as chamadas das instruções GET\_ITER e FOR\_ITER, que criam os blocos de \textit{loop} dentro da pilha. Tais blocos serão utilizados para que as chamadas de instruções internas ao \textit{loop} possam utilizar variáveis sem que as variáveis iniciais sejam perdidas.

Para finalizar a execução do \textit{loop}, é executado o trecho de código interior à estrutura, após é realizado um incremento na variável que gerencia o \textit{loop} e, então, é feito um pulo para a primeira linha da estrutura. Note que, no caso do \textit{for}, a primeira linha considerada não é a chamada de variáveis para realizar a comparação inicial, mas sim a linha 22, onde se encontra a instrução FOR\_ITER. Isso se deve ao fato de que tal instrução gerencia a saída do \textit{loop} ao seu final, e não uma comparação, como no \textit{while}. 

\begin{figure}[htp]
\centering
\includegraphics{images/4_for.png}
\caption{Código \textit{Assembly} de uma estrutura de repetição \textit{for}.}
\label{img_4_for}
\end{figure}

A próxima imagem, Figura \ref{img_5_add}, apresenta a primeira operação aritmética realizada. Através dela, é possível perceber como é feita a conversão de um código alto nível, escrito em \textit{Python}, feita pelo compilador, que realiza uma atribuição de variáveis com soma. 

Pode-se perceber, porém, que na Figura, só existe uma instrução de carregamento para a pilha, diferentemente das outras operações aritméticas. Tal instrução, LOAD\_CONST, pega o valor 15, e o carrega para a pilha. No entanto, ao escrever o código em alto nível, foi definido que o valor a ser salvo na pilha seria \(10 + 5\). Logo, pode-se concluir que o compilador, visando simplificar a operação e retirar linha de códigos de baixo nível, realizou a soma antes de definir qual seria o argumento da instrução LOAD\_CONST, definindo, então, como sendo o resultado da soma. 

\begin{figure}[htp]
\centering
\includegraphics{images/5_add.png}
\caption{Código \textit{Assembly} de uma operação aritmética de soma com duas constantes.}
\label{img_5_add}
\end{figure}



\begin{figure}[htp]
\centering
\includegraphics{images/5_add_var_int.png}
\caption{Código \textit{Assembly} de uma operação de soma com uma variável e uma constante.}
\label{img_5_add_var_int}
\end{figure}

Diferentemente da Figura \ref{img_5_add}, a Figura \ref{img_5_add_var_int} mostra um código \textit{Assembly} que vem de um algoritmo \textit{Python} que realiza a soma de uma variável com uma constante e armazena o resultado em outra variável. Para isso, primeiramente, como já visto nas figuras anteriores, existe a criação da primeira variável, onde ela é carregada como constante para a pilha e, após, é salva na memória em um endereço que é referenciado como sendo a primeira variável ("\textit{val1}").

Logo após, carrega-se a variável novamente para a pilha, com a instrução responsável por executar um carregamento de uma variável previamente criada, e carrega-se também o segundo operando, a constante, a qual será somada à "\textit{val1}". Com os dois operandos dispostos nas duas posições mais superiores à pilha, executa-se a primeira instrução responsável por executar uma operação aritmética. 

No caso de uma soma, as instruções que carregam os operandos para a pilha podem ser executadas em qualquer ordem, já que o resultado será o mesmo. Contudo, ao realizar-se uma subtração ou divisão, os resultados obtidos poderiam diferentes dependendo da ordem dos operandos. Para garantir a ordem, foi definido que o operando encontrado à esquerda da operação (operando 1) seria o primeiro a ser carregado e, em seguida, carrega-se o operando 2. Assim, quando os dados são lidos para ser somados, o \tos{} é lido primeiro e, nessa posição, encontra-se o operando 2. Portanto, pode-se considerar que a leitura dos operandos na pilha é inversa à ordem em que eles devem ser posicionados na operação, já que o operando 1 é o segundo a ser carregado.

A instrução aritmética é então, chamada para realizar a operação. Tal instrução recebe o nome de BINARY\_ADD e executa uma soma entre dois operandos. Os dois operandos utilizados vêm do \(TOS-1\) e TOS, respectivamente. Essa instrução não necessita de valores presentes no \textit{byte} de argumento, visto que seus operandos serão sempre os mesmos e que a operação também será sempre a mesma. Para realizar-se outra operação aritmética, utiliza-se códigos de instrução diferentes. Então, seu campo de argumento pode aparecer qualquer valor, pois ele será completamente ignorado. No caso da Figura \ref{img_5_add_var_int}, o campo aparece em branco, mas ao se converter para um código binário, ele precisa aparecer, mesmo que seja aleatório.

A execução de todas as operações aritméticas, as quais estão sendo mostradas também nas Figuras \ref{img_5_add_var_var}, \ref{img_5_sub}, \ref{img_5_multi} e \ref{img_5_div}, se dá de maneira semelhante. As duas posições topo da pilha, aqui chamadas de TOS e TOS1, sendo a segunda considerada a posição logo abaixo ao topo, são retiradas da pilha e carregadas para uma unidade que realizará a operação aritmética. Tal unidade, por se tratar de uma máquina virtual, é simplesmente simulada e, possivelmente, não exista. Contudo, em uma arquitetura física, uma unidade do tipo se torna indispensável. 

Então, ao serem carregados os dois operandos, executa-se a operação definida pela instrução, que pode ser soma, subtração, multiplicação ou divisão. Ao realizar tal operação, o resultado dela é armazenado no lugar antes ocupado pelo operando TOS1. Então, considera-se, do ponto de vista de posições na pilha, que a operação acontece tal como a Equação \ref{eq_arit_pilha} mostra.

\begin{equation} \label{eq_arit_pilha}
	TOS1 = TOS1 + TOS
\end{equation}

Todas as operações aritméticas acontecem da mesma forma, onde a primeira variável a ser carregada (TOS) se torna o segundo operando da equação e, a segunda (TOS1), o primeiro operando. O resultado é salvo no lugar onde estava TOS1.

\begin{figure}[htp]
\centering
\includegraphics{images/5_add_var_var.png}
\caption{Código \textit{Assembly} de uma operação aritmética de soma com duas variáveis.}
\label{img_5_add_var_var}
\end{figure}

A Figura \ref{img_5_add_var_var} realiza a mesma operação aritmética mostrada na Figura \ref{img_5_add_var_int}, com a diferença apenas nas origens dos operandos. Ao invés de ser executada a soma entre uma variável e uma constante, é executada a soma entre duas variáveis. Então, para isso, é preciso que as duas variáveis tenham sido salvas na memória e, então, carregadas novamente para a pilha. Para tal procedimento, é necessário o uso das instruções STORE\_FAST e LOAD\_FAST uma vez a mais do que o que foi visto anteriormente, na Figura \ref{img_5_add_var_int}.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_sub.png}
\caption{Código \textit{Assembly} de uma operação aritmética de subtração.}
\label{img_5_sub}
\end{figure}

Já as Figura \ref{img_5_sub}, \ref{img_5_multi} e \ref{img_5_div} seguem a mesma lógica empregada na Figura \ref{img_5_add_var_var}, com a diferença de que realizam operações aritméticas diferentes, sendo elas subtração, multiplicação e divisão, respectivamente. Perceba que as instruções aritméticas de cada uma delas estão destacadas nas figuras.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_multi.png}
\caption{Código \textit{Assembly} de uma operação aritmética de divisão.}
\label{img_5_multi}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/5_div.png}
\caption{Código \textit{Assembly} de uma operação aritmética de divisão.}
\label{img_5_div}
\end{figure}

\subsection{Definição das instruções escolhidas}
\label{def_inst_esc}

Baseados nas análises de algoritmos simples e sabendo que tais algoritmos estão presentes em praticamente 100\% dos algoritmos escritos em \textit{Python}, foi possível definir o conjunto de instruções mínimo para a arquitetura cobrir. As instruções escolhidas para serem executadas deverão possuir suporte na arquitura e serem executadas completamente em \textit{hardware}.

Para iniciar a lista, começar-se-á com as instruções de manipulação de dados. Estas instruções são responsáveis por definir quais dados entram e saem da pilha, assim como a ordem que eles entram e o endereço onde o \tos{} será salvo na memória principal. As instruções dessa categoria que serão implementadas são:

\begin{description}
	\item[LOAD\_CONST]: carregamento de um valor constante, passado por argumento, para o topo da pilha. Tal valor ocupa a posição de \textit{opArg} e, portanto, deverá conter 8 \textit{bits}. Esta instrução pode ser considerada a mais importante do código \textit{Assembly} \py{} que será implementada, pois ela é a única que permite a entrada de um valor externo no sistema. Sem ela, nenhum valor poderia ser salvo na memória ou sequer utilizado no sistema.
	\item[LOAD\_FAST]: é a instrução que permite a existência de variáveis. Na programação em qualquer linguagem, a utilização de variáveis é extremamente necessária e importante, para que os valores sejam manipulados dentro dos programas. Quando se fala de uma arquitetura física, possui-se números limitados de registradores e memória utilizável pelo sistema, então precisa-se salvar os valores que não estão sendo utilizados no momento em algum lugar onde eles possam ser recuperados posteriormente, sem serem perdidos. Este lugar é a memória principal. Portanto, esta instrução é a única que permite a recuperação de um valor previamente salvo na memória principal. Sem ela, seria impossível a existência e manipulação de variáveis dentro de uma arquitetura física. Portanto, ela é de vital importância para o sistema e deverá ser suportada na arquitetura.
	\item[STORE\_FAST]: a instrução anterior, LOAD\_FAST, é de extrema importância para a manipulação de variáveis. Porém ela só atende um lado dessa manipulação de variáveis, que é o carregamento da memória para a pilha. Contudo, uma variável precisa ser salva na memória principal previamente para, então, poder ser carregada. O salvamento de uma variável na memória é feito por essa instrução, sendo, portanto, também fundamental para a existência de variáveis na arquitetura.
	\item[LOAD\_GLOBAL]: essa é a instrução presente, até o que foi analisado, nas estruturas \textit{for}. Ela realiza o carregamento de um \textit{range} (alcance) que a estrutura terá. Ou seja, quando se executa um \textit{for}, tem-se um valor inicial e um valor final. O \textit{range} é a "distância" entre esses dois valores, indicando quantas vezes dever-se-á executar o código interno à estrutura.
\end{description}

As quatro instruções de manipulação de dados apresentadas acima possuem grande importância para uma arquitetura física, porque ela deverá ser capaz de suprir uma necessidade básica da linguagem \textit{Python}, que é a manipulação de variáveis e dados. Então, a escolha delas é justificada pela grande importância e pela elevada taxa de utilização destas instruções, que estão presentes praticamente todos os algoritmos, desde os mais simples até os mais complexos. 

Das instruções analisadas na subseção \ref{a_instrucoes_algo}, foi definido que as quatro operações básicas da matemática seriam suportadas na arquitetura física. Para isso, o código \textit{Assembly Python} possui uma instrução específica para cada uma das operações. São elas:

\begin{description}
	\item[BINARY\_ADD]: executa uma soma binária, ou seja, entre dois valores. Os valores escolhidos para tal operação são o TOS e a posição exatamente abaixo dele, salvando o resultado na posição desta última. A operação de soma é uma das operações mais importantes de um sistema, pois ela é necessária para definir-se o topo da pilha e para avançar para outra instrução, incrementando o contador de programa. Contudo, tais operações são operações básicas do sistema e que não dependem desta instrução, apenas dessa funcionalidade. Mas, como elas deverão ser implementadas, adicionar também uma instrução que execute uma operação de soma entre dois operandos reaproveitará os mesmos componentes da arquitetura. As operações aritméticas são de extrema importância, visto que a maioria dos algoritmos executam uma hora ou outra uma manipulação de valores.
	\item[BINARY\_SUBTRACT]: é a instrução responsável por executar uma subtração entre dois operandos. Assim como a instrução anterior, ela executa tal operação entre o TOS e TOS-1, e salva o resultado em TOS-1. 
	\item[BINARY\_MULTIPLY]: é a instrução responsável por executar uma multiplicação entre dois operandos. Caso ela não fosse implementada, sempre que uma operação de multiplicação fosse solicitada na linguagem de alto nível, ela deveria ser realizada através de uma soma sucessiva manualmente (contendo cada instrução de soma no código \textit{Assembly}).
	\item[BINARY\_DIVIDE]: realiza uma divisão entre dois operandos. Sua implementação, assim como a multiplicação, se faz necessária para simplificar o código \textit{Assembly} e acelerar a execução dentro da arquitetura.
\end{description}

Em anexo às instruções de operações aritméticas, pode-se incluir da instrução INPLACE\_ADD, que possui seu funcionamento muito semelhante à instrução BINARY\_ADD, porém com a diferença de aceitar que o resultado seja o mesmo de um dos operandos. Ela é utilizada principalmente na estrutura de repetição \textit{while}, quando executa-se um incremento de um em um valor (\(val++\)).

Portanto, as instruções responsáveis por operações aritméticas são de extrema importância, visto que a existência de manipulação de números dentro de algoritmos escritos em qualquer linguagem é uma exigência mínima. Para viabilizar a utilização de tais operações dentro da arquitetura física, as operações mais importantes foram definidas e receberão suporte na arquitetura.

Pode-se citar ainda instruções que executam pulos (\textit{jumps}). Elas são de vital importância, pois nenhum algoritmo de programação executa em uma sequência estática. Muitas vezes, os trechos de código que serão executados dependem de resultados anteriores, podendo, então, pular trechos e voltar para executar novamente outros. As instruções do código \textit{Assembly Python} escolhidas para serem suportadas dentro da arquitetura aqui proposta foram:

\begin{description}
	\item[POP\_JUMP\_IF\_FALSE]: é a instrução utilizada, principalmente, em estruturas \textit{if}, onde se precisa executar um trecho de código escrito logo após uma comparação, quando ela é falsa. Ela executa um pulo onde o valor do contador de programa (PC) é completamente substituido pelo valor contido no argumento (\textit{opArg}) da chamada desta instrução. Porém, só ocorrerá a substituição caso o resultado de uma comparação executada anteriormente seja negativo. Ela é extremamente importante para facilitar a tomada de decisão dentro de um algoritmo.
	\item[POP\_JUMP\_IF\_TRUE]: é exatamente a operação inversa à instrução anterior. Ela não aparece em nenhum dos algoritmos apresentados na subseção \ref{a_algo_sim}, porém sua implementação utiliza a mesma base da instrução anterior. Logo, sua implementação simplesmente precisa ser executada caso a comparação retorne como sendo positiva.
	\item[JUMP\_FORWARD]: é a instrução utilizada, principalmente, para executar a saída do trecho executado em uma comparação, quando a mesma retorna como sendo positiva. Ela realiza um incremento do valor do contador de programa, substituindo-o pelo novo valor. Seu argumento é chamado de \textit{delta} e é o valor usado para ser somado a PC. Ela é utilizada dentro das estruturas \textit{if} porque seu funcionamento permite que o compilador simplesmente veja quantas linhas de código devem ser executadas quando a comparação for positiva e, então, incrementar o valor do contador com esse valor. Isso acontece porque, quando tal instrução é escrita pelo compilador, ainda não foi definido qual será o primeiro valor de PC que estará fora da estrutura \textit{if}. Sendo assim, se torna difícil utilizar a próxima instrução.
	\item[JUMP\_ABSOLUTE]: é a instrução responsável por substituir completamente o valor de PC pelo seu argumento. Ela é utilizada, principalmente, em estruturas de repetição, pois é preciso retornar ao início da estrutura sem realizar nenhuma comparação prévia. Então, salva-se como \textit{OpArg} desta instrução o valor da primeira linha da estrutura e, ao ser executada essa instrução, o valor de PC é substituído e reinicia-se a repetição.
\end{description}

\begin{description}
	\item[COMPARE\_OP]: é a instrução responsável por realizar uma comparação entre dois valores. Ela possui um formato semelhante às instruções aritméticas, porém seu argumento contém o tipo de comparação que deverá ser feito (>, <, =). Após ser executada, ela gera um sinal (\textit{flag}) indicando que seu resultado foi verdadeiro ou falso para que possa-se executar um desvio condicional na sequência.
	\item[SETUP\_LOOP]: inicia, na pilha, um bloco de repetição. Esse bloco guardará os valores envolvidos diretamente na repetição. 
	%\item[GET\_ITER]: .........
	%\item[FOR\_ITER]: .........
\end{description}


\begin{description}
	\item[CALL\_FUNCTION]: é a instrução responsável por inicializar uma função. Sua chamada causa o salvamento do valor de PC+1 (indicando o ponto de volta da instrução a seguir), um desvio para o bloco de código que deve ser executado e uma alocação de um bloco de função na pilha, o qual receberá os valores manipulados dentro da função e, após seu fim, os apagará.
	\item[RETURN\_VALUE]: é a instrução que define o final de uma função. Ela retorna o valor no \tos{} presente no bloco da função para a função anterior, a qual chamou essa função. Ao executar essa instrução, o valor de PC é atualizado com o valor salvo na chamada da função e, portanto, realiza-se um desvio para que o código siga executando a função antiga de onde parou. 
	\item[POP\_BLOCK]: retira um bloco completo da pilha. É utilizado ao final de uma função, para retirar o bloco que foi adicionado na pilha para a execução da função. Então, o \tos{} retorna para o TOS anterior à chamada da função. 
\end{description}


\section{Análise de requisitos para a arquitetura}
\label{a_requisitos}

Após realizadas as análises sobre quais serão as instruções a serem implementadas, inicialmente, na arquitetura, é preciso projetar a arquitetura de forma que consiga atender a todos os requisitos de cada instrução. Para isso, atender a todas as instruções acima descritas se torna necessário. 

Para iniciar tal análise, foram separadas em diversas subseções os diferentes tipos de instruções, tais como foram separadas na subseção \ref{def_inst_esc}. Isso se deve ao fato de que analisar a arquitetura como um todo, em uma só subseção, é inviável, visto poderia ficar uma leitura massante e confusa.

\subsection{Conceitos básicos}
\label{a_requisitos_basicos}

Antes de iniciar a análise das instruções propriamente ditas, é necessário que a arquitetura consiga suportar a entrada e o gerenciamento delas. Para isso, é preciso que conceitos básicos de execução de algoritmos sejam analisados. %\textbf{CITAR REFERENCIA DE EXECUÇÃO DE ALGORITMOS PC+1} 

Ao executar-se um algoritmo, as instruções \textit{Assembly} são salvas em uma memória específica para elas e, então, são percorridas sequencialmente, podendo haver desvios (pulos) entre elas ou não. Assim, o primeiro componente que deve ser adicionado à arquitetura é uma memória de instruções, chamada de \textit{memInstr}. Ela será responsável por salvar os argumentos (\textit{OpArg}) e os códigos de instruções (\textit{OpCode}), tais como foram apresentados na seção \ref{rf_modos_enderecamento}. Então, cada posição de sua memória deverá receber uma instrução, juntamente com seu argumento (mesmo que ele seja dispensável, como nas instruções BINARY\_). Desta forma, torna-se necessário que cada bloco da memória de instruções possua 2 \bys{}, já que tanto \textit{OpCode} quanto \textit{OpArg} possuem 8 \bis{}.

Porém, para manter essa funcionalidade, serão necessários ainda três outros componentes. O primeiro deles, o qual será responsável por gerenciar qual será a instrução lida a cada momento, será um registrador de contador de programa, chamado de \textit{regPc}. Tal registrador irá apontar para o endereço na memória de instrução que está sendo executado a cada instante. Então, quando \textit{regPc} possuir como saída o valor binário referente ao decimal zero, indicará que a primeira posição na memória de instruções está sendo lida e, por conseguinte, sendo executada pela arquitetura. 

A cada instrução executada no processador, o valor de saída do \textit{regPc} será atualizado com a soma do valor um. Assim sendo, o programa irá ser executado sequencialmente. Contudo, existe a possibilidade de serem realizados pulos, que serão apresentados na subseção \ref{a_requisitos_jump}. Esses pulos substituirão o valor de \textit{regPc} por um valor passado nos seus argumentos, redirecionando, então, para a execução de uma instrução fora de ordem.

O segundo componente responsável pela execução básica do programa é um registrador que salvará o tipo de instrução (\textit{OpCode}), contendo 8 \textit{bits}, que está sendo executado no momento. Tal registrador, chamado de \textit{regInstr}, irá receber um valor diretamente da memória de instruções e o passará diretamente para o controle, o qual será apresentado na seção \ref{projeto_control} e será responsável por tomar todas as decisões de execução necessárias. Esse valor de 8 \bis{} vem da segunda metade do endereço de 16 \bis{} contido no bloco da memória que está sendo lendo no momento. 

O último componente apresentado nesta subseção é o registrador que salvará os argumentos das instruções executadas. Esse registrador, chamado de \textit{regArg}, manterá os valores dos argumentos estáveis para que possam ser utilizados a qualquer momento durante a execução. Instruções como COMPARE\_OP e LOAD\_CONST utilizam seus argumentos em diferentes momentos. Logo, é necessário que o argumento se mantenha estável durante toda a execução de uma instrução. O \textit{regArg} receberá a outra metade do endereço vindo da \textit{memInstr}, o qual se referente aos primeiros 8 \bis{} do bloco de memória lido.

Então, os componentes básicos para que a arquitetura consiga executar códigos são uma memória de instruções, \textit{memInstr}, um registrador para o contador de programa, \textit{regPc}, e dois registradores para instruções e argumentos, \textit{regInstr} e \textit{regArg}, respectivamente. Com todos esses componentes básicos de execução, é possível que um código \textit{Assembly} seja executado por completo, realizando pulos ou executando sequencialmente. 

A Figura \ref{img_analisebasicos} apresenta os componentes apresentados nessa subseção e que são utilizados para a realização da execução básica de qualquer algoritmo no processador. Nela, é possível perceber a memória de instruções (\textit{memInstr}) que possui uma entrada, que é o valor de PC, e duas saídas, que são o valor de \textit{OpCode} e \textit{OpArg}. Além da memória, existem três registradores, considerados simples, já que possuem uma entrada de dados, uma saída de dados e uma entrada de controle, chamada de "\textit{ctrl}". Contudo, ainda existe uma outra entrada em cada um deles, a qual não foi inserida na Figura, que recebe o valor referente ao \textit{clock} do processador. Os três registradores são, então, os registradores o de contador de programa (\textit{regPc}), o de argumento (\textit{regArg}) e o de instruções (\textit{regInstr}). 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_basicos.png}
\caption{Componentes utilizados o funcionamento básico do processador.}
\label{img_analisebasicos}
\end{figure}


\subsection{Instruções de gerenciamento de dados}
\label{a_requisitos_dados}

O primeiro conjunto de instruções engloba as instruções responsáveis pelo gerenciamento de dados dentro da arquitetura. As instruções escolhidas para esta área, tal como foi dito anteriormente, foram: LOAD\_CONST, LOAD\_FAST, LOAD\_GLOBAL e STORE\_FAST.

Iniciando, então, uma análise de requisitos para essa área, percebe-se que serão necessárias, além da memória de instruções, apresentada na subseção \ref{arq_basico}, mais duas memórias. A primeira delas, e igualmente importante à segunda, será a pilha. Dentro dela, serão encontrados todos os dados que estão em uso durante a execução de um algoritmo \textit{Python}. Logo, será possível encontrar no seu interior dados como operandos de uma operação aritmética iminente, dados que estão aguardando para serem salvos na memória e dados que estão entrando no sistema como constantes e ainda não foram salvos. A pilha tem como característica possui 8 \bis{} em cada um de seus blocos, contendo 256 posições de memória, que podem ser endereçadas com também 8 \bis{}.

Como tal componente é uma pilha, pressupõe-se que os dados que entraram por último sejam os primeiros a serem lidos. Este trabalho não abordará profundamente conceitos de pilha. Tais conceitos podem ser encontrados em \cite{Aho}.

Contudo, sabendo que a saída de uma pilha deverá ser sempre o último valor que entrou, ou seja, seu topo, é necessário que exista um valor que gerencie qual o valor que está saindo a cada instante. Para isso, será necessária a utilização de um registrador de topo (posição ocupada pelo dado adicionado por último), chamado de \textit{regTos}, que estará diretamente conectado à entrada de endereços da pilha. Ele deve conter a mesma quantidade de \bis{} necessária para realizar o endereçamento da pilha, ou seja, 8 \bis{}. Sempre que for realizada uma entrada de dados, o valor presente nesse registrador deverá ser atualizado com o acrescimento de uma unidade, indicando que o topo foi modificado. Quando existir uma retirada de dados, o ponteiro deverá apontar para a posição logo abaixo do dado retirado, ou seja, dever-se-á subtrair uma unidade do valor de \textit{regTos}.

Além de uma pilha, é necessário que exista um componente que irá armazenar valores de entrada e de saída da pilha para que eles fiquem estáveis enquanto são utilizados por outros componentes ou salvos na pilha. Para tal finalidade, foi incluído o registrador de pilha, chamado de \textit{regPilha}, responsável por salvar dados que entrarão na pilha e dados que estão saindo da pilha. Esse registrador permite que os dados fiquem estáveis por tempo suficiente, permitindo que outros componentes ou a pilha realize as operações utilizando sua saída.

O \textit{regPilha} possui duas entradas e duas saídas, ambas com largura de 8 \bis{}. Na realidade, o registrador de pilha pode ser considerado a junção de dois registradores simples, porém foi definido que ele seria apenas um registrador duplo para melhor apresentação e utilização. O primeiro par de entrada e saída será utilizado para os dados que irão ser salvos na pilha, então, com um sinal de controle definido para escrita na pilha, a entrada de escrita (\textit{entrada\_write}) terá permissão para salvar seu valor na saída de escrita (\textit{saída\_write}). O dado escrito nessa saída terá como destino a entrada de escrita da pilha. 

O outro par de pinos do \textit{regPilha} é utilizado para dados que estão saindo da pilha. Então, ao ler-se um dado da pilha, é necessário salvá-lo no \textit{regPilha} utilizando a saída de operandos, nome dado à esse pino. Tal pino terá como destino final as entradas de operandos da unidade lógica aritmética (ULA), que será abordada em detalhes na subseção \ref{a_requisitos_arith}, e a entrada de escrita na memória externa, que será abordada ainda nesta subseção.

Definidos os dois componentes responsáveis pelo pleno funcionamento do componente pilha (\textit{regPilha} e \textit{regTos}), passa-se então para a memória externa. Essa memória terá o mesmo funcionamento de uma memória comum, onde os dados serão salvos em um endereço específico dentro da memória e só poderão ser acessados, posteriormente, com a utilização do mesmo endereço. Para maiores informações sobre o funcionamento básico de uma memória, recomenda-se a leitura de \cite{Stallings2002}.

A memória externa possui como característica principal, assim como a pilha, o fato de estar sempre lendo um de seus endereços. Tendo, portanto, uma saída durante todo o período de execução, exceto quando não existe nenhum dado salvo na posição apontada para o endereço. Porém, a escrita no seu interior depende de um sinal de controle específico que permitirá que exista uma escrita na próxima borda de relógio (\textit{clock}), de modo idêntico ao funcionamento da pilha. Ela possui, assim como a pilha, largura de bloco de 8 \bis{} e 256 posições, que podem ser endereçadas com os 8 \bis{} recebidos como argumento em uma instrução de gerenciamento de dados.

Contudo, juntamente com a memória, deverão existir dois componentes que manterão estáveis informações essenciais para o correto funcionamento da memória. O primeiro, chamado de registrador de endereço, \textit{regEnd}, é responsável por manter estável o endereço do bloco de memória que está sendo lido. Sua atualização é feita através da entrada do registrador de argumentos, \textit{regArg}, apresentado em detalhes na subseção \ref{a_requisitos_basicos}. O registrador \textit{regEnd} deve conter, assim como o registrador \textit{regArg}, 8 \bis{} de largura e sua funcionalidade pode ser comparada à do registrador de \tos{}, porém com atualização de seu valor sendo inteiramente feita pelo argumento recebido.

Além do \textit{regEnd}, dever-se-á existir um registrador semelhante ao \textit{regPilha}, o qual será responsável por manter estáveis dados lidos da memória e dados que serão escritos nela. Ele recebe o nome de \textit{regMemExt} e seu funcionamento é similar ao funcionamento do registrador de pilha, o qual possui dois pinos de entrada e dois de saída, divididos em pares. O par que permitirá a escrita na memória receberá dados diretamente do \textit{regPilha}. Já o par que permitirá a leitura de dados da memória passará os dados para o mesmo registrador, porém em outra entrada. O registrador de memória externa recebe o nome de \textit{regMemExt}.

A Figura \ref{img_analisedados} apresenta todos os componentes utilizados para manipulação de dados dentro do processador. Nela, aparecem os componentes pilha, memória externa (\textit{memExt}), registrador de pilha (\textit{regPilha}), registrador de endereço (\textit{regEnd}), registrador de \tos (\textit{regTos}) e o registrador de memória externa (\textit{regMemExt}). É possível ver, na imagem, todas as entradas e saídas previstas para esses componentes. É necessário destacar que aparecem os mesmos pinos de controle nos registradores \textit{regPilha} e \textit{regMemExt}, mas na realidade ambos os registradores possuem duas entradas de controle, uma para cada par. Logo, entenda-se "\textit{ctrl}" como sendo o necessário para controlar cada registrador, podendo ser mais de um pino ou um pino com largura maior.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_dados.png}
\caption{Componentes utilizados para instruções de gerenciamento de dados.}
\label{img_analisedados}
\end{figure}


\subsection{Instruções de operações aritméticas e comparações}
\label{a_requisitos_arith}

As instruções responsáveis por operações aritméticas e comparações utilizam praticamente os mesmos componentes. Porém, a grande diferença entre elas é que cada uma salva o resultado em locais diferentes. 

O componente principal desta área é a unidade lógica aritmética (ULA), que será responsável por executar as operações propriamente ditas. Contudo, para que as operações consigam chegar à ULA e seus resultados serem armazenados, são necessários outros componentes auxiliares. 

Como as instruções responsáveis por operações aritméticas da linguagem \py{} sempre são executadas com dois operandos. Por esse motivo, em seus nomes, está a palavra "\textit{binary}", que pode ser livremente traduzida para "binário", indicando uma operação entre dois elementos. Isto posto, os dois primeiros componentes, responsáveis pelas entradas dos operandos a serem operados na ULA, são os registradores de operandos, \textit{regOp1} e \textit{regOp2}. Eles possuem ligações com as duas entradas de operandos do componente. Suas finalidades são menter os valores que serão utilizados nos calculos da ULA estáveis até que o resultado seja salvo.

Isso acontece porque a unidade lógica não utiliza períodos de relógio para gerar resultados nem armazena nada em seu interior. Assim sendo, quando há uma mudança ou instabilidade na entrada da ULA, tal acontecimento reflete diretamente na sua saída. Por esse motivo, é de grande importância manter as entradas estáveis durante todo o período entre a entrada dos dados na ULA e o salvamento do resultado.

Também conectados à ULA, estão os componentes de saída. Eles somam, ao todo, três, sendo que um deles já foi apresentado na seção anterior. Começando pelo componente que já foi apresentado na subseção \ref{a_requisitos_dados}, tem-se o \textit{regPilha}, o qual é responsável por salvar o resultado de dados. Isso acontece porque o resultado da ULA em operações aritméticas é salvo diretamente na pilha. Logo, é possível aproveitar o mesmo componente para salvar diretamente na pilha, assim como ele também é aproveitado para outras funcionalidade que já foram mostradas.

O segundo componente, chamado de registrador de \textit{overflow} ou \textit{regOverflow}, é o registrador que salvará um sinal indicando se o resultado da ULA ultrapassou o número de \textit{bits} suportado pelo sistema ou não. Então, tem-se que a saída deve possuir o mesmo número de \textit{bits} que as entradas, ou seja 8 \bis{}. Porém, operações como multiplicação e soma podem gerar valores que não podem ser salvos, visto que excedem esse valor. Quando é feita uma multiplicação em valores binários, o resultado possui o tamanho de \(t1 + t2\), sendo \textit{t1} o tamanho do primeiro operando e \textit{t2} o do segundo. Logo, em uma operação de multiplicação com dois operandos de mesmo tamanho, o resultado é um valor com o dobro do tamanho. 

Contudo, caso a primeira metade do resultado possua apenas zeros, eles podem ser descartados e a saída da ULA será do mesmo tamanho das entradas. Nesse caso, o valor salvo no \textit{regOverflow} será zero, pois o valor salvo como resultado não possuiu nenhuma alteração forçada pelo número de \textit{bits}. Já quando o resultado de uma operação multiplicação, por exemplo, possuir um valor 1 presente na metade mais significativa do valor, apenas a parte menos significativa será considerada. Logo, haverá uma alteração no resultado final forçada pela quantidade de \textit{bits}. Nesse caso, considera-se que houve um excesso de valores (\textit{overflow}) e é salvo, em \textit{regOverflow}, o valor 1. 

O último componente desta classe de instruções é o registrador responsável por salvar o resultado de uma comparação, sendo ele verdadeiro ou falso. Chamado de \textit{regComp}, tal registrador tem sua escrita ativa quando há a execução da instrução COMPARE\_OP e recebe 0 ou 1, sendo esse referente à uma comparação verdadeira e aquele a uma falsa. O uso desse registrador se faz necessário visto que a pilha não possui ligações com a unidade de controle, logo, as instruções de pulos, que serão vistas na subseção \ref{a_requisitos_jump}, não poderiam ser executadas. Consequentemente, a saída desse componente precisa estar conectada ao controle.

A Figura \ref{img_analisearith} apresenta todos os componentes utilizados para a realização de operações aritméticas no processador. Os componentes nela presentes são a unidade lógica arimética (ULA), dois registradores de operandos (\textit{regOp1} e \textit{regOp2}), o registrador de comparação (\textit{regComp}) e o registrador de \textit{overflow} (\textit{regOverflow}).

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_aritmeticas.png}
\caption{Componentes utilizados para instruções que realizam operações aritméticas e comparações.}
\label{img_analisearith}
\end{figure}

\subsection{Instruções de pulos}
\label{a_requisitos_jump}

A classe de instruções responsáveis por executar pulos/desvios dentro do código \textit{Assembly} salvo na memória de instruções não necessita de nenhum componente específico para funcionar. Todas as operações realizadas por ela utilizam componentes que já foram citados nas subseções anteriores.

Então, para executar uma instrução que substitui o valor do registrador \textit{regPc} por seu argumento, tal como JUMP\_ABSOLUTE, utiliza-se a unidade lógica aritmética (ULA), que tem seu resultado diretamente ligado à entrada do registrador PC e sua entrada ligada, também, ao registrador de argumento. A seção \ref{projeto_arq} irá mostrar com mais detalhes as ligações necessárias para que se utilize os mesmos componentes para diferentes funções. Contudo, para se utilizar a ULA, precisa-se realizar uma operação lógica ou aritmética entre dois operandos. Como tem-se um valor que deverá substituir o valor de \textit{regPc}, a operação ideal a ser realizada na ULA é uma soma por zero. 

Em uma instrução onde se realiza um pulo controlado por um \textit{delta}, o qual seu valor será somado no valor de \textit{regPc} atual, utiliza-se também a ULA. Para isso, é necessário conectar a saída de \textit{regPc} à uma das entrada da ULA (que ela naturalmente já é conectada) e utilizar na outra entrada o valor que deverá ser somado ao PC, o qual virá do registrador \textit{regArg}. Após obter-se o resultado, ele é salvo em \textit{regPc} e a instrução é finalizada.

Nas instruções que necessitam de uma comparação anterior para serem executadas, utilizar-se-á o registrador de comparação. Tal registrador, ligado ao controle, o permitirá decidir se será realizada a substituição do valor de \textit{regPc} pelo valor do argumento da instrução ou não. Caso a substituição seja feita, ela ocorre exatamente como foi detalhado na explicação da instrução JUMP\_ABSOLUTE. Caso ela seja ignorada, simplesmente soma-se o valor um ao valor de PC (PC+1) atual e segue-se executando as próximas instruções. As instruções que realizam pulos conforme o resultado de uma comparação são POP\_JUMP\_IF\_TRUE e POP\_JUMP\_IF\_FALSE.

Como dito anteriormente, para a realização de desvios não é necessário incluir nenhum novo componente, já que tais instruções utilizam componentes básicos e de operações aritméticas, apresentados nas Figuras \ref{img_analisebasicos} e \ref{img_analisearith}, respectivamente. 

\subsection{Instruções de chamada e retorno de funções}
\label{a_requisitos_funcoes}

As instruções responsáveis por chamar uma função e retornar da mesma são chamadas CALL\_FUNCTION e RETURN\_VALUE, respectivamente. Elas são de extrema importância quando se precisa reutilizar um trecho de código para mais de uma finalidade. A primeira, realiza uma chamada de função, salvando o valor de PC atual, incrementado em um, e realizando um desvio incondicional. Nela, ainda é preciso salvar o valor do ponteiro de \tos{} atual, visto que a chamada de uma função adiciona um bloco de dados na pilha, sendo necessário excluí-lo no retorno. Já a segunda obtém os valores salvos pela primeira, guarda o valor do topo atual da pilha. Após, retorna o valor de \textit{regPc} para PC+1, salvo anteriormente, e de \textit{regTos} para TOS+1. Após o retorno, o valor salvo do \tos{} da pilha, que era o \tos{} da função, é salvo no topo da pilha retornada.

Para melhor entendimento, pode-se utilizar um exemplo simples. A Figura \ref{img_analise_exemplo_funcoes} apresenta três pilhas listadas com suas letras. Em (a), pode-se perceber que existe um valor na primeira (e única) posição da pilha ocupada. Após, em (b), é chamada uma função que realiza uma operação entre os três valores carregados posteriormente, já dentro da função. No \tos{}, obtém-se um valor que é considerado o resultado da função. Quando a função é encerrada com a instrução RETURN\_VALUE, o valor presente no \tos{} é salvo, o bloco da função é excluído e esse mesmo valor retorna como sendo o valor o novo \tos{}. A pilha final, após a chamada e o retorno da função, pode ser vista na pilha (c). 

Vale lembrar que os valores não são fisicamente excluídos da pilha, somente são ignorados, pois para a arquitetura, os únicos valores que importam são os que estão abaixo do ponteiro que aponta para o \tos{}. Na Figura \ref{img_analise_exemplo_funcoes} os espaços aparecem em branco para melhor entendimento, mas na realidade o valores estão fisicamente lá, e só serão substituído quando forem feitas novas escritas em suas posições.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_exemplo_funcoes.png}
\caption{Exemplo de comportamento de uma pilha ao ser manipulada por funções.}
\label{img_analise_exemplo_funcoes}
\end{figure}

Então, para realizar todas essas operações, são necessários novos componentes na arquitetura. Necessita-se salvar os valores de \textit{regPc} e de \textit{regTos} antigos, logo, a ideia inicial seria utilizar um registrador. Porém, como uma linguagem como \py{} permite que sejam chamadas inúmeras funções, umas dentro das outras, um registrador somente conseguiria retornar para a função imediatamente anterior à chamada atual. 

Assim, fá-se necessário o uso de uma pilha, que conseguiria guardar na ordem correta todos os valores de retornos. Assim, foram adicionadas, como mostra a Figura \ref{img_analise_funcoes}, as pilhas de função (\textit{pilhaFuncao}) e retorno de TOS (\textit{pilhaTosRetorno}), que guardam \textit{regPc} e \textit{regTos}, respectivamente.

Como toda pilha, ela tem seu próprio indicador de topo. Logo, necessita um registrador para salvar esse indicador. Então, adiciona-se um registrador chamado \textit{regTosFuncao}. Ele indicará o topo das duas pilhas que foram adicionadas, visto que elas trabalham juntas e devem estar na mesma posição sempre para que estejam sincronizadas.

Para atualizar o indicador de \tos{} principal, que gerencia a pilha principal, utiliza-se a unidade lógica aritmética. Porém, como ela já é utilizada para diversos fins diferentes, optou-se por adicionar um somador/subtrator, que terá como única função atualizar o valor do registrador \textit{regTosFuncao}, incrementando-o ou decrementando-o conforme a unidade de controle indicar.

Como dito, a Figura \ref{img_analise_funcoes} apresenta todos os componentes necessários para o correto funcionamento das instruções CALL\_FUNCTION e RETURN\_VALUE. Nela, são apresentados os pinos de entradas e saídas de cada componente, assim como seus nomes abaixo.  

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/analise_funcoes.png}
\caption{Componentes utilizados para instruções que permite chamada e retorno de funções.}
\label{img_analise_funcoes}
\end{figure}

\section{Projeto da arquitetura}
\label{projeto_arq}

Após realizar uma analise de todos os componentes necessários para que todas as classes de instruções escolhidas sejam executados, é preciso fazer um projeto de arquitetura que consiga conectar todos eles de forma eficiente. Porém, não só eficiência é necessário, mas também economia de componentes, adicionando o mínimo de componentes possível e reutilizando o que puder ser reutilizado. 

Essa seção, então, apresentará como foi realizado o projeto da arquitetura, visando a correta execução de todas as instruções aqui apresentadas. Para melhor entendimento, ela foi dividida em tópicos seguindo o mesmo padrão da seção \ref{a_requisitos}, sendo que cada um tratará de uma classe de instruções específica. Ao final, é possível encontrar uma subseção responsável por definir quais componentes serão reaproveitados, apresentando a adição de multiplexadores em cada parte da arquitetura.

Assim, seguindo a mesma ordem da seção \ref{a_requisitos}, a primeira subseção sobre projeto, subseção número \ref{pArq_basicos}, abordará sobre os conceitos de funcionamento básico da arquitetura. Logo após, poderão ser encontradas as subseções de gerenciamento de dados, operações aritméticas e comparações, e pulos, com números \ref{pArq_dados}, \ref{pArq_arith} e \ref{pArq_pulos}, respectivamente. Finalizando esta seção, está a subseção \ref{pArq_geral}, o projeto de reutilização de componentes visando obter a menor área de ocupação possível para a arquitetura. 

\subsection{Conceitos Básicos}
\label{pArq_basicos}

Como dito na subseção \ref{a_requisitos_basicos}, os componentes aqui presentes e apresentados terão como propósito a execução básica de um algoritmo, executando a movimentação entre as instruções e leitura das mesmas. Essa arquitetura parcial dispõe dos registradores de contador de programa (\textit{regPc}), de instrução (\textit{regInstr}) e de argumento (\textit{regArg}), juntamente com uma memória de instruções. 

Na Figura \ref{img_analisebasicos}, lá na subseção \ref{a_requisitos_basicos}, pode-se observar que a memória de instruções possui uma entrada e duas saídas. Começando então por ela, o componente mais importante desta arquitetura parcial, pode-se perceber que a sua entrada é um endereço de memória. Como a memória de instruções tem como característica estar sempre lendo e escrevendo em sua saída, o endereço que chega nela deve estar sempre estável e, para isso, existe o \textit{regPc}. Então, a entrada da memória de instruções deverá ser ligada ao registrador capaz de salvar o endereço de memória da instrução lida a cada instante. 

Assim, faz-se a primeira conexão, que será a entrada da memória de instruções com a saída do registrador PC (\textit{regPc}), como poderá ser visto na Figura \ref{img_pArq_basicos}. Porém, a figura só será apresentada e explicada detalhadamente ao final desta subseção. 

Então, o \textit{regPc} é o registrador responsável por indicar a posição da memória de instrução que deverá ser lida. Como a cada instrução lida deve-se incrementar o registrador PC em 1 (caso não seja uma instrução de pulo, que será abordada na subseção \ref{pArq_pulos}), então a entrada do registrador PC deverá estar ligada à saída da unidade lógica aritmética, assim como a saída de \textit{regPc}, que também deverá estar ligada em uma das entradas da ULA. Como poderá ser visto na subseção \ref{pArq_arith}, a ULA deverá ter diversas entradas diferentes dependendo do que está sendo executado, então dever-se-á adicionar um multiplexador.

Um multiplexador, chamado também de \textit{mux}, é um componente de seleção, capaz de receber diversas entradas e selecionar uma delas para sair em sua única saída. A insersão de multiplexadores na arquitetura será apresentada em detalhes na subseção \ref{pArq_geral}. Por ora, basta saber que a entrada de \textit{regPc} é um resultado vindo de uma operação na unidade lógica aritmética e sua saída está ligada à memória de instruções e à ULA.

Até agora, portanto, definiu-se que a entrada de \textit{regPc} é ligada à saída da ULA e sua saída é ligada à entrada da ULA e à entrada da memória de instruções. Falta, então, conectar os dois registradores remanescentes. Para entender o funcionamento desses registradores, é preciso entender que cada bloco de memória presente na memória de instrução possui 16 \textit{bits}. Assim, ao ler o bloco que \textit{regPc} está apontando, quebra-se ele em dois valores de 8 \textit{bits} e os encaminha para cada uma das saídas da memória de instrução. Como apresentados na seção \ref{rf_modos_enderecamento}, os primeiros 8 \textit{bits} são identificados como o argumento da instrução e, portanto, são enviados para o registrador de argumento (\textit{regArg}). Já os 8 \textit{bits} finais são o código identificador de instrução (que mostram qual instrução deve ser executada) e são enviados para o registrador de instrução (\textit{regInstr}). 

Tendo as entradas dos registradores de argumento e instrução, falta ainda conectar suas saídas. O primeiro registrador tem sua saída ligada a uma das entradas do controle, ao registrador de endereço e ao multiplexador do registrador de pilha (mostrados na subseção \ref{pArq_dados}). O motivo pelo qual sua saída está ligada ao controle é a instrução de comparação, que tem seu tipo de comparação definido como argumento. Sendo assim, o controle precisa saber qual é a comparação que deve ser executada para que consiga selecionar a operação correta na ULA. Já o motivo para a saída de \textit{regArg} está ligada ao multiplexador do registrador de pilha é a instrução de carregamento de constante (LOAD\_CONST), que deve salvar o valor do argumento diretamente na pilha. Enquanto isso, os motivos para a mesma saída estar ligada ao registrador de endereço são as instruções de carregamento e salvamento na memória externa (LOAD\_FAST e STORE\_FAST), que salvam e carregam diretamente de um endereço da memória, especificado por argumento.

A Figura \ref{img_pArq_basicos}, como dito anteriormente, apresenta as ligações mensionadas acima. Na esquerda, é possível encontrar o registrador PC (\textit{regPc}), ligado à entrada da memória de instruções (\textit{memInstr}). Já à direita, encontram-se os dois registradores, argumento (\textit{regArg}) e instrução (\textit{regArg}), ligados às duas saídas da memória de instruções.  

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_basicos.png}
\caption{Arquitetura parcial responsável pela funcionalidade básica.}
\label{img_pArq_basicos}
\end{figure}

\subsection{Gerenciamento de Dados}
\label{pArq_dados}

Falando, então, sobre a arquitetura parcial responsável pelas instruções de gerenciamento de dados, realizar-se-á a conexão dos componentes apresentados na subseção \ref{a_requisitos_dados}. Tais componentes são: uma pilha, uma memória externa (\textit{memExt}), um registrador de pilha (\textit{regPilha}), um registrador de memória externa (\textit{regMemExt}), um registrador de \tos (\textit{regTos}) e, por último, um registrador de endereço (\textit{regEnd}). 

Partindo então do registrador de pilha (\textit{regPilha}), pode-se perceber, através da Figura \ref{img_analisedados}, apresentada na subseção \ref{a_requisitos_dados}, que ele possui duas entradas e duas saídas. Tal registrador poderia ser dividido em dois registradores diferentes: o primeiro responsável por escrita na pilha e o segundo responsável por leitura da pilha. Porém, não foi realizada essa divisão visando economizar em um componente e permitindo que a arquitetura ficasse mais limpa quando fosse desenhada. 

As primeiras entrada e saída do \textit{regPilha} que serão abordadas são as responsável por operações de escritas na pilha. Denominadas "\textit{entradaWrite}" e "\textit{saídaWrite}", elas possuem conexão direta entre elas. A entrada é conectada ao multiplexador que gerencia suas entradas, o qual será comentado na subseção \ref{pArq_geral}. Já a saída está conectada diretamente na entrada de escrita da pilha, denominada, também, "\textit{entradaWrite}".

O segundo par de entrada e saída é o de leitura da pilha. O pino de entrada, denominado "\textit{entradaDados}", está conectado ao pino de saída de leitura da pilha, chamado de "\textit{saidaRead}". Já o pino de saída está conectado aos dois operandos da ULA e ao registrador de memória externa. Além dos dois pares de pinos deste registrador, ainda existe mais um pino, apelidado de "\textit{ctrl}" e com nome formal sendo "controle". Este pino se divide em dois pinos de entrada de controle, cada um para controlar um par de entrada e saída, e ambos são conectados em saídas diferentes da unidade de controle. Os sinais recebidos do controle servirão para habilitar ou desabilitar a escrita nos pinos de saída de ambos os pares. 

Passando para o próximo componente, tem-se a pilha, que já teve um par de entrada e saída conectado ao \textit{regPilha} e, agora, falta só o último pino. Tal pino está conectado à saída do registrador de topo, \textit{regTos}, e é responsável por indicar qual posição da pilha está sendo lida. Sempre que é feita uma operação de escrita ou leitura da pilha, o valor deste registrador, através da ULA, é atualizado e sempre guardará a posição que está sendo lida na saída de leitura da pilha, ou seja, o \tos{}. 

Além dos três pinos aqui citados, existe um quarto pino, o qual não está presente na Figura \ref{a_requisitos_dados}, mas é necessário. Este pino é o de controle de escrita. Uma memória que possui dois pinos (entrada e saída) pode ter a propriedade de estar sempre lendo, mas precisa de um comando para saber quando deve salvar determinado valor. Então, no pino de saída da pilha, sempre existe um valor (o qual está na posição apontada pelo valor de \textit{regTos}). Já o valor presente no pino de entrada da pilha só será aproveitado caso o sinal de controle da pilha esteja ativo. Caso contrário, o valor é ignorado. 

O próximo trio de componentes (memória externa, registrador de memória externa e registrador de endereço) possui seu funcionamento parecido com o que já foi apresentado para a pilha. A memória externa tem seu funcionamento similar ao da pilha, equanto o registrador de memória externa possui funcionamento idêntico ao registrador de pilha. A grande diferença, e o que define que o primeiro trio possui uma pilha o segundo não, é o registrador de endereço. A função é a mesma do registrador \textit{regTos} (apontar a posição de memória lida), porém, ao invés de ter seu valor atualizado a cada operação de escrita ou leitura, sua saída é atualizada conforme o valor do registrador de argumento. Isso faz com que uma posição de memória especifica possa ler lida a qualquer momento, sem a necessidade de executar leituras sucessivas para conseguir acessar um dado que foi carregado no inicio da execução, como é o caso de uma pilha, que sempre lê o último dado carregado. 

A Figura \ref{img_pArq_dados} apresenta todas as conexões citadas acima. Nela, pode-se observar os seis componentes conectados entre si. Porém, como já foi dito, é possível observar somente uma entrada de controle (\textit{ctrl}) nos registradores de memória externa e pilha, porém divide-se essa entrada em duas. O motivo de estar aparecendo somente um pino foi para evitar que a imagem ficasse sobrecarregada de informações.  

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_dados.png}
\caption{Arquitetura parcial responsável pela execução de instruções de gerenciamento de dados.}
\label{img_pArq_dados}
\end{figure}

\subsection{Operações Aritméticas e Comparações}
\label{pArq_arith}

A arquitetura parcial responsável por realizar operações aritméticas e comparações, como dito na subseção \ref{a_requisitos_arith}, possui cinco componentes básicos: uma unidade lógica aritmética (ULA), dois registradores de operandos (\textit{regOp1} e \textit{regOp2}), um registrador de comparação (\textit{regComp}) e um registrador de \textit{overflow} (\textit{regOverflow}). Todos os componentes são conectados entre si, mas possuem suas entradas, como no caso dos operandos, e saídas, como é o caso dos registradores de \textit{overflow} e comparação, para fora da arquitetura parcial.

Iniciando-se uma análise sobre os dois registradores de operandos, definiu-se que ambos possuem suas entradas conectadas à saída de leitura do registrador de pilha, que foi explicado na subseção \ref{pArq_dados}. O registrador de pilha, então, lerá cada um dos operandos da pilha e os salvará, em instantes diferentes (lê um e o salva, após lê o outro e o salva), em cada um dos registradores de operandos. O primeiro que receberá o operando, conforme apresentado na subseção \ref{a_algo_sim}, é o registrador operando 1 (\textit{regOp1}), que será o segundo operando da operação, conforme equação \ref{eq_pArq_arith}. O segundo a receber seu valor é o \textit{regOp2}, que será o primeiro operando da ULA.

\begin{equation}
\label{eq_pArq_arith}
	RESULTADO = OP2 - OP1
\end{equation}

Ambos os registradores estão conectados às entradas de operandos da ULA, a qual é responsável pela execução das operações aritméticas e comparações. Para definir o tipo de operação a ser realizada, é utilizado um seletor, vindo da unidade de controle, que entrará através do pino denominado "\textit{entradaSeletor}". Esse seletor possui 3 \textit{bits} e pode escolher uma entre as quatro operações aritméticas previstas para serem implementadas nesse trabalho (soma, subtração, multiplicação e divisão), assim como uma das três comparações possíveis (igual, menor que e maior que). Sendo assim, existe uma posição de operação vazia, pois o mesmo seletor poderia selecionar entre oito diferentes tipos de operações.

Ainda na ULA, existem três saídas, as quais são responsáveis por distribuir os resultados das operações para componentes externos a ela. As duas primeiras, as quais seus registradores, estão presentes nesta arquitetura parcial. São elas a de comparação e a de \textit{overflow}. A primeira, conectada no \textit{regComp}, define se determinada operação de comparação é verdadeira ou falsa, salvando 0 ou 1 no registrador de comparação, que por sua vez terá sua saída conectada ao controle. 

Já a saída de \textit{overflow}, conectada ao \textit{regOverflow}, é utilizada apenas em operações de multiplicação e adição. Como operações de multiplicação possuem a quantidade de \textit{bits} do resultado definida como a soma o número de \textit{bits} dos dois operandos. Logo, espera-se que o resultado tenha 16 \textit{bits}, pois cada um dos operandos possui 8 \bis{}. No caso de uma soma, é possível que o \bi{} mais significativo apresente valor 1 e receba uma soma de um, o qual resultaria de um valor 10. Caso isso aconteça, será necessário adicionar o valor 1 mais à esquerda do antigo \bi{} mais significativo, tornando o resultado 1 \bi{} maior do que os operandos.

Contudo, só serão aproveitados os 8 \textit{bits} à direita. Assim, sempre que existir um \textit{bit} com valor 1 entre os 8 \textit{bits} à esquerda de um código de 16 \bis{}, o registrador de \textit{overflow} salvará o valor 1, indicando que houve \textit{overflow} e que o resultado da ULA pode estar comprometido e pode não expressar o resultado real, já que na saída resultado somente sairão os 8 \bis{} à direita. O \textit{regOverflow}, assim como o \textit{regComp}, é conectado a uma entrada da unidade de controle, permitindo que esse saiba se houve ou não \textit{overflow}. 

Por último, tem-se a saída de resultado normal, utilizada para todas as operações aritméticas. Nas comparações, essa saída sempre sairá zerada. Ela é conectada diretamente ao registrador PC (\textit{regPc}), ao registrador de \tos (\textit{regTos}) e ao registrador de pilha (\textit{regPilha}).

A Figura \ref{img_pArq_arith} apresenta um esboço da arquitetura parcial responsável pela execução das instruções aritméticas e comparação. Nela, podem ser vistos os cinco componentes conectados entre si e pinos de entrada e saída deles que são conectados a componentes externos a essa arquitetura. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_aritmeticas.png}
\caption{Arquitetura parcial responsável pela execução de instruções de operações aritméticas e comparação.}
\label{img_pArq_arith}
\end{figure}

\subsection{Instruções de Pulos/Desvios}
\label{pArq_pulos}

A próxima arquitetura parcial, responsável pela realização de pulos (ou desvios), possui o primeiro multiplexador (\textit{mux}) apresentado, até o momento, nessa arquitetura. Diferentemente das outras classes de instruções, onde foi possível apresentar a arquitetura parcial retirando-se os multiplexadores, nessa eles são necessários como sendo componente básico dela. Nas outras, adicionar multiplexadores apenas permite que o mesmo componente seja utilizado por diferentes classes de instruções, gerando entradas vindas de diversos componentes e com destino no mesmo. A adição de todos os outros multiplexadores será feita na subseção \ref{pArq_geral}.

Então, como pode ser visto na Figura \ref{img_pArq_pulos}, a arquitetura que realiza pulos contém três componentes principais (sem contar o multiplexador). Ela consegue atender às quatro instruções de desvios apresentadas neste trabalho, POP\_JUMP\_IF\_FALSE, POP\_JUMP\_IF\_TRUE, JUMP\_ABSOLUTE e JUMP\_FORWARD. Nas duas primeiras, existe uma comparação que acontece antes de ser iniciado um pulo, porém ela não é apresentada aqui pois é uma operação que depende da arquitetura parcial apresentada em \ref{pArq_arith} e do controle, que será apresentado na seção \ref{projeto_control}.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_pulos.png}
\caption{Arquitetura parcial responsável pela execução de pulos.}
\label{img_pArq_pulos}
\end{figure}

Tem-se então, para essa classe de instruções, os componentes: unidade lógica aritmética (ULA), registrador de argumento (\textit{regArg}) e registrador contador de programa (\textit{regPc}). A utilização de uma ULA para realizar os desvios foi definida para ser aproveitada a operação básica de adição ao valor de PC, que faz com o que seja executada a próxima operação de um programa. Então, partindo desse princípio, definir que a saída de \textit{regPc} e a entrada dele estão conectadas aos pinos de entrada e saída da ULA, respectivamente, evita que seja necessário adicionadar outro componente para armazenar o valor de \textit{regPc} antigo enquanto ele é atualizado.

Então, analisando a execução das instruções POP\_JUMP\_IF\_, em que as duas possuem o mesmo funcionamento, porém em circunstâncias contrárias, tem-se que o valor de saída de \textit{regPc} será ignorado, passando pelo \textit{MUX} apenas a opção zero, vinda de \textit{regArg}. Como esse tipo de instrução executa um pulo para um endereço passado por argumento diretamente para PC, a operação ocorrida na ULA é uma operação de adição do valor zero ao valor que entrou como argumento. Assim, a saída de resultado da ULA é o mesmo valor que veio de \textit{regArg} e que será salvo no registrador PC.

Assim como as duas instruções já analisadas, a instrução JUMP\_ABSOLUTE, que executa um desvio incondicional para um endereço passado por argumento, possui o mesmo funcionamento. A única diferença dela para as duas instruções POP\_JUMP\_IF\_ é que ela não necessita de uma comparação feita pelo controle antes de ser executada. Portanto, pode-se considerar que ela realiza um desvio incondicional.

A última instrução de pulo, JUMP\_FORWARD, justifica o fato de \textit{regArg} estar ligado ao MUX da entrada de operando 2 e também à entrada de operando 1. Ela executa um pulo baseado na adição de um valor, passado por argumento, no valor atual de PC. Assim, passa-se através do MUX a opção 1, chegando à entrada de operando 2 o valor de \textit{regPc}. À entrada de operando 1, chega o valor de \textit{regArg} e, então, executa-se uma soma entre os dois valores. O resultado é salvo no registrador PC e finaliza-se a execução. 

\subsection{Instruções de chamada e retorno de funções}
\label{pArq_funcoes}

Por fim, tem-se a arquitetura parcial responsável pela chamada e retorno de funções. Para que ela funcione corretamente, é preciso que existam duas pilhas. A primeira, responsável por salvar o endereço da próxima instrução a ser executada após o retorno. Já a segunda, responsável por guardar o endereço do \tos{} da pilha principal para que o bloco alocado para a função seja completamente ignorado após o retorno e os dados chamados anteriormente voltem a ser válidos.

Então, como mostra a Figura \ref{img_pArq_funcoes}, pode-se observar que as duas pilhas citadas acima, pilha de função (chamada "pilhaFuncao" e responsável por guardar o valor de PC+1) e pilha de TOS (chamada "pilhaTosRetorno" e responsável por guardar o \tos{} principal antes da chamada da função) tem suas saídas conectadas ao registrador PC e ao registrador TOS, respectivamente. Assim, quando a instrução RETURN\_VALUE for chamada, os valores presentes nos topos dessas pilhas serão alocados nos registradores a qual estão conectadas.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/projeto_funcoes.png}
\caption{Arquitetura parcial responsável pela chamada e retorno de funções.}
\label{img_pArq_funcoes}
\end{figure}

Assim como toda pilha, pode-se perceber que as duas pilhas estão ligadas ao mesmo registrador responsável por guardar seus próprios topos, chamado de \textit{regTosFuncao}. Isso se deve ao fato de que elas possuem o mesmo valor endereçando seus topoo e sempre que for adicionado um novo dado em uma delas, será adicionado um dado equivalente na outra também. Assim, não há necessidade de existirem dois registradores de topo, visto que eles deveriam ser atualizados separadamente e isso custaria tempo de execução. Além do registrador de \tos{} adicionado para essa funcionalidade, foi adicionado um somador/subtrator, que é o responsável por manipular esse registrador. O motivo da adição do novo registrador é evitar que a unidade lógica aritmética (ULA) fique sobre carregada, fazendo com que seja necessário adicionar um multiplexador maior em uma de suas entradas, e paralisada para realizar apenas essa operação, não podendo executar essa operação e outra ao mesmo tempo. Com o somador/subtrator, a ULA não precisa parar e executar somente essa operação, pode seguir executando paralelamente o que for necessário, como uma soma PC+1 que salvará no topo da \textit{pilhaFuncao}. 

Fora esses componentes, ligado ao registrador da pilha principal, está o registrador de retorno de dados (chamado de "\textit{regDataReturn}"). Sua entrada vem diretamente da saída de leitura da ULA, pois ele guarda um dado que está no \tos{} e, consequentemente, no topo de um bloco alocado para a função inicializada por CALL\_FUNCTION. Esse valor é retornado para a função principal e, portanto, precisa ser armazenado, após ocorrer o retorno para a função principal, no topo de pilha. Tendo em vista essa funcionalidade, esse registrador recebe o valor no topo da pilha antes de ser realizada a atualização do \textit{regTos} e, após a atualização desse registrador, é adicionado no \tos{} atual o valor salvo no registrador.

\subsection{Arquitetura Geral}
\label{pArq_geral}

Então, após analisar todas as classes de instruções e suas arquiteturas parciais capazes de execulá-las, percebe-se que alguns dos componentes se repetem em mais de uma arquitetura. Essa repetição gera entradas diferentes para o mesmo componente, sendo necessário, portanto, utilizar um multiplexador.

Um multiplexador (\mux{}) nada mais é do que um componente capaz de escolher, baseado em um sinal de controle, qual de suas entradas será reproduzida no pino de saída. Então, um multiplexador é capaz de possuir inúmeras entradas, sendo que o número de \bis{} que o sinal de controle deverá ter depende exatamente do número de entradas que o \mux{} possui. A Equação \ref{eq_nBits_seletor} mostra a fórmula que define o número de \bis{} que um seletor (como é chamado o sinal de controle que gerencia o multiplexador) deve possuir baseado no seu número de entradas.

\begin{equation}
\label{eq_nBits_seletor}
n\_bits = \log_{2}{(n\_entradas)}
\end{equation}

A Figura \ref{img_muxes} apresenta o formato de um componente multiplexador, que já pôde ser visto na Figura \ref{img_pArq_pulos}, porém foi apresentado em detalhes. O componente posicionado à esquerda, (a), é um \mux{} que possui duas entrada e, portanto, apenas um \bi{} em seu seletor. Já o componente à direita, (b), é um \mux{} que possui 4 entradas e, portanto, um seletor de dois \bis{}. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/muxes.png}
\caption{Exemplos de multiplexadores.}
\label{img_muxes}
\end{figure}

Utilizando esse componente, portanto, é possível utilizar melhor componentes que apareceram em mais de uma arquitetura, sendo o destino da saída de diversos componentes. Começando, então, com o registrador de pilha (\textit{regPilha}), que recebe conexões vindas da ULA, do registrador da memória externa (\textit{regMemExt}), do registrador de argumento (\textit{regArg}) e do registrador de retorno de dados (\textit{regDataReturn}). 


À entrada do \textit{regPilha}, foi necessário adicionar um multiplexador com dois \bis{} de sinal de controle, permitindo, portanto, quatro entradas. A Figura \ref{img_pArq_muxPilha} apresenta como é a entrada do registrador de pilha e quais os componentes que se conectam ao seu \textit{mux}. As entradas em que cada componente se conecta é a que eles realmente estão conectados na implementação final e são as que o controle irá enviar sinal para que saiam no pino à esquerda, que será apresentado na seção \ref{projeto_control}.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/muxPilha.png}
\caption{Apresentação do multiplexador posicionado na entrada do registrador de pilha.}
\label{img_pArq_muxPilha}
\end{figure}

É possível perceber, através da análise da imagem, que na entrada "00" do multiplexador é conectada à saída da ULA. Já às entradas "01", "11" e "10", respectivamente, estão conectados os registradores de memória externa, argumento e dado de retorno, respectivamente. Ainda é possível perceber que alguns dos pinos foram cortados na imagem para que os componentes pudessem ser encaixados sem desperdício de espaço, porém o nome dos seus sinais/entradas se mantiveram. 

A tabela \ref{table_muxPilha} apresenta, baseada na Figura \ref{img_pArq_muxPilha}, o mapeamento das entradas do multiplexador conectado à entrada do registrador de pilha. Nela, é possível ver o valor, à esquerda, referente ao sinal de controle que será recebido e, à direita, o nome do componente que será repassado na saída.

\input{tables/table_muxPilha}

Passando, então, para a próxima análise de adição de multiplexadores, tem-se a adição de três multiplexadores às entradas do mesmo componente, a unidade lógica aritmética. O primeiro multiplexador, apresentado também na Figura \ref{img_pArq_pulos}, não estava completo nessa Figura, pois somente era necessário, naquele momento, entender como funcionava a arquitetura parcial responsável pela execução de pulos, que necessitava de um \mux{} de duas entradas apenas. Agora, na Figura \ref{img_pArq_muxesUla}, o mesmo multiplexador aparece maior e completo completo, recebendo todos os componentes necessários para seu funcionamento. A ele, dar-se-á o nome de \textit{muxOp2}. Falar-se-á dele na sequência, após os dois primeiros registradores, para que a ordem seja seguida.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/muxesUla.png}
\caption{Apresentação dos três multiplexadores que compõem as duas entradas da ULA.}
\label{img_pArq_muxesUla}
\end{figure}

Analisando a Figura \ref{img_pArq_muxesUla}, percebe-se que o primeiro multiplexador, o qual recebe o nome de \textit{muxOp1}, recebe conexão de outro multiplexador e possui alguns valores de entrada constantes. Tais valores são zero (utilizado para somar zero durante um JUMP\_ABSOLUTE) e um (utilizado para atualizar o valor de PC e atualizar o valor do registrador de \tos{}). À entrada "11", conecta-se o \mux{} visto na sequência. Já a entrada "10", até o momento, não possui nenhuma conexão. Na tabela \ref{table_muxOp1} podem ser vistas todas as ligações do \textit{muxOp1}, juntamente com seus valores de controle.

\input{tables/table_muxOp1}

Passando para o multiplexador \textit{muxRegOp1}, que é responsável por definir se chegará o valor de \textit{regArg} ou \textit{regOp1} no \textit{muxOp1}. Quando necessita-se realizar um JUMP\_FORWARD, o valor passado por ele é o de \textit{regArg}, pois será necessário somá-lo ao valor de PC, que entrará como segundo operando da ULA. Já quando precisa-se realizar uma operação aritmética ou comparação, passa-se \textit{regOp1}. Esse multiplexador possui apenas um \bi{} em seu seletor, visto que só possui duas entradas. Na tabela subsequente, de número \ref{table_muxRegOp1}, pode ser visto o mapeamento das entradas e valores de seletor para o multiplexador \textit{muxRegOp1}.

\input{tables/table_muxRegOp1}

E, como último \mux{} da Figura \ref{img_pArq_muxesUla} e também já comentado anteriormente, tem-se o multiplexador \textit{muxOp2}, o qual é responsável por selecionar qual valor chegará à entrada de operando 2 da ULA. Suas entradas são conectadas aos registradores \textit{regArg} (utilizado para todos os desvios, exceto JUMP\_FORWARD), \textit{regTos} (utilizado para atualizar o valor de \tos{}, \textit{regPc} (utilizado para a atualização do registrador contador de programa) e \textit{regOp2} (utilizado para operações aritméticas e comparações). Na tabela \ref{table_muxOp2} podem ser vistos os componentes conectados a cada entrada do \textit{muxOp2}, juntamente com seus valores de controle.

\input{tables/table_muxOp2}

Além dos multiplexadores já adicionados, foram adicionados mais dois \textit{muxes} para permitir que existam chamadas e retornos de funções. O primeiro deles, conforme mostra a Figura \ref{img_pArq_muxPc}, tem sua saída ligada à entrada do registrador PC. Ele é um \mux{} com 1 \bi{} de controle e, portanto, duas entradas. A primeira delas, endereçada com o \bi{} "0", está ligada à saída da ULA. Já a segunda, "1", está ligada à saída da pilha de funções (chamada "pilhaFuncoes").


\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/muxPc.png}
\caption{Apresentação do multiplexador responsável pela entrada do registrador PC.}
\label{img_pArq_muxPc}
\end{figure}

A tabela \ref{table_muxPc} apresenta as conexões de entrada no multiplexador responsável por definir a entrada do registrador PC.

\input{tables/table_muxPc}

O segundo \mux{}, o qual pode ser observado na Figura \ref{img_pArq_muxTos}, tem sua saída conectada ao registrador \textit{regTos}. Ele também possui um sinal de controle endereçado com 1 \bi{}. Suas entradas são, respectivamente, a saída da ULA e a saída da pilha de retorno de topo em suas entradas "0" e "1". 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{images/muxTos.png}
\caption{Apresentação do multiplexador responsável pela entrada do registrador TOS.}
\label{img_pArq_muxTos}
\end{figure}

Na tabela \ref{table_muxTos} pode ser observado o mapeamento das entradas e sinais do seletor do \mux{} ligado ao registrador TOS.

\input{tables/table_muxTos}

Esses dois últimos multiplexadores são necessários para que seja possível escolher entre fazer um retorno, com a instrução RETURN\_VALUE, e fazer uma atualização normal dos valores dos registradores PC e TOS, com a saída da unidade lógica aritmética. 

Uma visualização completa da arquitetura, contendo todas as arquiteturas parciais conectadas, pode ser encontrada no apêndice \ref{apendice_arq}. Criado através da ferramenta \textit{Logisim}, o esboço da arquitetura apresenta todos os componentes conectados, gerando apenas uma arquitetura final. É possível observar, também, a presença de todas as arquiteturas parciais e todos os componentes apresentandos. Além disso, existem componentes, tais como \textit{regInstr} e \textit{regArq}, que possuem saídas que não são conectadas a nada. Esses pinos de saída representam, então, uma conexão com a unidade de controle, a qual não está presente na imagem mas se conecta a todos os componentes.

\section{Projeto do controle}
\label{projeto_control}

A unidade de controle de uma arquitetura funciona como seu cérebro. Ela define os sinais para todos os componentes que precisam deles, para que eles funcionem de forma sincronizada e realizem corretamente as operações a eles destinadas, permitindo um correto funcionamento da arquitetura como um todo.

É função da unidade de controle reconhecer qual instrução que está sendo executada, através da leitura do código de instrução (\textit{OpCode}), recebido através endereço vindo da memória de instruções e salvo no registrador de instrução (\textit{regInstr}). Com esse código, o controle sabe exatamente qual será a instrução a ser executada e prepara seus componentes, a cada estado de execução, para que consiga realizar a execução exatamente como esperado.

Cabe ao controle, também, a análise de resultados, como a leitura do registrador de comparação ("\textit{regComp}") e a decisão se um desvio irá ocorrer ou não. Assim como a análise do argumento (contido no registrador \textit{regArg}) durante a execução da instrução COMPARE\_OP, para que o sinal de controle da unidade lógica aritmética seja escolhido corretamente.

Portanto, cabe ao controle definir como cada componente se comportará a cada instante durante a execução. Mas, para que ele funcione corretamente, são definidas máquinas de estados, as quais possuem como saída os sinais de cada componente presente na arquitetura que necessite deles. A subseção \ref{control_sinais} apresentará todos os sinais de controle presentes na arquitetura proposta, assim como o significado de cada um deles.

Mas, para que o sinais sejam corretamente selecionados no instante de tempo certo, é preciso que haja uma máquina de estados contendo todos os sinais e as ocasiões em que eles deverão ser passados para os componentes. As subseções \ref{control_meExp} e \ref{control_projMe} apresentarão, respectivamente, o funcionamento de uma máquina virtual e uma explicação as máquinas de estados projetadas para essa arquitetura, juntamente com suas imagens.  

\subsection{Sinais de controle}
\label{control_sinais}

A seção \ref{a_requisitos} apresentou todos os componentes que são necessários para que todas as funcionalidades previstas para o processador \py{} sejam atendidas corretamente. Cada um deles, como as imagens mostram, possuem um pino de entrada chamado controle (\textit{ctrl}) ou seletor (chamado também de \textit{sel}). Nas figuras apresentadas, aparecem os nomes abreveados, visando economia de espaço.

Esse módulo nada mais é do que um componente, o qual contém uma máquina de estados implementada, contendo uma lista de saídas que se conectarão a cada um dos componentes presentes na arquitetura. Além disso, ainda existem algumas entradas no componente, responsáveis por permitir que o controle faça escolhas durante a execução. Como o controle é um componente e não um tipo de sistema mestre que tem acesso a tudo sem se conectar a nada, é necessário que os dados que precisem ser analisados por ele sejam suas entradas. Então, por ele, somente poderão ser analisados dados que chegam até ele.

Cada um dos registradores apresentados possui um sinal de controle, o qual é comumente chamado, na computação, de \textit{enable}, o que em português poderia ser traduzido livremente para "habilitar". Esse sinal indica o momento em que o registrador deverá salvar um dado ou não. O salvamento de cada dado ocorre em uma das bordas de subida do \textit{clock}, mas o sinal de controle \textit{enable} precisa estar ativo.

Considera-se um dado salvo aquele valor que é passado para a saída de um registrador e nela mantido para que possa ser utilizado por qualquer outro componente que está conectado à ela. Então, já é esperado que a entrada de um registrador, quando o sinal \enable{} estiver desativado, possa ser totalmente diferente da saída. 

Além dos registradores, os multiplexadores e as unidades de operações aritméticas também possuem sinais de controle. Contudo, diferentemente dos registradores, seus sinais de controle são chamados de seletores (ou abreviados para "\textit{sel}"). Seus sinais não são \enable{} porque eles não habilitam nada, mas sim definem o que será feito e, portanto, selecionam. Mesmo que eles estejam em zero, haverá um valor nos pinos de saída, mesmo que esse valor seja nulo, devido a uma possível ausência de entrada.

No caso dos multiplexadores, que possuem mais de uma entrada que deverão ser mapeadas para apenas uma saída, o seletor irá indicar o código da entrada que deverá ser reproduzida no pino de saída. Já na ULA, a funcionalidade é diferente. Um seletor na ULA define o tipo de operação aritmética ou de comparação que deverá ser executada. O mesmo ocorre no somador/subtrator, pois ele possui mais de uma operação possível para executar. Caso ele só fosse um somador, não necessitaria de um sinal de controle, visto que, no momento em que chegasse um valor em sua entrada, sairia o valor somado a 1 na sua saída. 

Quando se fala das memórias (ou pilhas), a nomenclatura também é um pouco diferente, mas sua funcionalidade é parecida com a de um registrador. O nome do sinal, nesse caso, é, muitas vezes, \textit{write}. Isso acontece porque uma memória está sempre lendo a posição que está sendo apontada pelo endereço de leitura (vindo de \textit{regTos}, \textit{regEnd} ou ainda \textit{regTosFuncao}) e reproduzindo o conteúdo dessa posição na sua saída. Mas quando o assunto é a escrita, então é necessário que haja uma permissão do controle para que ela seja feita. Isso se deve ao fato de que a memória não salvará todos os valores que chegam à sua entrada, mas sim apenas valores definidos. O funcionamento da memória, portanto, nada mais é do que um grupo de registradores conectados e coordenados. 

Até agora, foi falado apenas de componentes que possuem apenas um sinal de controle. Mas, na arquitetura proposta, podem ser encontrados dois registradores mais complexos (\textit{regPilha} e \textit{regMemExt}), os quais possuem dois sinais de controle cada. O funcionamento deles pode ser comparado a um conjunto de dois registradores unidos em um só. Na verdade, é exatamente o que eles são. Porém, para simplificar a implementação e o desenho da arquitetura, eles foram unidos em apenas um, porém com duas saídas e duas entradas. 

Após apresentados todos os tipos de sinais, não é necessariamente preciso nomeá-los, visto que, com exceção dos registradores de pilha e memória externa, todos possuem apenas um sinal de controle. Assim, os nomes dos sinais de controles que serão apresentados na subseção \ref{control_projMe} são exatamente os nomes dos componentes. Quando forem citados os registradores de pilha e memória, serão adicionados "W", indicando que a operação é para a saída de escrita (\textit{write}), ou "R", indicando uma operação de leitura (\textit{read}), no final dos seus nomes.

\subsection{Máquinas de Estados}
\label{control_meExp}

Uma máquina de estados nada mais é do que um conjunto de estados, os quais possuem definições diferentes para as saídas do componente controle. A cada ciclo de \clock{}, é esperado que haja uma troca de estado. Cada estado possui um estado que será seu sucessor. Assim, já é definido previamente qual estado virá após determinado estado. Em alguns casos específicos, pode haver uma decisão lógica para que seja definido o próximo estado.

Ao se encontrar em um estado, os sinais de controle são selecionados e adicionados às saídas do componente denominado controle. Normalmente, em um esboço de arquitetura, as ligações realizadas entre cada componente e o controle não são desenhadas, visto que já é esperado que o controle esteja conectado quase todos os componentes, tornando o desenho extremamente poluído e dificultando a visualizações de conexões mais importantes. 

Cada máquina de estados começa sempre em um estado inicial, o qual será o ponto de partida para cada uma das máquinas de estado parciais, que são como podem ser chamadas as máquinas de estados responsáveis por funcionalidades específicas. Nesse estado, é esperado que haja uma definição de instrução que seja executada ou um carregamento de dados iniciais necessários, para que se possa, então, encaminhar o sistema para a máquina de estado parcial responsável pela funcionalidade que será executada. 

Uma melhor visualização do sistema como um todo e da máquina de estados geral pode ser foi dividindo a máquina completa em máquinas menores, responsáveis por instruções ou funcionalidades específicas. Então, no primeiro estado, é esperado que o próximo estado seja selecionado. Esse próximo estado pode ser o primeiro estado de qualquer uma das instruções e depende unica e exclusivamente do valores salvo no registrador de instruções (\textit{regInstr}), o qual está conectado a uma das entradas do componente controle.

Uma imagem do componente controle, com seus pinos de entrada (à esquerda) e de saída (à direita) pode ser vista na Figura \ref{img_control}. Os nomes de cada pino de saída e entrada são os exatos nomes dos componentes que deverão estar conectados a eles, com excessão dos registradores com dois sinais de controle (memória externa e pilha). 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.8]{images/control.png}
\caption{Representação do componente Unidade de Controle.}
\label{img_control}
\end{figure}

Para que as máquinas de estados parciais, que serão apresentadas na próxima subseção, fossem criadas, foi necessário visualizar a arquitetura como um todo e definir os fluxos de execução para cada uma das instruções que serão executadas. Então, olha-se o que é preciso ser feito primeiro em cada passo de execução e define-se os sinais que deverão aparecer nas saídas do controle. Pode-se, porém, perceber que o primeiro estado de cada máquina de estados parcial é exatamente igual. Isso indica que pode existir um estado inicial comum para todas as instruções. 

Com raras exceções (instruções BINARY\_ e COMPARE\_OP), além do primeiro estado, cada estado só possui um sucessor fixo. As duas instruções que possuem um estado com mais de um estado sucessor são as duas citadas, pois nelas o valor de seleção da unidade lógica aritmética é a única característica diferente entre os estados "b4\_" (máquina de estados apresentada no apêndice \ref{apendice_maqEst}), no caso das instruções BINARY\_. Todas elas possuem sinais de saídas exatamente idênticos para todos os estados, exceto o estado que define o seletor da ULA. O mesmo ocorre na instrução COMPARE\_OP, na qual o seletor da ULA depende do valor contido no registrador \textit{regArg}. 

A unidade de controle, conforme pode ser observado na Figura \ref{img_control}, possui ainda mais duas entradas que não foram comentadas. A primeira, apelidada de \textit{clk}, representa a entrada do \clock{} e será utilizada para definir a troca de estados. Já a segunda, a qual possui uma saída também, é chamada de \textit{reset}. Quando inicia-se a arquitetura, a máquina de estados ainda não possui um estado definido, assim como os registradores TOS e PC, que não tem valores em suas saídas. Contudo, esses três componentes não podem funcionar sem que tenham um valor inicial em suas saídas, já que os valores de PC e TOS deverão ser incrementados ou decrementados durante a execução. Nos outros registradores, é possível iniciar a execução sem um valor inicial pois todos eles receberão valores prontos, que aparecerão em suas entradas independente das suas saídas. Mas \textit{regPc} e \textit{regTos} precisam das suas saídas para gerarem novos valores para serem atualizados.

Assim, define-se que, por padrão, os primeiros ciclos de \clock{} que a arquitetura executar, logo após ser ligada, serão utilizados para \textit{reset} e o sinal de entrada (\textit{entrada\_reset}) dessa funcionalidade no controle estará ativo. Esse, por sua vez, repassará, através do pino de saída (\textit{saida\_reset}), o mesmo sinal para todos os outros componentes que necessitem de um valor inicial para que possam funcionar corretamente. 

\subsection{Projeto das Máquinas de Estados}
\label{control_projMe}

Quando foi realizado o projeto da unidade de controle, definiu-se que cada instrução a ser implementada teria uma máquina de estados diferente. Com isso, foi possível otimizar ao máximo cada instrução, sem que haja a necessidade de perder funcionalidades com a reutilização de estados em outras instruções. 

Caso fosse priorizada a reutilização de estados, alguns dos passos que estão sendo feitos em apenas dois estados, poderiam ser feitos em três ou mais. Isso porque cada um dos estados teriam que ser menos complexos, visando que seja possível reunilizá-los em mais de uma instrução. Porém, como eles são complexos e cheios de sinais de saída específicos para cada instrução, torna-se extremamente difícil reunilizá-los em outra instrução.

Contudo, existe uma funcionalidade que é básica e feita no primeiro estado de cada instrução. Tal funcionalidade é a que permite a leitura, vinda da memória de instruções, dos 2 \bys{} de uma instrução: \textit{OpArg} e \textit{OpCode}. 

A Figura \ref{estado_inicial} apresenta, como exemplo de um estado, o estado inicial, que é o mesmo para todas as instruções. É possível perceber que, dentro de seu círculo, só aparecem os sinais que se tornaram ativos no momento da inicialização do estado. Quanto aos sinais que controle que são considerados seletores, eles são definidos como um valor padrão, atribuindo-se zero para cada um deles, já que eles são considerados \textit{don't care} no momento.

\begin{figure}[htp]
\centering
\includegraphics[scale=1]{images/estado_inicial.png}
\caption{Representação do estado inicial de todas as instruções.}
\label{estado_inicial}
\end{figure}

É possível perceber que, na imagem, aparecem três atribuições: desativação de \textit{regPc} e ativações de \textit{regInstr} e \textit{regArg}. A primeira, mesmo sendo um sinal que desliga um registrador, é apresentado pois, geralmente, o último estado de cada instrução salva o valor de \textit{regPc} atualizado, ativando-o. Logo, quando se atribui o valor zero à \textit{regPc}, fá-se uma modificação em possíveis instruções que tenham finalizado com o sinal de controle de \textit{regPc} ativo. Caso a última instrução executada não apresente um salvamento de PC no último estado, a atribuição de zero ao sinal \textit{regPc} não mudará nada. 

É necessário destacar que, para cada estado, é necessário que todos os sinais sejam definidos. Nos esquemas de máquinas virtuais, no entanto, somente são apresentados sinais que sofreram modificações. Já na implementação, cada estado define os valores de todos os sinais, já que caso não seja feito isso, poderiam haver problemas nos valores de casa sinal. 

Em cada máquina de estados é possível perceber um nome para cada um dos estados. Como o nome de cada instrução contém, na maioria das vezes, duas palavras, o nome de cada estado são as iniciais de cada palavra juntamente com o número do estado. Uma das exceções a isso são as instruções BINARY\_, que possuem uma máquina de estados que atende todas elas. Isso acontece porque as instruções são praticamente idênticas, com uma mudança apenas no valor do seletor da ULA, que deverá representar a operação aritmética que a instrução executada vai realizar. 

A outra exceção à essa definição são as instruções POP\_JUMP\_IF\_FALSE e POP\_JUMP\_IF\_TRUE. Nela, são apresentadas letras iniciais das duas primeiras palavras, juntamente com as palavras "\_PULO" ou "\_FICA", indicando que está havendo um desvio ou não. Isso porque nessa instrução deve haver uma definição sobre haver ou não o pulo e, caso houver, o próximo estado deve realizar ou não essa funcionalidade. 

Como pode ser visto na Figura \ref{me_loadConst}, que representa a instrução LOAD\_CONST, os nomes dos estados são "lc1", "lc2", etc. Esse mesmo padrão pode ser observado em todos os diagramas de máquinas de estados criados. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/LOAD_CONST.jpg}
\caption{Representação da máquina de estados da instrução LOAD\_CONST.}
\label{me_loadConst}
\end{figure}

No entanto, existe uma exceção quanto ao nome de um dos estados. Tal exceção acontece também em outras máquinas de estados. O estado com o nome de "lc1\_AUX" é um estado auxiliar, que foi inserido para que corrigir problemas. Durante o projeto das máquinas de estado e implementação, alguns estados foram acelerados, fazendo com que três estados virassem apenas dois. Contudo, ao realizar-se os testes, foi percebido que com a aceleração, não havia tempo para que os dados necessários para alguns componentes estivessem prontos para serem utilizados diretamente no próximo estado, fazendo com que seja necessária uma pequena pausa enquanto os dados não chegam.

Pode-se utilizar, como exemplo, a mesma instrução da Figura \ref{me_loadConst}. Nela, o estado apresentado como "lc2" foi concatenado ao estado "lc1\_AUX", fazendo com que, no mesmo estado, os registradores salvassem um valor e os multiplexadores já modificassem suas saídas, permitindo que no próximo estado já se obtivesse um novo resultado da ULA. Contudo, foi percebido, durante os testes, que o multiplexador modificava sua saída antes que os registradores terminassem de salvar o dado que era esperado, salvando, então, a nova saída da ULA. Para resolver esse problema, sem modificar todos os estados e seus nomes, foi inserido um estado auxiliar entre "lc1" e "lc2", o qual recebeu o nome de "lc1\_AUX" e que possui como característica apenas ativar o salvamento de dois registradores, sendo o \textit{regTos} responsável por salvar a saída da ULA.

Todas as máquinas de estados desenvolvidas para este trabalho e implementadas nele podem ser encontradas no apêndice \ref{apendice_maqEst}. Lá, elas estão divididas por classe de instrução e cada estado possui como nome as iniciais da instrução a qual pertence.