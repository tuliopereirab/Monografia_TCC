Um trabalho acadêmico é um documento que engloba tanto dados sobre a implementação propriamente dita quanto sobre o levantamento de informações. Este trabalho, recebendo essa classificação, foi desenvolvido durante o período de um ano e passou por diversos passos de levantamento de informações e projeto.

Este capítulo apresenta como foi desenvolvido este projeto, desde seu início até o resultado final, apresentado neste documento. Nele, podem ser encontradas informações sobre levantamento de informações (Seção \ref{newMeto_levantamento}), análises pré-implementação (Seção \ref{newMeto_analises}), implementação e testes (Seção \ref{newMeto_implementacao} e, por último, levantamento de resultados (Seção \ref{newMeto_resultados}).

Como este projeto foi dividido em duas grandes fases, houve algumas modificações nas características definidas inicialmente que, com o objetivo de manter íntegro o fluxo de implementação, foi adicionado um novo capítulo apresentando as modificações e os motivos que fizeram delas necessárias. A Seção \ref{newMeto_modificacoes} discorre brevemente sobre este tema. 

\section{Levantamento de Informações}
\label{newMeto_levantamento}

Primeiramente, antes que fosse tomada qualquer ação dentro do projeto, foi preciso que houvesse um amplo levantamento de informações sobre o assunto. Dentre essas informações, foi necessário, primeiramente, entender em detalhes como a linguagem \py{} é executada.

Sabendo, então, que ela é executada utilizando uma máquina virtual chamada \textit{Python Virtual Machine} (PVM), foi possível definir os objetivos deste trabalho: tornar possível executar algoritmos escritos em \py{} em uma arquitetura projetada em \hw{}.

Com a informação de que a máquina virtual existia, foi possível obter a documentação oficial que a descreve e outros documentos fornecidos por autores não oficiais da \textit{Python Software Foundation}, todos já apresentados no capítulo \ref{ref-teorico}. Com essa documentação, foi possível observar, principalmente, as instruções \as{} que compõem a máquina virtual, as quais são geradas através de compilação utilizando o compilador próprio da linguagem, \textit{CPython}.

De posse das informações básicas sobre as instruções, foi possível analisar quais seriam as instruções necessárias para que algoritmos de baixa complexidades pudessem ser executados diretamente em \hw{}. De posse de uma arquitetura que consegue executar algoritmos \py{} simples, é possível adicionar módulos capazes de aumentar o leque de aplicações suportadas. Tais incrementos ficarão para trabalhos futuros, tendo em vista o pouco tempo para a realização deste.

\section{Análises e Planejamentos}
\label{newMeto_analises}

Com várias informações básicas já obtidas, possuía-se conhecimento sobre o funcionamento básico da máquina virtual e podia-se iniciar a implementação. Contudo, o que implementar exatamente? Esta fase, chamada fase de análise, é responsável por responder a essa pergunta.

\subsection{Análise das Instruções}

Foi então iniciada a fase de análises e planejamentos do que deveria ser implementado. Primeiramente, com a aceitação de que seria impossível, no período deste trabalho, implementar todas as instruções existentes na máquina virtual \py{} tampouco todas as funcionalidades suportadas por ela, foi necessário analisar quais eram as mais importantes.

Para isso, alguns algoritmos de baixa complexidade foram implementados diretamente em \py{}. Utilizando a ferramenta \textit{Disassembler} presente na própria máquina virtual, foi possível observar as instruções \as{} utilizadas para a geração desses algoritmos.

Assim, foi criada uma lista básica de instruções que deveriam ser suportadas pela arquitetura física. Todas as análises feitas para definir as instruções básicas a serem suportas podem ser encontradas como leitura adicional no Apêndice \ref{analise_instr}.

A lista de instruções suportadas inicialmente era:

\begin{itemize}
	\item \textbf{Memória: }LOAD\_CONST, LOAD\_FAST e STORE\_FAST;
	\item \textbf{Aritméticas e comparações: }BINARY\_ADD, BINARY\_SUBTRACT, BINARY\_MULTIPLY, BINARY\_DIVIDE e COMPARE\_OP;
	\item \textbf{Desvios: }POP\_JUMP\_IF\_TRUE, POP\_JUMP\_IF\_FALSE, JUMP\_ABSOLUTE e JUMP\_FORWARD; 
	\item \textbf{Funções: }CALL\_FUNCTION e RETURN\_VALUE.
\end{itemize}

No decorrer do projeto, como será abordado no capítulo \ref{modificacoes}, foram adicionadas à lista as instruções BINARY\_AND, BINARY\_OR, BINARY\_XOR e UNARY\_NOT. Com exceção da UNARY\_NOT, todas se encaixam perfeitamente na classe de operações aritméticas. Essa, por sua vez, se baseia no seu funcionamento e sua única diferença é que utiliza apenas um operando para gerar resultado.

\subsection{Análise dos Componentes Necessários}
\label{newMeto_analise_comp}
Com a lista de instruções já definida, foi necessário realizar uma análise dos componentes necessários antes de gerar o modelo da arquitetura final.

Então, as instruções, separadas nas classes que foram apresentadas na subseção anterior, tiveram a definição dos componentes necessários. Para instruções de memória, por exemplo, foram definidos componentes como: pilha, registrador de pilha, registrador de topo, memória externa, registrador de memória externa e registrador de endereço. 

Todas as análises explicações sobre as decisões tomadas nesta fase de projeto podem ser encontradas como leitura adicional contida no Apêndice \ref{analise_componentes}.

Nesta fase, em resumo, foram definidos os componentes que estariam presentes em cada uma das arquiteturas parciais, as quais serão apresentadas no capítulo \ref{desenvolvimento}. Com esses componentes, foi possível identificar quais deles poderiam ser reutilizados e, portanto, reduzir a área ocupada pela arquitetura final.

Os componentes necessários para a criação de cada uma das arquiteturas parciais são:

\begin{itemize}
	\item \textbf{Funcionamento básico: } memória de instruções (\textit{memInstr}), registrador PC (\textit{regPc}), registrador de argumento (\textit{regArg}) e registrador de instrução (\textit{regInstr});
	\item \textbf{Memória: } pilha, memória externa (\textit{memExt}), registrador de pilha (\textit{regPilha}), registrador de endereço (\textit{regEnd}), registrador de \tos{} (\textit{regTos}) e registrador da memória externa (\textit{regMemExt}); 
	\item \textbf{Aritméticas e comparações: } unidade lógica aritmética (ULA), registrador de operandos 1 e 2 (\textit{regOp1} e \textit{regOp2}), registrador de \textit{overflow} e comparação (\textit{regOverflow} e \textit{regComp}); 
	\item \textbf{Desvios: } inicialmente nenhum componente em especial, porém foi adicionado o registrador de pulos (\textit{regJump}) durante as modificações; 
	\item \textbf{Funções: } pilha de função (\textit{pilhaFuncao}), pilha de retorno de TOS (\textit{pilhaTosRetorno}), registrador de TOS das pilhas anteriores (\textit{regTosFuncao}), somador/subtrator e registrador de retorno de dados (\textit{regDataReturn}).
\end{itemize}

\section{Implementação e Testes}
\label{newMeto_implementacao}

Nesta fase de projeto, foram definidas as arquiteturas parciais e, juntamente com as análises feitas anteriormente, foi possível criar uma arquitetura final. Além disso, foi necessária a realização de testes para validar o que foi implementado. As subseções \ref{newMeto_desenvolvimento} e \ref{newMeto_testes} apresentarão, respectivamente, como foram feitos o desenvolvimento e os testes.

\subsection{Fase de desenvolvimento}
\label{newMeto_desenvolvimento}

Para realizar o desenvolvimento, primeiramente, definiu-se a linguagem e, por conseguinte, a plataforma que seriam utilizadas para implementação, compilação e testes. Assim, foi definido que todo o projeto do \hw{} seria implementado em VHDL, utilizando a ferramenta \textit{Quartus}. Já o conversor, chamado de \textit{pyConv} e apresentado no capítulo \ref{conversor}, seria implementado em C.

A fase de desenvolvimento fala apenas sobre a criação do \hw{}, visto que o \textit{pyConv} foi uma implementado para ser uma ferramenta extra, utilizado, principalmente, para gerar arquivos de testes. A criação do conversor, juntamente com seus métodos para evitar erros, são explicados no capítulo \ref{conversor}.

Isto definido, foram criadas arquiteturas parciais para cada classe de instruções e, ao final, uma arquitetura final englobando todas as parciais, com adição de multiplexadores para que fosse possível reaproveitar componentes. A criação dessas arquiteturas é explicada com detalhes no capítulo \ref{desenvolvimento}. 

\subsection{Fase de testes}
\label{newMeto_testes}

Após realizada a implementação da arquitetura completa, assim como sua unidade de controle, foram realizadas simulações para cada uma das instruções e funcionalidades, utilizando algoritmos de baixa complexidade. Para a realização desses testes, foi utilizada a ferramenta de simulação \textit{Modelsim}.

Com essa ferramenta, é possível analisar cada um dos sinais internos e externos de cada um dos componentes que fazem parte da arquitetura. Essa funcionalidade é fundamental, visto que podem haver erros internos que, sem ela, seriam difíceis de serem identificados.

\section{Modificações}
\label{newMeto_modificacoes}

Com a divisão deste projeto em duas grandes partes (a primeira de levantamento de informações e implementação primária, e a segunda de realização de testes e refinamento do projeto), foram necessárias algumas modificações simples, aplicadas diretamente na arquitetura, que precisavam ser inseridas neste documento. 

Contudo, parte deste documento, responsável por explicar o desenvolvimento em detalhes, já estava concluída e, assim, decidiu-se incluir um capítulo a parte explicando as modificações e as motivações que levaram a elas. As informações completas e detalhadas de todas as modificações podem ser encontradas no capítulo \ref{modificacoes}.

Basicamente, todas as modificações tiveram como objetivo refinar a arquitetura para que fosse possível suportar futuras funcionalidades, as quais poderão ser acopladas como componentes externos à arquitetura. No resultado deste projeto, é esperado que a ampliação da arquitetura aqui descrita possa ser ampliada com trabalhos futuros sem modificar nada, além da unidade de controle (\textit{plug and play}). 

\section{Levantamento de Resultados}
\label{newMeto_resultados}

Para o levantamento dos resultados, foram analisados, principalmente, dados gerados pelas ferramentas utilizadas. Tanto o \textit{Quartus} quanto o \textit{Modelsim} geram dados que permitem que uma análise sólida do funcionamento da arquitetura seja feita.

O \textit{Quartus} gera dados relacionados à arquitetura em si, permitindo que seja possível verificar dados como área ocupada em um \textit{chip} (quantidade de componentes utilizados) e características básicas, como frequência de operação e potência dissipada. Ainda com essa ferramenta é possível realizar simulações, contudo essa não é uma boa funcionalidade para ser utilizada durante a fase de testes, tendo em vista a falta de dados apresentados nas simulações em comparação com o \textit{Modelsim}.

As simulações do \textit{Quartus} apenas apresentam dados dos pinos de entrada e saída da arquitetura, não sendo possível analisar sinais internos dela. Sendo assim, para este quesito, a ferramenta \textit{Modelsim} se sobressai.

Essa ferramenta permite que sejam verificados dados internos aos componentes, facilitando, principalmente, que as causas de problemas na execução de certas instruções sejam encontradas. Um exemplo para isso é quando era esperada uma escrita na memória e, por algum motivo, ela não foi realizada. Com o \textit{Modelsim} é possível identificar o exato componente problemático através de análises das ondas geradas pela execução, indicando os valores presentes em cada um dos sinais internos no decorrer do tempo.

Assim, como apresentado no Capítulo \ref{resultados}, dividiu-se a utilização do \textit{Quartus} apenas para verificar características da arquitetura e carregar a mesma em um FPGA, também utilizado para os testes. Já para o \textit{Modelsim} ficou toda a parte de simulação e correção de \textit{bugs} encontrados. Somente quando tem-se simulações que executam o que era esperado no \textit{Modelsim}, passa-se ao \textit{Quartus} para realizar testes com um FPGA.