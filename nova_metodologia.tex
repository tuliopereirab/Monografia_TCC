Um trabalho acadêmico é algo que engloba tanto a implementação propriamente dita quando o levantamento de informações e, posteriormente, inserção dessas informações em uma monografia. Este trabalho, recebendo essa classificação, foi desenvolvido durante um ano e passou por diversos passos de levantamento de informações e projeto.

Este capítulo apresenta como foi feito o projeto completo, desde seu início até o resultado final. Nele, podem ser encontradas informações sobre levantamento de informações (seção \ref{newMeto_levantamento}), análises pré-implementação (seção \ref{newMeto_analises}), implementação e testes(seção \ref{newMeto_implementacao} e, por último, levantamento de resultados (seção \ref{newMeto_resultados}).

Como este projeto foi dividido em duas grandes fases, houveram algumas modificações simples no projeto que, tendo em vista que parte desse documento já estava escrita, foi adicionado um novo capítulo explicando as modificações e as necessidades delas. A seção \ref{newMeto_modificacoes} discorre brevemente sobre este tema.

\section{Levantamento de Informações}
\label{newMeto_levantamento}

Primeiramente, antes que fosse tomada qualquer ação dentro do projeto, foi preciso que houvesse aquisição de informações fundamentais. Dentre elas, foi necessário, primeiramente, entender como a linguagem \py{} é executada, em detalhes.

Sabendo, então, que ela é executada utilizando uma máquina virtual chamada \pvm{}, foi possível definir os objetivos deste trabalho: tornar possível executar algoritmos escritos em \py{} diretamente em uma arquitetura em \hw{}.

Com a informação de que a máquina virtual existia, foi possível obter a documentação oficial que a descreve e outros documentos não oficiais, já apresentados no capítulo \ref{ref-teorico}. Com essa documentação, foi possível observar, principalmente, as instruções \as{} que compõem a máquina virtual, as quais são geradas através de uma compilação.

De posse das informações básicas sobre as instruções, foi possível analisar quais seriam as instruções necessárias para que algoritmos de baixa complexidades pudessem ser executados diretamente em \hw{}. 

\section{Análises e Planejamentos}
\label{newMeto_analises}

Com várias informações básicas já adquiridas, tinha-se as o conhecimento sobre o funcionamento básico da máquina virtual e podia-se iniciar a implementação. Contudo, o que implementar exatamente? Esta fase do projeto é responsável por responder essa pergunta.

\subsection{Análise das Instruções}

Foi então iniciada a fase de análises de planejamentos do que deveria ser implementado. Primeiramente, com a aceitação de que seria impossível, no período deste trabalho, implementar todas as instruções existentes na máquina virtual \py{}, foi necessário analisar quais eram as mais importantes.

Para isso, alguns algoritmos extremamente simples foram criados e implementados diretamente em \py{}. Utilizando a ferramenta \textit{Disassembler} presente na própria máquina virtual, foi possível entender as instruções \as{} utilizada para a geração desses algoritmos.

Com essa informação, foi levantada uma lista básica de instruções que deveriam ser suportadas pela arquitetura física. Todas as análises feitas para definir as instruções básicas a serem suportas podem ser encontradas como leitura adicional no apêndice %citar apêndice da metodologia.

A lista de instruções suportadas inicialmente é:

\begin{itemize}
	\item \textbf{Memória: }LOAD\_CONST, LOAD\_FAST e STORE\_FAST;
	\item \textbf{Aritméticas e comparações: }BINARY\_ADD, BINARY\_SUBTRACT, BINARY\_MULTIPLY, BINARY\_DIVIDE e COMPARE\_OP;
	\item \textbf{Desvios: }POP\_JUMP\_IF\_TRUE, POP\_JUMP\_IF\_FALSE, JUMP\_ABSOLUTE e JUMP\_FORWARD; 
	\item \textbf{Funções: }CALL\_FUNCTION e RETURN\_VALUE.
\end{itemize}

\subsection{Análise dos Componentes Necessários}

Com a lista de instruções já definida, foi necessário realizar uma análise dos componentes necessários antes de gerar o modelo da arquitetura final.

Então, as instruções, separadas nas classes que foram apresentadas na subseção anterior, tiveram a definição dos componentes necessários. Para instruções de memória, por exemplo, foram definidos componentes como: pilha, registrador de pilha, registrador de topo, memória externa, registrador de memória externa e registrador de endereço. 

Todas as análises explicações sobre as decisões tomadas nessa fase de projeto podem ser encontradas na leitura adicional contida no apêndice %citar apêndice.

Em resumo, esta fase definiu-se pela definição de componentes presentes em cada uma das arquiteturas parciais, as quais seram definidas no capítulo \ref{desenvolvimento}. Com esses componentes, foi possível identificar componentes que poderiam ser reutilizados e, portanto, reduzir a área ocupada pela arquitetura final.

\section{Implementação e Testes}
\label{newMeto_implementacao}

Nesta fase de projeto, foram definidas as arquiteturas parciais e como as análises feitas anteriormente foram utilizadas na criação da arquitetura final. Além disso, foi necessária a realização de testes para validar o que foi implementado. As subseções \ref{newMeto_desenvolvimento} e \ref{newMeto_testes} apresentarão, respectivamente, como foram feitos o desenvolvimento e os testes.

\subsection{Fase de desenvolvimento}
\label{newMeto_desenvolvimento}

Para realizar o desenvolvimento, primeiramente, definiu-se a linguagem a ser utilizada e a plataforma que seria utilizada para compilação e testes. Então, definiu-se que todo o projeto do \hw{} seria implementado em VHDL e o conversor, apresentado no capítulo \ref{conversor}, em C.

A fase de desenvolvimento fala apenas sobre a criação do \hw{}, visto que o Conversor foi algo a mais utilizado, principalmente, para os testes. Então, para a criação do \hw{}, foi utilizada a ferramenta \textit{Quartus}, provida pela empresa Altera. 

Com isso definido, foram criadas arquiteturas parciais para cada classe de instruções e, ao final, uma arquitetura final contendo todas as parciais. A criação dessas arquiteturas é explicada com detalhes no capítulo \ref{desenvolvimento}. 

\subsection{Fase de testes}
\label{newMeto_testes}

Após realizada a implementação da arquitetura completa com sua unidade de controle, foram realizados testes para cada uma das instruções e para algoritmos de baixa complexidade. Para a realização desses testes, foi utilizada a ferramenta \textit{Modelsim}, também criada pela empresa Altera.

Com essa ferramenta, é possível analisar cada um dos sinais internos e externos de cada um dos componentes que compõem a arquitetura. Essa funcionalidade é fundamental visto que podem haver erros internos que, sem ela, seriam extremamente difíceis de serem identificados.

\section{Modificações}
\label{newMeto_modificacoes}

Com a divisão deste projeto em duas grandes partes (a primeira de implementação e levantamente de instruções e a segunda de realização de testes e refinamento do projeto), houveram algumas modificações simples diretamente na arquitetura que precisavam ser inseridas neste documento. 

Contudo, parte deste documento, responsável por explicar o desenvolvimento, já estava concluída e, então, decidiu-se incluir um capítulo a parte explicando as modificações e as motivações que levaram a elas. As informações completas e detalhadas de todas as modificações podem ser encontradas no capítulo \ref{modificacoes} deste documento.

Basicamente, todas as modificações tiveram como objetivo refinar a arquitetura para que fosse possível suportar futuras funcionalidades, as quais poderão ser acopladas como componentes externos à arquitetura. No resultado deste projeto, é esperado que a amplicação da arquitetura aqui descrita possa ser ampliada com trabalhos futuros sem modificar nada, além da unidade de controle. 

\section{Levantamento de Resultados}
\label{newMeto_resultados}