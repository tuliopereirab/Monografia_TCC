A linguagem \textit{Python} \cite{Rossum2008} é considerada uma linguagem de programação interpretada \cite{Sanner1999}. Isso significa que, ao invés de seus \textit{bytecodes}, quando executados, serem enviados para que o processador físico da máquina onde o algoritmo irá rodar os leia e execute cada uma de suas instruções, um interpretador assume essa responsabilidade e executa em \textit{software} o que seria executado pelo \textit{hardware} e, consequentemente, esse \sw{} é executado em \hw{}. Contudo, tal interpretador é implementado em uma linguagem que irá executar diretamente no processador físico do sistema utilizado. O \textit{Python} utiliza como interpretador a ferramenta \textit{CPython}, que foi criada especificamente para ser capaz de cumprir tal tarefa corretamente. Ela foi desenvolvida pelo mesmo criador da linguagem e escrita na linguagem de programação C \cite{PythonLanguageReference}.

O interpretador \textit{Python}, \textit{CPython}, pode ser tratado como uma máquina virtual, visto que ele recebe os \textit{bytecodes} de determinado algoritmo e executa dentro de si próprio. Ir-se-á ver, na seção \ref{cpython_func}, como é feita execução de determinado algoritmo através do interpretador. Assumir-se-á, então, que tal interpretador seja tratado especificamente como uma máquina virtual (VM) daqui para frente neste trabalho, já que ele possui todas as características de uma \cite{Goldberg1974}.

A grande vantagem de se utilizar uma linguagem interpretada, ou seja, baseada em uma máquina virtual, é o fato de que qualquer algoritmo escrito na linguagem pode ser executado em qualquer \textit{hardware}, desde que exista uma implementação da máquina virtual para tal \textit{hardware} \cite{Rosenblum2004}. Isso evita que o mesmo algoritmo tenha de ser convertido para outras linguagens de programação ou recompilado para cada sistema onde deverá rodar.

\section{A linguagem Python}
\label{ling_python}

A linguagem \py{}, como dito anteriormente, teve sua primeira aparição no ano de 1990. Ela é uma linguagem interpretada, com seu interpretador principal e básico sendo o \cpy{}, que será apresentado na seção \ref{cpython_func}. 

Segundo \cite{Sandler2018}, que escreveu para a revista Business Insider, a linguagem \py{} aparece na sétima posição em uma lista das 14 linguagens mais populares, de acordo com 100 mil desenvolvedores. Isso mostra que a linguagem está muito próxima de linguagens como \textit{Java} \cite{Grand1997}, a qual aparece na quinta posição e é muito conhecida, principalmente, por permitir a criação de algoritmos que possam ser executados nos mais variados dispositivos. A lista também mostra a enorme difusão de sistemas focados funcionarem na \textit{Internet}, tendo, em suas três primeiras posições, linguagens como \textit{Javascript} \cite{Flanagan2006}, HTML \cite{Lloyd2008} e \textit{Cascading Style Sheets}, conhecida como CSS \cite{Bos2011}.

Ainda sobre a lista publicada pela revista, muitos dos desenvolvedores entrevistados acreditam que \py{} é a melhor e mais fácil linguagem para que uma pessoa que nunca programou, mas gostaria de ingressar na área. Segundo eles, ela é uma linguagem com alta facilidade de leitura, podendo ser entendida facilmente.

\subsection{Aplicações para \py{}}

A linguagem \py{}, por ser uma simples e poderosa linguagem orientada a objetos \cite{Lutz2007}, é utilizada para diversos fins que envolvam algoritmos complexos. Diversas áreas utilizam algoritmos \py{} para resolver problemas e verificar acontecimentos.

Uma das áreas, a primeira, é a área biológica, chamada de bioinformática, que utiliza \py{} para criar ferramentas computacionais aplicadas à biologia molecular \cite{Cock2009}. Outras aplicações que utilizam \py{} dentro da bioinformática são a filogenética \cite{Sukumaran2010} e sequenciamento de alto rendimento \cite{Anders2015}. Essas duas últimas são bibliotecas que visam facilitar implementações de algoritmos para fins específicos dentro de cada área.

Outras áreas da ciência que utilizam \py{} para criação de seus algoritmos são a sismologia, que possui uma biblioteca que permite facilitar a implementação de algoritmos \cite{Beyreuther2010}, a exploração de árvores \cite{Huerta-Cepas2010} e a neurociência \cite{Peirce2007}.

Voltando para a computação sem aplicação a nenhuma área específica, podemos citar aplicações de \py{} em algoritmos focados na \textit{web}, tal como \cite{Forcier2008}, inteligência artificial (\textit{Machine Learning}) \cite{Pedregosa2012} e \textit{Data Science} \cite{Grus2015}. Dentro da matemática, também, a ferramenta \textit{Matlab} possui suporte à algoritmos \py{} \cite{MathWorks2015}.



\section{Funcionamento CPython}
\label{cpython_func}

A máquina virtual \textit{Python}, com a sua implementação original chamada de \textit{CPython} \cite{designCompiler}, baseia-se no uso uma pilha para permitir a execução de diversas funcionalidades nos componentes do processador. Para executar qualquer instrução que necessite utilizar dados que virão da memória externa onde ficam armazenadas as variáveis, é preciso que essa pilha salve estes dados no seu topo para, então, a instrução de execução possa ser chamada e possa utilizar os dados. Para falar sobre o topo da pilha, utilizaremos a sigla TOS (top of the stack), que também é utilizada em documentos que descrevem o funcionamento do interpretador \cite{pythonMachine}. 

A pilha do \cpy{} é capaz de suportar qualquer tipo de dados que a linguagem \py{} permite. Tal pilha é a responsável por guardar todos os dados que forem carregados, com o objetivo de serem executados e determinados componentes do processador, sendo valores constantes (que estejam entrando no sistema pela primeira vez) ou variáveis (que já foram carregados anteriormente e salvos na memória). Assim como uma pilha padrão, existe um ponteiro que sempre aponta para a primeira posição da pilha (a posição que se encontra no topo da pilha e que contém o último dado que foi inserido). A seção \ref{a_requisitos} irá apresentar mais detalhes sobre as análises referentes à pilha. 

Quando se retira um dado da pilha, deve-se modificar o \tos{}, realizando uma subtração. Logo, por ora, é importante saber que, ao remover um elemento, é necessário que o \tos{} passe a apontar para a posição abaixo, já que o primeiro elemento (\tos{}) será excluído da pilha. Os grandes exemplos de instruções que modificam o TOS durante as execuções podem ser quaisquer operações aritméticas, que falaremos aprofundadamente na subseção \ref{op-arit}. 

Assim como os códigos \textit{Assembly} de outros processadores, como MIPS \cite{Sweetman2006}, Neander e suas variáveis \cite{Weber1998}, os da linguagem \textit{Python} são organizados e sugestivos, já que alguém que possua um conhecimento básico sobre o funcionamento de uma linguagem de baixo nível conseguirá observar diversas familiaridades com outros códigos. Porém, existem diversas instruções que são próprias da linguagem \textit{Python} e que servem para propósitos bem específicos na execução de algum algoritmo (como exemplos podemos citar LOAD\_CONST e LOAD\_FAST), assim como outras que são semelhantes as de outros processadores mas apresentam outros nomes (como por exemplo BINARY\_ADD). 

Note que a comparação direta do código \textit{Assembly} \textit{Python} que tenha como objetivo executar em qualquer processador pode ser feita somente porque o \textit{Python} utiliza uma \vm{} que trabalhará como um processador auxiliar na execução dos algoritmos, ou seja, fará com que um código \as{} padrão execute em qualquer \hw{} sem a necessidade de uma recompilação. Em outras linguagens, como C, não podemos realizar tal comparação, visto que o compilador irá converter o código \as{} baseado no conjunto de instruções (ISA) do processador alvo da execução e não baseado em um conjunto fixo da linguagem, assim o código \as{} poderá executar diretamente no \hw{}. Como exemplo, podemos citar o caso de um algoritmo escrito em C sendo executado em processadores desenvolvidos pela Intel, que possuem ISAs bem específicas e o mesmo algoritmo sendo executado em processadores AMD. Para que seja possível essa troca de processadores, é necessário que o algoritmo inicial seja recompilado utilizando um compilador próprio para seu processador, o qual transformará o código em alto nível em um código \as{} baseado na sua ISA. Já quando estamos falando de \py{}, temos que o mesmo código \as{} podendo rodar em processadores de ambas as empresas sem haver a necessidade de ser executada uma nova compilação. Isso torna o \py{} uma linguagem com alta portabilidade  \cite{Watters1996}.  

Conquanto, é necessário notar que, ao transformar a \pvm{}  em um circuito digital implementado em \textit{hardware}, serão necessárias várias modificações, visto que existem muitas diferenças entre as abstrações de como um \sw{}  é executado e como um \hw{} é executado. No que diz respeito a manipulação de \textit{bytecodes} e endereçamentos, a \vm{} utiliza funcionalidades específicas de um \sw{}, tais como manipulação simples de \textit{strings}, não podendo, portanto, serem utilizadas tão facilmente em \hw{}. Muitas das características que serão abordadas aqui vieram de \cite{insidePVM}.

Atualmente, o interpretador \cpy{}, sendo ele implementado em \sw{}, utiliza diversas funcionalidades que facilitam sua implementação e que só são possíveis de serem utilizadas porque uma linguagem de programação de alto nível possibilita isso. Dentre as funcionalidades, podemos citar um modo simples de endereçamento, podendo utilizar, inclusive, o código \as{} com instruções escritas invés de instruções expressas em código binário. Já implementar o mesmo sistema em \hw{} exige que o problema seja analisado com um menor nível de abstração e que, baseado no exemplo dado, seja definida uma codificação binária, que o um sistema físico não conseguirá ser capaz de ler e reconhecer letras e palavras. 


\section{Instruções básicas de funciomento da linguagem Python}

Como parte deste trabalho, foram feitas análises utilizando algoritmos escritos em \py{} para gerar, através de uma ferramenta da própria linguagem, chamada \textit{Disassembler}, o código \asp{}. Isso foi feito com o objetivo de identificar instruções que são essenciais  para executar algoritmos em \textit{Python}. A seção \ref{a_instrucoes} irá abordar em detalhes como foram feitos os testes e as definições.

Como algoritmos que foram utilizados para realizar tais análises, podemos citar códigos que executam diversas operações aritméticas, comparações e pulos através do código. Como já era esperado, nenhuma das funções que são chamadas na linguagem de alto nível pode ser vistas no baixo nível. Em todas as vezes, determinado comando em alto nível é quebrado em cinco ou até mais instruções de baixo nível. Isso se deve ao fato de que a \vm{}, mesmo sendo implementada em \sw{}, simula um processador, o qual não é capaz de executar um bloco complexo de instruções em um único módulo. Em outras palavras, um processador possui instruções simples visam melhorar o desempenho na execução de qualquer aplicação e diminuir a área ocupada pelo processador. Caso fosse adicionado em um processador um módulo que fosse responsável somente por, por exemplo, executar uma equação matemática inteira de uma só vez, tal instrução seria extremamente grande, complexa e, além disso, ocuparia grande área pra executar uma pequena taxa de vezes, já que a mesma equação não será executada sempre. Por isso, os processadores utilizam instruções que executam tarefas separadas e, de certa forma, simples, para evitar que determinada instrução se torne o ponto fraco do processador, consumindo maior área e diminuindo a frequência de operação de todos os componentes. 

Assim sendo, a \pvm{} possui instruções bem definidas e de propósitos específicos. Juntando determinada sequência delas, é possível montar uma instrução de alto nível. Dessarte, podemos então entender como é feita a programação em \textit{Assembly}, que se baseia em um conhecimento prévio do conjunto de instruções de determinado processador ou, neste caso, \vm{}, e, após, uma montagem de um algoritmo que execute determinada função, presente nas linguagens de alto nível, em vários passos simples de serem executados individualmente.

As instruções que foram analisadas para a realização desse projeto estão apresentadas abaixo, juntamente com suas funcionalidades básicas. A linguagem \textit{Python} dispõe de inúmeras outras instruções, que não serão apresentadas neste trabalho. Todas as instruções e suas funcionalidades podem ser encontradas na documentação oficial da linguagem \py{} \cite{Python2017}. 

\subsection{Manipulação de dados}
\label{manipulacao_dados}
Instruções de manipulação de dados podem ser consideradas de grande importantes na maioria dos conjuntos de instruções, tendo em vista que a principal funcionalidade de qualquer algoritmo é computar dados de inúmeros formatos. Logo, é sempre necessário que os dados possam ser acessados e alocados na memória da máquina onde o algoritmo está sendo executado. 

A utilização das instruções de manipulação de dados geralmente ocorre imediatamente antes e imediatamente após a manipulação de determinado dado ou conjunto de dados. Isso acontece porque, na maioria das vezes, o processador precisará destes dados em uma memória que seja rápida o suficiente para que possa ser lida e escrita por ele na mesma velocidade em que ele trabalha. Então, para essa finalidade, utilizam-se registradores dentro do próprio processador, que são extremamente rápidos, porém possuem baixa capacidade de armazenamento e elevada volatilidade, podendo haver perdas de dados com quedas ou oscilações de energia. Então, quando se necessita executar, por exemplo, uma operação aritmética de soma, carrega-se as duas variáveis (dados) para os registradores na ordem em que o compilador definiu, com base no que o usuário escreveu em alto nível. 

A ordem é escolhida pelo compilador na hora em que ele lê determinado comando em alto nível e decide quebrá-lo em várias instruções. Então, um compilador lerá, no caso do \py{}, uma linha de código de alto nível de atribuição de valor a uma variável contendo uma soma entre duas outras variáveis e a quebrará em dois carregamentos de variáveis, uma soma e um salvamento na memória. No caso da linguagem \py{}, como o compilador foi feito especialmente para trabalhar com uma pilha, ele já tem definido a ordem certa de chamar cada operando da operação, visando sempre que o resultado da operação seja o esperado pelo usuário quando ele escreveu o algoritmo. Logo, a correta ordem de carregamentos das variáveis é crucial para que o resultado saia corretamente. A Figura \ref{img_exemplo_pilha} mostra uma instrução (a), o carregamento das variáveis na pilha (b), a obtenção do resultado retornado na pilha (c) e, posteriormente, o salvamento do resultado na memória (d). Em equações mais complexas, onde existem parênteses que tornam operações internas mais importantes que outras, é necessário que o compilador consiga percebê-las e montar o código \as{} de forma que elas sejam atendidas corretamente. 

\begin{figure}[htp]
\centering
\includegraphics{images/exemplo_pilha.png}
\caption{Exemplo de carregamento de dados de uma equação para a pilha.}
\label{img_exemplo_pilha}
\end{figure}

Portanto, sempre que o compilador necessita traduzir uma operação aritmética, ele visualiza as prioridades da mesma e faz com que instruções de carregamento dos dados estejam posicionadas na ordem certa. Como os dados da \pvm{} executam dentro de uma pilha, existe uma ordem correta para que os dados sejam adicionados na pilha, já que a mesma irá retirar sempre o último dado primeiro. Então, como veremos na seção \ref{op-arit}, operações aritméticas executam sempre entre os dois dados no \tos{}. Logo, dados que estejam entre parênteses, por exemplo, serão os últimos a serem carregados, pois precisarão estarem mais ao \tos{} do que os demais. Podemos dizer, então, que o carregamento de dados para a pilha é realizado de forma inversamente proporcional à ordem de prioridade, sendo o primeiro a ser carregado apresentando a menor prioridade.

Após todos os carregamentos concluídos, são feitas as chamadas de funções aritméticas, por exemplo, na ordem idêntica à de prioridade. Tal fato ocorre porque, como as primeira e segunda posições da pilha contêm os dois operandos da operação de maior prioridade, como dito anteriormente, sua operação deverá ser executada antes de qualquer outra. Então, a segunda e terceira posição possuem elementos de prioridade diretamente inferior e deverão ser executadas logo a seguir. Seguindo a ordem de prioridade até que todas as instruções tenham sido executadas. A Figura \ref{img_exemplo_prioridades} apresenta a execução de uma equação que possui uma multiplicação e uma soma. Em (a), é apresentada a equação; em (b), aparecem todos os três valores carregados para a pilha; em (c), a pilha aparece com dois valores, pois já foi executada a operação de multiplicação (que possui prioridade superior à soma) e; em (d) pode-se observar que só existe o valor final da equação, após a realização da soma entre o resultado da multiplicação e o terceiro valor.

\begin{figure}[htp]
\centering
\includegraphics{images/exemplo_prioridades.png}
\caption{Exemplo de uma operação, através da pilha, de uma equação com três operândos e prioridades diferentes.}
\label{img_exemplo_prioridades}
\end{figure} 

Após obter-se o resultado da equação matemática no \tos{}, é então chamada uma instrução que deverá salvar o conteúdo do \tos{} em uma posição da memória para que ela fique acessível para possíveis outras utilizações. Note que a definição das ordens de prioridades é feita completamente pelo compilador da linguagem \py{}, sendo necessário, somente, que o usuário programador especifique corretamente as prioridades de uma operação os sinais adequados.

As instruções de manipulação de dados da linguagem \textit{Python} são:

\begin{description}
	\item[LOAD\_CONST]: é a instrução responsável por carregar um valor para a posição TOS. Seu uso ocorre, na maioria das vezes, quando é preciso definir o valor de uma variável inicialmente para, após, salvar tal variável na memória. 
	\item[LOAD\_FAST]: é a instrução capaz de carregar, diretamente da memória, o conteúdo de uma variável que foi previamente salva. Ela é utilizada para operações que envolvam uma ou mais variáveis, com ou sem constantes presentes. Seu argumento é a posição de memória na qual será lido o conteúdo para, então, executar o carregamento.
	\item[LOAD\_GLOBAL]: \textbf{FALTA APROFUNDAMENTO TEÓRICO}
	\item[STORE\_FAST]: é a instrução responsável por levar o conteúdo do \tos para uma posição específica da memória. Ela recebe como argumento o endereço de memória onde o dado será salvo. 
\end{description}

\subsection{Pulos (jumps)}
\label{instr_pulos}

As instruções que são responsáveis por executar pulos (\textit{jumps}) dentro do código são de extrema importância para algoritmos, pois visam otimizar determinada tarefa, permitindo que haja reaproveitamento de código, e permitem que haja pulos de uma linha de código para outra muito a frente ou atrás, não sendo, portanto, necessária uma execução sequencial durante todo o tempo. Na maioria das vezes, tais instruções são utilizadas em funções de repetições (\textit{loops}) e em funções de comparações. \textbf{CITAR INSTRUÇÕES DE REPETIÇÃO} 

Sua utilização é muito importante, visto que somente com elas é possível reaproveitar partes de códigos em mais de um contexto e momento. Como exemplo disso, podemos reutilizar qualquer procedimento implementado em uma linguagem de alto nível, tal como C ou \py{}. Esse procedimento é definido como uma parte de código que executa uma sequência de funcionalidades específicas que podem ser utilizadas várias vezes durante a execução do programa, com a finalidade de evitar que a mesma funcionalidade seja escrita mais de uma vez. Com isso, dizemos que sempre que uma outra função precisar executar diversas linhas de código mais de uma vez, ela irá "chamar" o procedimento, em uma linha de código apenas, sem a necessidade de reescrever tudo o que está dentro da função chamada novamente.

Logo, como podemos perceber, olhar e entender para o funcionamento de alto nível é mais simples, pois existe uma grande abstração que simplifica conceitos físicos. Porém, como estamos trabalhando com o código \textit{Assembly} da linguagem \textit{Python}, precisamos entender como essa simples chamada irá resultar na execução de uma função e, depois, retornar de onde parou. 

Para explicar isso, começaremos com um simples exemplo de um fluxo de repetição (\textit{while}). Quando escrevemos em nosso algoritmo \textit{Python} que uma sequência de código irá executar enquanto uma variável "X", por exemplo, estiver entre 0 e 10, incrementando sempre o valor em uma unidade, estamos evitando de escrever dez vezes o mesmo trecho de código. Então, na primeira execução, o valor de "X" é comparado com o valor final (dez), para verificar se esse já foi atingido ou não. Caso não tenha sido, ir-se-á passar para a próxima linha de código e começará a executar o \textit{loop} pela primeira vez. Ao chegar no final da sequência de código, haverá um pulo para a linha inicial do \aloop{}, onde a variável "X" é carregada da memória para a pilha, juntamente com a constante 10. Nesse pulo, o valor que define a linha atual que o processador está lendo (contador de programa - PC) será substituído pelo valor referente ao da primeira instrução da estrutura de repetição. Então, se inicia novamente o fluxo até que chegue o número final alvo, neste caso 10.

Supondo então que o valor alvo já foi atingido e o contador de programa está apontando para a instrução de comparação. Então, a instrução de comparação irá resultar em falso, já que será feita a comparação do valor atual de "X", que não é menor que 10. Como o valor de "X", agora, é igual a 10, o resultado da comparação será falso. Obtendo esse resultado, não é possível simplesmente continuar executando a linha de código imediatamente após a comparação. É necessário, então, um pulo para fora do \textit{loop}. Então, é feito um pulo que tem como alvo a linha de código imediatamente após o final do \textit{loop}. Tal linha deve ter sido salva antes de iniciar-se o \textit{loop} e, na maioria das vezes, esse pulo é realizado com a instrução JUMP\_FORWARD. Os detalhes mais específicos sobre as implementações dessa categoria de instruções será abordado na seção \ref{def_inst_esc}.

Os pulos inseridos em um \aloop{} foram utilizados como exemplo para explicar o funcionamento de duas instruções de pulos diferentes e a necessidade deles para que trechos de código sejam reaproveitados. Então, em resumo, um pulo seria a troca do valor do \pc{} para o valor referente ao início de um procedimento e, após, para o valor referente à instrução imediatamente após a chamada do procedimento. Neste caso, diferentemente do caso de um \textit{loop}, em que não salvamos o valor de \pc{} anterior ao início do \aloop{}, devemos salvar o valor de \pc{} anterior como sendo a linha de código logo após a chamada do procedimento. Então, após chegar na última linha do procedimento, devemos executar um pulo que leve o \pc{} de volta para a linha de código que foi salva previamente. 

As instruções presentes na ISA da PVM para tratar de desvios são as seguintes:

\begin{description}
	\item[POP\_JUMP\_IF\_FALSE]: é a instrução responsável por executar um pulo após uma comparação que obtém um resultado falso. Pode ser utilizada, por exemplo, em uma saída de \textit{loop}, onde o resultado da comparação será falso.
	\item[POP\_JUMP\_IF\_TRUE]: é a instrução responsável por executar um pulo após uma comparação que obtém um resultado negativo. Ela é comumente utilizada para a execução de um \textit{loop} que realiza a comparação após a execução do código interno, diferentemente de um \textit{loop} \textit{while} que a executa antes. Ao utilizar um \textit{loop} como comparação após a execução, precisa-se voltar para o início caso a comparação seja verdadeira.
	\item[JUMP\_FORWARD]: é a instrução capaz de incrementar o valor de PC (\textit{program counter} - \pc) com um valor 'DELTA' determinado. Então, se nosso 'DELTA' for 10 e PC estiver com o valor 7, ao utilizar esta instrução, nosso PC passará a ter o valor 17.
	\item[JUMP\_ABSOLUTE]: é a instrução capaz de definir livremente o valor de PC. Ela é utilizada para uma chamada de função, por exemplo, em que o valor de PC deverá assumir o endereço da rotina a ser executada. 
\end{description}

\subsection{Comparações}

As instruções responsáveis por fazer comparações entre dois elementos são utilizadas quando se precisa tomar uma decisão dentro do algoritmo e gerar resultados diferentes dependendo de cada situação. Elas são conhecidas como \textit{if}, \textit{elif} e \textit{else}. 

A primeira, \textit{if}, é a função básica da qual as outras duas dependem. Ela é chamada juntamente com um argumento, o qual é, necessariamente, uma afirmação lógica (maior que, menor que, igual ou ainda um valor que será sempre verdadeiro, tal como 1). Com o resultado dessa afirmação lógica sendo verdadeiro, acontece a execução do código previsto para essa opção, encontrado dentro da estrutura \textit{if}. Caso obtenha-se um resultado falso, é necessário, então, passar para o próximo passo de comparação. Vale lembrar que um \textit{if} pode ou não ser seguido de \textit{elif} ou \textit{else}. \textbf{CITAR LIVRO ALGORITMOS QUE DIGA QUE EXISTE IF SOZINHO} Uma chamada \textit{elif} define que determinada rotina deve ser executada caso a primeira comparação resulte falsa e mediante uma segunda comparação, que deve ser verdadeira. Já a chamada \textit{else} define que a rotina interna a ele deve ser executada caso nenhuma das comparações anteriores seja verdadeira, não precisando-se, portanto, executar uma nova comparação. Caso um \textit{if} não seja seguido por nada e obtendo-se resultado negativo para a comparação, o código contido no no corpo da comparação, que deveria ser executado caso ela fosse verdadeira, é ignorado e o algoritmo segue seu fluxo normal de execução. 

Já quando, após um \textit{if}, encontrase-se um \textit{elif}, significa que, caso a comparação do \textit{if} retorne um resultado falso, testar-se-á novamente, utilizando outra afirmação lógica. Uma chamada \textit{elif} também possui uma rotina de execução que será executada caso tal afirmação seja verdadeira. Caso a afirmação retorne como sendo falsa, o trecho código contido dentro da função é ignorado e passa-se a verificar a existência de outro \textit{elif} ou um \textit{else}.

Caso seja encontrado um \textit{else} após um \textit{elif} ou até mesmo diretamente após um \textit{if}, entende-se que, caso todas as afirmações feitas anteriormente retornem como sendo falsas, deve-se executar o trecho de código presente no \textit{else}. Contudo, é importante salientar que não é necessária a existência de um \textit{else}, visto que alguns algoritmos pretendem executar determinada parte do código somente caso seja verdadeira e, caso contrário, esperam simplesmente ignorar o que foi escrito no corpo da comparação.


A \pvm{} prevê a utilização de uma função de comparação, chamada \textit{COMPARE\_OP}, que passará em seu argumento uma classe de comparação que será feita entre o \tos{} e o elemento encontrado logo abaixo dele. Aliado a essa comparação, é possível sempre encontrar uma instrução que já foi apresentada anteriormente na seção \ref{instr_pulos}. Essa instrução é comumente a \textit{POP\_JUMP\_IF\_FALSE}, podendo ainda ser a inversa dela, e, como já foi descrito aqui, somente funcionará caso a operação anterior a ela retorne um resultado falso. Essa instrução é utilizada para, caso a afirmação feita na comparação retorne como sendo falsa, exista a possibilidade de ignorar o código presente no interior da chamada \textit{if} (em alto nível) e que, em baixo nível, se encontrará logo após o pulo condicional. Após o pulo, existe o conjunto de instruções que deve ser executado caso a comparação seja verdadeira.

\subsection{Operações aritméticas}
\label{op-arit}

Finalmente, o principio de operações aritméticas utilizado para a \vm{} da linguagem \textit{Python} dispõe de instruções binárias, como são chamadas, que executam cálculos utilizando dois operandos \cite{Dubois1996}. Para executar uma instrução deste tipo, é necessário que os dois operandos alvos estejam presentes na pilha e, especificamente, nas duas posições superiores dela.

Tendo em vista que já foram executados os \textit{loads} necessários e que os operandos se encontram nas suas corretas posições na pilha, chama-se uma das instruções responsáveis por cálculos. Falar-se-á sobre as instruções responsáveis pelos cálculos ao final desta subseção.

Como o código \as{} de um algoritmo, em uma situação normal, é definido e montado inteiramente pelo compilador, baseado no que foi escrito pelo programador, cabe a ele também a função de entender o que foi escrito em alto nível e o que o usuário programador deseja obter de resultado, com base no que foi digitado. Na maioria das vezes, as equações matemáticas que são adicionadas em um algoritmo dispõem de mais de dois operandos, fazendo com que se torne menos evidente o que e como deverá ser feito tal cálculo na \vm{}, tendo em vista que o conjunto de instruções da \pvm{} só contém instruções de operações entre dois elementos.

Para resolver tal problema, é necessário entender que cada equação matemática necessita de um conhecimento prévio sobre prioridades de solução para que gere o resultado correto e esperado. Então, independentemente da ordem em que as operações matemática foram escritas na equação de alto nível, é necessário respeitar as prioridades. Quando as instruções escritas em alto nível são enviadas ao compilador para serem convertidas de um código \as{}, é tarefa deste analisar as prioridades e montar a sequência de código de forma que o resultado final seja exatamente o esperado pelo usuário. 

Um exemplo de uma equação matemática simples que necessita respeitar a prioridade de operações é uma soma seguida de uma multiplicação, nessa ordem e sem a presença de parênteses, tal como \(val = val1 + val2 * val3\). Percebemos que a soma está sendo apresentada antes da multiplicação e, ignorando as prioridades, intuitivamente resolveríamos a soma antes e, após, a multiplicação. Contudo, resolver a operação desse modo resultaria em um erro no resultado final. Então, sabendo que uma operação de multiplicação possui maior precedência que uma operação de soma, devemos executar a multiplicação primeiro. A execução de uma operação similar foi apresentada na Figura \ref{img_exemplo_prioridades}, apresentada na subseção \ref{manipulacao_dados}, porém com objetivo em mostrar a ordem em que os dados são carregados para a pilha.

Seguindo as prioridades e utilizando o exemplo acima, podemos esperar que um compilador execute a operação de multiplicação antes da operação de soma. E, como são esperados que existam três operandos distintos, o compilador executa uma operação de carregamento para a pilha (\textit{load}) em todos os operandos. Tal operação deve ser feita na ordem inversa à ordem de prioridade, fazendo com que os operandos na multiplicação fiquem no \tos{} e na posição logo abaixo. Como os operandos da soma são o resultado da multiplicação e um valor, definido no exemplo por \textit{val1}, podemos esperar que o primeiro \textit{load}, feito no inicio da execução, seja na variável \textit{val1}, que se encontrará na posição mais abaixo na pilha. Assim, após realizarmos a multiplicação, teremos que o valor do seu resultado presente no \tos{} e, na segunda posição, o valor de \textit{val1}. Logo, é possível executar uma soma sem que seja necessária nenhuma outra operação de \textit{load} ou \textit{store}.

Quanto ao resultado de uma operação aritmética, tem-se que o resultado estará no novo \tos{}. Isso acontece porque sempre que um dado é carregado da pilha, ou seja, utilizado, ele é automaticamente excluído da mesma. Assim sendo, em uma operação aritmética simples, tendo \textit{val1} e \textit{val2} no \tos{} e na posição logo abaixo dele, respectivamente, exclui-se \textit{val1} e, após, exclui-se \textit{val2}. Quando o resultado é obtido, salva-se seu valor no novo \tos{}, que estará localizado exatamente na posição onde estava \textit{val2}. A Equação \ref{eq_tos} apresenta como são feitas as alocações da pilha. Considere que \textit{TOS} é o \tos{} e \textit{TOS1} é a posição logo abaixo.

\begin{equation} \label{eq_tos}
	TOS1 = TOS1 + TOS
\end{equation}

Observe ainda que, conforme a Equação \ref{eq_tos} mostra, o \tos{} se posiciona como sendo o segundo operando de uma operação. Em uma operação de adição, como a do exemplo, a ordem não importa, pois o resultado será o mesmo de qualquer forma. Já em operações de subtração e divisão, tem-se resultados completamente diferentes com a troca dos operandos de lugar. Então, considere uma operação entre \(r = val1 / val2\). Para que ela funcione corretamente, é necessário carregar \textit{val1} para a pilha e, após, \textit{val2}. Nesse caso, a simples inversão da ordem de carregamento dos dois operandos resultaria em um erro enorme.

As instruções \textit{Assembly} responsáveis por executar operações aritméticas na linguagem \textit{Python} são:

\begin{enumerate}
	\item[BINARY\_ADD]: executa uma operação de soma entre o TOS e a segunda posição da pilha.
	\item[BINARY\_SUBTRACT]: executa uma operação de subtração entre o TOS e a segunda posição da pilha.
	\item[BINARY\_MULTIPLY]: executa uma operação de multiplicação dentre o TOS e a segunda posição da pilha.
	\item[BINARY\_DIVIDE]: executa uma operação de divisão entre o TOS e a segunda posição da pilha.
	\item[INPLACE\_ADD]: \textbf{FALTA EXPLICAÇÃO}
\end{enumerate}

\section{Modos de endereçamento da PVM}
\label{rf_modos_enderecamento}
A linguagem \textit{Python}, possuindo uma máquina virtual, necessita também de um método de endereçamento para que ela consiga funcionar corretamente. Para isso, foi definido pelo desenvolvedor e criador da linguagem que cada endereço lido pela VM deveria conter 2 \textit{bytes} (ou 16 \textit{bits}). 

Então, quando uma instrução é retirada da memória de instruções e lida pelo decodificador, são retirados os 16 \textit{bits} que formam a instrução. A divisão para esses 2 \textit{bytes} é que o primeiro \textit{byte} seja responsável por apresentar o \textit{oparg} da instrução. Ou seja, o primeiro \textit{byte} da instrução é responsável por apresentar o argumento que será passado para a instrução chamada. Ou seja, no caso do exemplo acima, onde é feito um carregamento de uma constante para o topo da pilha, o argumento desta instrução seria o valor da constante expresso em código binário. Ao primeiro \textit{byte}, também podemos chamá-lo de \textit{oparg}. Tal abreveação deriva-se da junção das palavras \textit{operation} e \textit{argument}, que em uma tradução livre, resulta em argumento da operação.

Já os 8 \textit{bits} menos significativos, ou seja, mais à esquerda, são responsáveis por definir o tipo de instrução que será executada no momento da leitura. Apenas lendo o \textit{opcode}, é possível saber que será executada, por exemplo, a instrução \textit{LOAD\_CONST}. A esse segundo \textit{byte}, atribuímos o nome de \textit{opcode}, que trata-se apenas da junção das palavras \textit{operation} (operação, em português) e \textit{code} (código, em português). Tal junção, resulta, através de uma tradução livre, em código de operação.

É importante lembrar que, para algumas instruções, o primeiro \textit{byte} não é utilizado. Isso acontece porque algumas instruções não necessitam utilizar um argumento, pois executam uma funcionalidade específica e independente de qualquer entrada externa. Um exemplo de instrução que não necessita de argumento em sua chamada é a \textit{BINARY\_ADD}, que executa uma soma entre o TOS e a segunda posição. Assim, ao ser identificado o \textit{opcode} que chama tal instrução, ignora-se o segundo \textit{byte} do endereço e segue-se para a execução. 

A Figura \ref{img_endCode} apresenta o formato de um endereço \textit{Python}, contendo o \textit{oparg} primeiro, até o \textit{bit} número 7, e o \textit{opcode} a partir do \textit{bit} número 8 até o final do argumento. 
\begin{figure}[htp]
\centering
\includegraphics{images/bytecodeFormat.png}
\caption{Formato de um endereço binário de 2 \textit{bytes}, retirada do livro (CITAR LIVRO INSIDE PYTHON VIRTUAL MACHINE)}
\label{img_endCode}
\end{figure}

Os endereços \textit{Python} são criados e definidos pelo próprio processador e, ao serem executados em um processador, devem ser salvos na memória de instruções. O compilador, ao ler o código de alto nível e interpretá-lo, monta os endereços e define os melhores endereços para que tudo o que foi escrito funcione corretamente quando for executado. Então, cabe ao compilador atribuir argumentos às instruções de modo que tudo possa funcionar. 

\subsection{OPARG Python}

A primeira parte de um endereço \textit{Python}, onde está contido o arqumento da instrução, contém 8 \textit{bits} e é utilizada para mostrar ao sistema que a operação que será executada utilizará determinado valor especificado neste campo. Todas as instruções contém esse argumento, porém algumas delas não o utilizam para absolutamente nada. A essas instruções, atribuímos a característica de ter um argumento sem importância.

Ao quando o processador percebe que está executando uma instrução que necessita de um argumento, ele imediatamente lê este argumento e o passa para quem é o responsável por ele. Como o argumento pode ser tanto uma constante, que será carregada diretamente para a pilha, ou um endereço de memória, é inviável que o decodificador que fará a leitura da instrução a ser executadá já leia o argumento e o repasse. Por isso, todas as decisões sobre pegar ou não o argumento, assim como outras decisões mais sensíveis dentro da execução, são feitas dentro do controle. A seção \ref{end_controle} abordará, em detalhes, o funcionamento de um módulo de controle de um processador e fará relação como deverá ser projetado um controle para um processador \textit{Python}

O campo argumento, então, é utilizado única e exclusivamente para mostrar ao processador que existe uma entrada de dados externa ou algo que foi solicitado anteriormente. Ao executar-se uma compilação de um algoritmo \textit{Python}, o próprio compilador já cria os endereços e, a eles, já adiciona os argumentos. (\textbf{INCOMPLETO E TALVEZ INCORRETO - REVISAR!})

\subsection{Opcode Python}



\section{Código Assembly da linguagem Python}

\section{Controle para um processador Python}