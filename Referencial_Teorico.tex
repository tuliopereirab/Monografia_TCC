A linguagem \textit{Python} \cite{Rossum2008} é considerada uma linguagem de programação interpretada \cite{Sanner1999}. Isso significa que, ao invés de seus \textit{bytecodes}, quando executados, serem enviados para que o processador físico da máquina onde o algoritmo irá ser executado execute cada uma de suas instruções, um interpretador assume essa responsabilidade e executa em \textit{software} o que seria executado pelo \textit{hardware} e, consequentemente, esse \sw{} é executado em \hw{}. Contudo, tal interpretador é implementado em uma linguagem que irá executar diretamente no processador físico do sistema utilizado. O \textit{Python} utiliza como interpretador a ferramenta \textit{CPython}, que foi criada especificamente para ser capaz de cumprir tal tarefa corretamente. Ela foi desenvolvida pelo mesmo criador da linguagem e escrita na linguagem de programação C \cite{PythonLanguageReference}.

O interpretador \textit{Python}, \textit{CPython}, pode ser tratado como uma máquina virtual, visto que ele recebe os \textit{bytecodes} de determinado algoritmo e executa dentro de si próprio. Conforme descrito na seção \ref{cpython_func}, pode-se entender como é feita execução de determinado algoritmo através do interpretador. Assume-se, então, que tal interpretador seja tratado especificamente como uma máquina virtual (VM) daqui para frente neste trabalho, já que ele possui todas as características de uma \cite{Goldberg1974}.

A grande vantagem de se utilizar uma linguagem interpretada, ou seja, baseada em uma máquina virtual, é o fato de que qualquer algoritmo escrito na linguagem pode ser executado em qualquer \textit{hardware}, desde que exista uma implementação da máquina virtual para tal \textit{hardware} \cite{Rosenblum2004}. Isso evita que o mesmo algoritmo tenha de ser convertido para outras linguagens de programação ou recompilado para cada sistema onde deverá executar.

\section{A linguagem \py{}}
\label{ling_python}

A linguagem \py{}, como dito anteriormente, teve sua primeira aparição no ano de 1990. Ela é uma linguagem interpretada, com seu interpretador principal e básico sendo o \cpy{}, que será apresentado na seção \ref{cpython_func}. 

Segundo \citeonline{Sandler2018}, que escreveu para a revista \textit{Business Insider}, a linguagem \py{} aparece na sétima posição em uma lista das 14 linguagens mais populares, de acordo com 100 mil desenvolvedores. Isso mostra que a linguagem está muito próxima de linguagens como \textit{Java} \cite{Grand1997}, a qual aparece na quinta posição e é muito conhecida, principalmente, por permitir a criação de algoritmos que possam ser executados nos mais variados dispositivos. A lista também mostra a enorme difusão de linguagens voltadas à aplicações para \textit{Internet} (\textit{web}), tendo, em suas três primeiras posições, linguagens como \textit{Javascript} \cite{Flanagan2006}, HTML (\textit{HyperText Markup Language}) \cite{Lloyd2008} e \textit{Cascading Style Sheets}, conhecida como CSS \cite{Bos2011}.

Ainda sobre a lista publicada pela revista, muitos dos desenvolvedores entrevistados acreditam que \py{} é a melhor e mais fácil linguagem para que uma pessoa que nunca programou, mas gostaria de ingressar na área, começar. Segundo eles, ela é uma linguagem com alta facilidade de leitura, podendo ser entendida facilmente. Isso se dá, além de outros fatores, pela simplificação na declaração de variáveis, já que a linguagem é fracamente tipada. %onde o usuário não precisa entender onde é aplicado cada tipo de variável para que consiga programar. Na maioria das linguagens, define-se um tipo de variável para cada funcionalidade. Já em \py{}, basta o usuário utilizar uma variável, mesmo sem declará-la, que o compilador a reconhecerá e permitirá que os dados sejam salvos nela, sem restrição sobre tipo (\textit{int}, \textit{float}, \textit{char}).

\subsection{Aplicações para a linguagem \py{}}

A linguagem \py{}, por ser uma simples e poderosa linguagem orientada a objetos \cite{Lutz2007}, é utilizada, também, a para diversos fins que envolvam algoritmos complexos. Diversas áreas utilizam algoritmos \py{} para resolver problemas e executar cálculos que exigem grande poder computacional.

Uma das áreas é a biológica, chamada também de bioinformática, que utiliza \py{} para criar ferramentas computacionais aplicadas à biologia molecular \cite{Cock2009}. Outras aplicações que utilizam \py{} dentro da bioinformática são a filogenética \cite{Sukumaran2010} e sequenciamento de alto rendimento \cite{Anders2015}. Essas duas últimas possuem bibliotecas que visam facilitar implementações de algoritmos para fins específicos dentro de cada área.

Outras áreas da ciência que podem ser citadas por utilizarem \py{} para criação de seus algoritmos são a sismologia, que possui uma biblioteca que permite facilitar a implementação de algoritmos \cite{Beyreuther2010}, a exploração de árvores \cite{Huerta-Cepas2010} e a neurociência \cite{Peirce2007}.

Voltando para a computação sem foco em alguma área específica, pode-se citar aplicações de \py{} em algoritmos voltados para a \textit{web}, tal como \cite{Forcier2008}, inteligência artificial (\textit{Machine Learning}) \cite{Pedregosa2012} e \textit{Data Science} \cite{Grus2015}. Dentro da matemática, também, a ferramenta \textit{Matlab} possui suporte a algoritmos \py{} \cite{MathWorks2015}.

Por último, pode-se citar como uma aplicação para a linguagem \py{} a possibilidade de descrever arquiteturas físicas, tal como a linguagem VHDL faz. Segundo \citeonline{Villar2011}, isso pode ser feito por meio um pacote chamado \textit{MyHDL}, o qual consegue converter um código \py{} em VHDL, gerando uma arquitetura que pode ser simulada com a ajuda dos mesmos simuladores utilizados para implementações VHDL nativas.

\subsection{Máquina Virtual da linguagem \py{} em \textit{Hardware}}
\label{pvm_hardware}
Ao testar os mesmos sistemas em \sw{} ou em \hw{}, é possível obter-se resultados bem variados, dependendo do sistema \cite{Adams2006}. Na maior parte dos casos, com algoritmos que exigem maior poder computacional e que precisam ser executados em um tempo pré-determinado, são utilizados sistemas em \hw{}. É sabido que um sistema físico, \hw{}, consegue executar mais rapidamente aplicações complexas \cite{Grevera2000}. Isso acontece porque, quando se executa um sistema em \sw{}, existem diferentes tratamentos de dados e envio das instruções para um processador físico executar, que passam pelo sistema operacional e outros tratamentos, dependendo da linguagem utilizada. Assim, ocorre um significativo aumento sobre tempo de executação, gerando um desempenho inferior. 

Desta forma, quando se adiciona ainda outra camada de \sw{}, como a linguagem \py{} possui, que é a \pvm{}, o desempenho diminui consideravelmente, fazendo com que sistemas de elevada complexidade que necessitam obrigatoriamente respeitar tempos pré-definidos, sofram falhas significativas. Contudo, ao analisar-se a reportagem apresentada na subseção inicial dessa seção, percebe-se que as linguagens de programação mais utilizadas hoje em dia são as interpretadas. Isso se deve ao fato de que elas possuem grande portabilidade, podendo ser executadas em inúmeros sistemas físicos, alguns completamente diferentes de outros, com o mesmo algoritmo compilado (mesmos \bc{}) \cite{Ngo1997}.

Um grande exemplo disso são sistemas de pequenas empresas ou \textit{startups} que não possuem suporte a todos os sistemas possíveis. Então, ao implementar, por exemplo, um sistema de \textit{Machine Learning} em \textit{Java}, o mesmo código compilado poderá rodar em um sistema \textit{Linux}, \textit{Windows} ou, até mesmo, em \textit{Android}. Isso faz com que a empresa não precise gastar tempo e dinheiro para desenvolver sistemas totalmente diferentes para cada tipo de dispositivo e, tampouco, perder mais tempo ainda para atualizar cada um deles separadamente. Basta desenvolver um sistema em uma linguagem com alta portabilidade e atualizar esse mesmo sistema, que diferentes dispositivos poderão usufruir das funcionalidades. 

Porém, mesmo com a grande vantagem que a alta portabilidade traz para linguagens interpretadas, existe um grande problema: desempenho. Em aplicações leves e simples, esse problema raramente poderá ser perceptível. Porém, quando é executada uma aplicação que exige maior poder computacional ou sensível ao tempo, podem ocorrer falhas ou atrasos enormes. Quando se juntam as duas categorias de aplicações, complexa e sensível ao tempo, então, pode-se obter um resultado desastroso. 

Quando se executa algo em um sistema implementado em \hw{}, as entradas do sistema são preenchidas e o resultado pode ser visto em uma das saídas com um intervalo baseado, praticamente, no tempo que a energia demorou para percorrer o circuito, passando por todos os componentes utilizados. Cada componente gera um atraso de configuração (\textit{setup}) e propagação, interferindo significativamente no tempo final de execução, já que são esses atrasos que definem a frequência de execução máxima que o sistema suporta e define, por consequência, o período do sistema, chamado de tempo de \textit{clock}.

Com o propósito de acelerar sistemas críticos, são criados aceleradores com o propósito de executar determinada funcionalidade do sistema em \hw{}, para que ela seja executada mais rápido e possa estar pronta quando outras partes do código precisarem do seu resultado, respeitando, portanto, tempos. A esse tipo de implementação, dá-se o nome de \textit{Codesign} \cite{Wolf2003} A parte que é implementada em \hw{}, geralmente, é uma parte crítica do código, onde são feitas diversas operações complexas e com grandes repetições, sendo necessário muito tempo. Caso uma parte seja erroneamente escolhida para ser implementada em \hw{}, o resultado pode ser pior do que o inicial \cite{Ewins1997}. Portanto, antes de se criar um acelerador para um sistema, é essencial que seja escolhida a parte crítica do sistema, onde ele necessita mais tempo executando, para que o \hw{} consiga impactar positivamente no desempenho geral.

Para \textit{Java}, existem diversas propostas de arquiteturas físicas que visam implementar as linguagens de programação baseadas em máquinas virtuais diretamente em \hw{}, visando melhorar o desempenho. Uma delas, a \textit{picoJava-I}, por exemplo, que será apresentada detalhadamente na seção \ref{trab_correlatos} e que foca em algoritmos de tempo real. 

\subsection{Descrição de \hw{} utilizando VHDL}
\label{desc_hw_vhdl}
A linguagem VHDL é uma linguagem de descrição de \hw{}, ou seja, em vez de gerar \bc{} para serem executados em um processador, como em linguagens de programação, ela é lida por um sistema específico que, a partir de determinado algoritmo, gerará a descrição de uma arquitetura em portas lógicas capaz de executar o que foi escrito. A linguagem VHDL foi desenvolvida, inicialmente, em 1983 pelo Departamento de Defesa dos Estados Unidos, que estava pesquisando meios de se criar equipamentos eletronicos e simular um sistema antes mesmo de ser feito fisicamente \cite{U.SDepartamentofDefense1992}. 

Sua funcionalidade é bem diferenciada em comparação a linguagens de programação \cite{Shahdad1986}. Uma das grandes diferenças está no fato de que a linguagem VHDL executa cada linha de código, por padrão, em paralelo, enquanto linguagens de programação, para gerar tal funcionalidade, é preciso utilizar \textit{threads}. Então, caso seja preciso executar um bloco de código sequencialmente, é preciso iniciar um processo específico para tal fim. Algumas estruturas, como \textit{if}, necessitam serem executadas sequencialmente \cite{Navabi1997}.

Para a criação, compilação e simulação dos código escritos em \textit{VHDL}, será utilizada, nesse trabalho, uma ferramenta da empresa Altera, que foi comprada pela Intel, chamada \textit{Quartus} \cite{quartusIntel}. Tal ferramenta permite criar arquiteturas em VHDL e Verilog, outra linguagem de descrição de \hw{}, compilar essas arquiteturas e ainda testá-las, obtendo, então, dados de performance, gasto energético e área ocupada pela arquitetura \cite{quartus2018}. 

Para melhor realizar simulações, obtendo mais detalhes, será utilizada a ferramenta pertencente à mesma empresa e chamada de \textit{Modelsim} \cite{MODELSIM}, que permite realizar uma análise de sinais internos à arquitetura, enquanto a primeira ferramenta só permite visualizar a saída final. %Muitas vezes, apenas analisando uma saída de arquitetura não é possível identificar um problema, visto que pode haver um problema em um sinal interno específico que não fosse esperado. Então, é preciso ter acesso a esses sinais e analisá-los, na ocorrência de um problema, com calma e atenção, para que o problema possa ser solucionado. 

%Após obter-se uma arquitetura funcional e que consiga executar corretamente tudo o que era esperado durante as simulações, é possível retornar à primeira ferramenta e configurá-la para que a arquitetura seja prototipada em um FPGA (\textit{Field-programmable gate array}). Tal sistema é uma placa, parecida com um processador convencional, que é capaz de montar caminhos físicos no seu interior, entre seus blocos, que simulam fisicamente uma arquitetura descrita por uma linguagem de descrição de \hw{}. Uma grande característica de um FPGA é que ele pode ser reprogramado quantas vezes for preciso, não precisando, portanto, ser descartado após uma utilização. Com ele é possível testar uma arquitetura física, sem precisar realmente criar fisicamente um \textit{chip} com as especificações descritas necessárias e testá-lo, algo que demoraria em torno de 3 meses para ser concluído e teria que ser feito todo o processo novamente em caso de problemas. 

\section{Trabalhos Correlatos}
\label{trab_correlatos}

Tendo em vista os pontos vantajosos de se desenvolver uma arquitetura em \hw{} capaz de executar fisicamente o que era executado em \sw{}, como dito na subseção \ref{pvm_hardware}, foram desenvolvidos alguns trabalhos com o mesmo propósito desse. Os trabalhos correlatos analisados no desenvolvimento deste projeto são apenas relacionados à linguagem \java{}, os quais possuem a mesma teoria de desenvolvimento empregada nesta proposta.

As linguagens \java{} e \py{} são semelhantes em alguns pontos: ambas utilizam máquinas virtuais para executar seus \bc{}, possuem operações de dados baseadas em uma pilha, possuem estrutura orientada a objetos, entre outras semelhanças. Também possuem, obviamente, diferenças, tal como, por exemplo, a taxa de utilização da memória na linguagem \java{} ser maior do que na linguagem \py{}. Uma comparação completa entre as duas linguagens e algumas outras foi feita por \cite{Prechelt2000}. 

Então, sabendo que existem diversas semelhanças nos modos de funcionamento das linguagens \java{} e \py{}, é possível analisar trabalhos realizados com o objetivo de transformar a Máquina Virtual \java{} em uma arquitetura física. Os trabalhos abaixo apresentados possuem objetivos específicos, focando em determinados nichos de implementação para resolver um problema específico. Este trabalho, porém, possui o objetivo de desenvolver um sistema que consiga executar algoritmos \py{} básicos, não sendo, portanto, focado em nenhuma área específica.  

\subsection{picoJava-I}
\label{pico}
O primeiro trabalho analisado pertence a \citeonline{OConnor1997}, que desenvolveu a arquitetura \textit{picoJava-I}. Seu trabalho é uma proposta de arquitetura que visa executar algoritmos escritos em \java{} diretamente em \hw{}. Seu objetivo específico é permitir a execução de, praticamente, qualquer algoritmo escrito em \java{} em \hw{}.

Para iniciar sua análise, ele apresenta diversos dados mostrando as taxas de execução de cada classe de instruções. Com esses dados, é possível perceber que grande parte das operações executadas são de gerenciamento de dados, sendo o carregamento de variáveis locais sendo executada 34,5\% das vezes, seguida por carregamentos vindos da memória, que é executada em 20,2\% das vezes. 

A arquitetura proposta por ele possui um \textit{pipeline} no estilo \textit{RISC} (\textit{Reduced Instruction Set Computer}) e é baseada em pilha. Foram implementadas, portanto, apenas instruções que realmente causam impactos na execução de um algoritmo \java{}, tendo como objetivo melhorar o desempenho da linguagem. Seu conjunto de instruções dispõe de 341 instruções. Algumas instruções, as quais não foram implementadas diretamente em \hw{}, foram postas para funcionar em \sw{} juntamente com a arquitetura. A essa técnica de mesclar implementações em \hw{} com outras em \sw{} atribui-se o nome de \textit{Codesign}. 

Para realizar os testes de suas arquitetura, foi definida uma frequência de 100 MHz, sendo que essa não é a frequência máxima esperada para o resultado final, apenas para os testes. Foram rodados \textit{benchmarks}, tais como \textit{Javac} e \textit{Raytracer}. Os resultados da execução utilizando a arquitetura proposta e os métodos de execução padrões da linguagem \java{} foram comparados, podendo-se perceber que a arquitetura permitiu uma economia significativa de tempo para a execução.

\subsection{JAIP-MP}
\label{jaipmp}
O segundo trabalho, proposto por \citeonline{Tsai2015a}, é um processador de quatro \textit{cores} feito para executar algoritmos escritos em \java{}. Foi atribuido à arquitetura o nome de JAIP-MP (\textit{Java Application IP - Multi-core Processor}).

Nesse trabalho, a arquitetura implementada permite carregamentos dinâmicos de classe e execução dupla de \textit{bytecodes}, permitindo que duas instruções sejam executadas simultaneamente em cada núcleo do processador (\textit{core}). Além disso, foram implementados métodos de utilização da memória \textit{cache} para o funcionamento de objetos, tais como utilizados na linguagem \java{}. Ou seja, é possível alocar objetos diretamente na memória e manipulá-los. Com a possibilidade de execução simultânea de instruções, é possível perceber o uso de \textit{multithreading} por parte da arquitetura proposta. 

Para a realização dos testes, foi definida uma frequência de 83,3 MHz e utilizada a ferramenta de síntese Xilinx XST 13.4. Os resultados apresentados pelo autor são separados por componentes específicos e funcionalidades específicas. Dentre suas conclusões, é dito que a arquitetura proposta é eficiente e a técnica \textit{multithreading} permitiu um ganho em comparação com as execuções padrões da linguagem \java{}.

\subsection{JOP - \textit{Java Optimized Processor}}
\label{jop}
O autor \citeonline{Schoeberl2008} propôs uma arquitetura de um processador \java{} que visa a execução de sistemas embarcados de tempo real. À sua arquitetura, foi dado o nome de JOP. 

Nela, é possível perceber técnicas utilizadas para melhorar o desempenho, tais como utilização de \textit{pipelines}, \textit{caches} e predição de desvios. JOP é classificada pelo autor como uma arquitetura RISC e baseada em pilha. Suas instruções são otimizadas para o funcionamento juntamente com os \textit{bytecodes} \java{}. É uma arquitetura considerada como "completamente \textit{pipeline}", por ser executada tal técnica em todas as execuções feitas nela.

Para a obtenção de resultados referentes à performance, não foram utilizados \textit{benchmarks}, visto que sua utilização em sistemas embarcados é problemática. Então, para obter resultados, foi utilizada a própria aplicação para a qual o sistema foi projetado. Foi definido a priori que a frequência de operação da arquitetura JOP seria de 100 MHz nos testes. É possível perceber, através dos dados disponibilizados pelo autor, que sua arquitetura apresenta grande eficiência quando comaparada a outras que visam o mesmo tipo de execução.  

\subsection{JAIP}

Esse trabalho, proposto por \citeonline{Tsai2015}, apresenta uma arquitetura de baixo custo, baseada em memória de pilha e manipulação de exceções. Seu trabalho apresenta uma execução dupla de instruções utilizando técnicas de \textit{pipelining} e \hw{} de baixa complexidade, segundo o autor. Esse trabalho está relacionado com o trabalho apresentado na subseção \ref{jaipmp}, o qual pertence ao mesmo autor. 

Sendo um sistema embarcado, esse trabalho define a utilização de uma classe \java{} dinâmica integrada, através de \textit{buffers}, com um \textit{core} \java{}, classificado como uma arquitetura RISC. Em outras palavras, esse trabalho visa executar algoritmos em \java{} utilizando, como ponto de partida, um \sw{} e \textit{buffers}, conectado a uma arquitetura RISC. Para a execução dos algoritmos, são utilizados os próprios \textit{bytecodes} da linguagem \java{}.  

Nessa publicação, o autor realiza uma comparação do seu processador e os processadores apresentados nas subseções \ref{pico} e \ref{jop}, utilizando o \textit{benchmark} \textit{JemBench}. Nessa apresentação, pode-se perceber que, dependendo do algoritmo testado, os resultados variam bastante. Portanto, não é possível definir qual arquitetura possui o maior desempenho. Um dos resultados apresentados, por exemplo, é para a execução do algoritmo denominado \textit{Sieve} (algoritmo capaz de encontrar números primos até certo valor definido como limite) \cite{ONEILL2009}. Com esse algoritmo, é possível obter a classificação, respectivamente: \textit{picoJava-I}, \textit{JAIP} e \textit{JOP}. 

\subsection{Visão Geral}

Apresentados os trabalhos correlatos acima, pode-se perceber que todos eles possuem como objetivo a implementação de sistemas em \hw{} baseados na linguagem \java{}. Esse trabalho, porém, utiliza como alvo a linguagem \py{}. 

Comparando as especificações desse trabalho com as dos trabalhos apresentados, pode-se esperar a implementação de uma arquitetura com um número reduzido de instruções, em comparação ao número apresentado pela arquitetura \textit{picoJava-I} (\ref{pico}), por exemplo. Isso se dá pelo fato desse trabalho necessitar ser desenvolvido em um tempo reduzido, não permitindo a implementação de diversas funcionalidades. 

Quanto a utilização de técnicas \textit{pipelining} nesse trabalho, ainda não existe uma posição concreta, visto que poderão ser implementadas no período de aperfeiçoamento. Já técnicas \textit{multithreading} estão descartadas devido à grande complexidade necessária para esse tipo de funcionalidade. 

Espera-se, desse trabalho, que a execução dos algoritmos escritos em \py{}, tal como todos os trabalhos acima, utilize os \textit{bytecodes} da linguagem como método de entrada. Podendo-se, também, esperar até uma execução automática em \hw{}, recebendo arquivos compilados diretamente do compilador \py{} e os executando na arquitetura. 

Através das análises feitas, é possível perceber uma grande semelhança entre o trabalho apresentado na subseção \ref{pico}, picoJava-I, e este, visto que ambos visam desenvolver uma arquitetura sem um foco específico de execução. Nesse trabalho, são implementadas instruções que são capazes de executar inúmeros algoritmos escritos em \java{}. O objetivo da arquitetura apresentada nesse trabalho é, assim como na picoJava-I, executar algoritmos variados escritos em \py{}. 

\section{Funcionamento CPython}
\label{cpython_func}

A máquina virtual \textit{Python}, com a sua implementação original chamada de \textit{CPython} \cite{designCompiler}, baseia-se no uso de uma pilha para permitir a execução de diversas funcionalidades nos componentes do processador. Para executar qualquer instrução que necessite utilizar dados que virão da memória onde ficam armazenadas as variáveis, é preciso que essa pilha salve estes dados no seu topo para que, então, a próxima instrução possa ser chamada e possa utilizar os dados. Para falar sobre o topo da pilha, utilizar-se-á a sigla TOS (top of the stack), que também é utilizada em documentos que descrevem o funcionamento do interpretador \cite{pythonMachine}. 

A pilha do \cpy{} é capaz de suportar qualquer tipo de dados que a linguagem \py{} permite. Tal pilha é a responsável por guardar todos os dados que forem carregados, vindos da memória ou de fonte externa (carregamento de constante), com o objetivo de serem executados em determinados componentes do processador, sendo valores constantes (que estejam entrando no sistema pela primeira vez) ou variáveis (que já foram carregados anteriormente como constantes e salvos na memória). Assim como uma pilha padrão, existe um ponteiro que sempre aponta para a primeira posição da pilha (a posição que se encontra no topo da pilha e que contém o último dado que foi inserido). 

Quando se retira um dado da pilha, deve-se modificar o \tos{}, realizando uma subtração. Logo, por ora, é importante saber que, ao remover um elemento, é necessário que o \tos{} passe a apontar para a posição abaixo, já que o primeiro elemento (\tos{}) será excluído da pilha. Os exemplos típicos de instruções que modificam o TOS durante as execuções podem ser quaisquer operações aritméticas, que falar-se-á aprofundadamente na subseção \ref{op-arit}. 

Assim como os códigos \textit{Assembly} de outros processadores, como MIPS \cite{Sweetman2006}, Neander e suas variantes \cite{Weber1998}, os da linguagem \textit{Python} são organizados e intuitivos, já que alguém que possua um conhecimento básico sobre o funcionamento de uma linguagem de baixo nível conseguirá observar diversas familiaridades com outros códigos. %Porém, existem diversas instruções que são próprias da linguagem \textit{Python} e que servem para propósitos bem específicos na execução de algum algoritmo, assim como outras que são semelhantes as de outros processadores mas apresentam outros nomes. 

Note que a comparação direta do código \textit{Assembly} \textit{Python} que tenha como objetivo executar em qualquer processador pode ser feita somente porque o \textit{Python} utiliza uma \vm{} que trabalhará como um processador auxiliar na execução dos algoritmos. Ou seja, fará com que um código \as{} padrão execute em qualquer \hw{} sem a necessidade de uma recompilação. Em outras linguagens, como C, não se pode realizar tal feito, visto que o compilador irá converter o código \as{} baseado no conjunto de instruções (ISA) do processador alvo da execução e não baseado em um conjunto fixo da linguagem, assim o código \as{} poderá executar diretamente no \hw{}, sem utilizar uma \vm{}. Como exemplo, pode-se citar o caso de um algoritmo escrito em C sendo executado em processadores desenvolvidos pela Intel, que possuem ISAs bem específicas, e o mesmo algoritmo sendo executado em processadores AMD. Para que seja possível essa troca de processadores, é necessário que o algoritmo inicial seja recompilado utilizando um compilador próprio para seu processador, o qual transformará o código em alto nível em um código \as{} baseado na sua ISA. Já quando fala-se de \py{}, tem-se que o mesmo código \as{} podendo rodar em processadores de ambas as empresas sem haver a necessidade de ser executada uma nova compilação. Isso torna o \py{} uma linguagem com alta portabilidade  \cite{Watters1996}.  

Conquanto, é necessário notar que, ao transformar a \pvm{}  em um circuito digital implementado em \textit{hardware}, serão necessárias várias modificações, visto que existem muitas diferenças entre as abstrações de como um \sw{}  é executado e como um \hw{} é executado. No que diz respeito a manipulação de \textit{bytecodes} e endereçamentos, a \vm{} utiliza funcionalidades específicas de um \sw{}, tais como gerenciamento simples de \textit{strings}, não podendo, portanto, serem utilizadas tão facilmente em \hw{}. Muitas das características que serão abordadas aqui vieram de \cite{insidePVM}.

Atualmente, o interpretador \cpy{}, sendo ele implementado em \sw{}, utiliza diversas funcionalidades que facilitam sua implementação e que só são possíveis de serem utilizadas porque uma linguagem de programação de alto nível possibilita isso. Dentre as funcionalidades, é possível citar um modo simples de endereçamento, podendo utilizar, inclusive, o código \as{} com instruções escritas em alto nível em vez de instruções expressas em código binário. Já implementar o mesmo sistema em \hw{} exige que o problema seja analisado com um menor nível de abstração e que, baseado no exemplo dado, seja definida uma codificação binária, que o um sistema físico não conseguirá ser capaz de ler e reconhecer letras e palavras. 


\section{Instruções básicas de funciomento da linguagem Python}

Como parte deste trabalho, foram feitas análises utilizando algoritmos escritos em \py{} para gerar, através de uma ferramenta da própria linguagem, chamada \textit{Disassembler}, o código \asp{}. Isso foi feito com o objetivo de identificar instruções que são essenciais  para executar algoritmos em \textit{Python}.

Como algoritmos que foram utilizados para realizar tais análises, pode-se citar códigos que executam diversas operações aritméticas, comparações e pulos através do código. Como já era esperado, nenhuma das funções que são chamadas na linguagem de alto nível pode ser vistas no baixo nível. Em todas as vezes, determinado comando em alto nível é dividido em cinco ou até mais instruções de baixo nível. Isso se deve ao fato de que a \vm{}, mesmo sendo implementada em \sw{}, simula um processador, o qual não é capaz de executar um bloco complexo de instruções em um único módulo. Em outras palavras, um processador possui instruções simples que visam melhorar o desempenho na execução de qualquer aplicação e diminuir a memória de programa ocupada pelo processador, quando o mesmo é implementado por \sw{}, como o \cpy{}. Para exemplificar, caso fosse adicionado em um processador um módulo que fosse responsável somente por executar uma equação matemática inteira de uma só vez, tal instrução seria extremamente grande, complexa e, além disso, ocuparia grande área pra executar uma pequena taxa de vezes, já que a mesma equação não será executada sempre. Por isso, os processadores utilizam instruções que executam funcionalidades básicas distintas e, de certa forma, simples, para evitar que determinada instrução se torne o ponto fraco do processador, consumindo maior área e diminuindo a frequência de operação de todos os componentes. 

Assim sendo, a \pvm{} possui instruções bem definidas e de propósitos específicos. Juntando determinada sequência delas, é possível montar uma instrução de alto nível. Dessarte, pode-se então entender como é feita a programação em \textit{Assembly}, que se baseia em um conhecimento prévio do conjunto de instruções de determinado processador ou, neste caso, \vm{}, e, após, uma montagem de um algoritmo que execute determinada função, presente nas linguagens de alto nível, em vários passos simples de serem executados individualmente.

A linguagem \textit{Python} dispõe de inúmeras instruções, sendo que a maioria delas não será apresentada neste trabalho. As instruções que foram escolhidas para uma análise mais aprofundada no âmbito deste presente estudo estão apresentadas nas seções a seguir, juntamente com suas funcionalidades básicas. Todas as instruções existentes na linguagem \py{}, juntamente com suas funcionalidades, podem ser encontradas na documentação oficial da linguagem \py{} \cite{Python2017}. 

\subsection{Carga e armazenamento de dados}
\label{manipulacao_dados}
Instruções de manipulação de dados podem ser consideradas de grande importância na maioria dos conjuntos de instruções, tendo em vista que a principal funcionalidade de qualquer algoritmo é computar dados de inúmeros formatos. Logo, é sempre necessário que os dados possam ser acessados e alocados na memória da máquina onde o algoritmo está sendo executado. 

A utilização das instruções de carga e armazenamento de dados geralmente ocorre imediatamente antes e imediatamente após a manipulação de determinado dado ou conjunto de dados. Isso acontece porque, na maioria das vezes, o processador precisará destes dados em uma memória que seja rápida o suficiente para que possa ser lida e escrita por ele na mesma velocidade em que ele trabalha. Então, para essa finalidade, utilizam-se registradores dentro do próprio processador, que são extremamente rápidos, porém possuem baixa capacidade de armazenamento e elevada volatilidade, podendo haver perdas de dados com quedas ou oscilações de energia. Então, quando se necessita executar, por exemplo, uma operação aritmética de soma, carrega-se as duas variáveis (dados) para os registradores na ordem em que o compilador definiu, com base no que o usuário escreveu em alto nível. Tal modo de carregamento só é possível porque trata-se de um algoritmo baseado em pilha, não sendo necessário utilizar qualquer tipo de argumento para definir quais serão os operandos da operação. Arquiteturas baseadas em bancos de registradores necessitam de endereços informando quais serão os dados que precisam ser lidos e utilizando-se pilha, sabe-se que sempre o topo dela está sendo lido.

Quando o código assembly não é desenvolvido diretamente pelo programador, a escolha das instruções e a ordem de presença delas no código é feita pelo compilador na hora em que ele lê determinado comando em alto nível e decide quebrá-lo em várias instruções. Então, para exemplificar, um compilador lerá, no caso do \py{}, uma linha de código de alto nível de atribuição de valor a uma variável a partir de uma soma entre duas outras variáveis e a dividirá em dois carregamentos de variáveis, uma soma e um salvamento na memória. No caso da linguagem \py{}, como o compilador foi feito especialmente para trabalhar com uma pilha, ele já tem definido a ordem certa de carregar cada operando da operação, visando que os resultados a cada operação fiquem estrategicamente posicionados na pilha para servirem, quando necessário, para outras operações. Logo, a correta ordem de carregamentos das variáveis é crucial para que o resultado saia como era esperado. A Figura \ref{img_exemplo_pilha} mostra uma instrução (a), o carregamento das variáveis na pilha (b), a obtenção do resultado retornado na pilha (c) e, posteriormente, o salvamento do resultado na memória (d). Em equações mais complexas, onde existem, por exemplo, parênteses que tornam operações internas mais importantes que outras, é necessário que o compilador consiga percebê-los e que monte o código \as{} de forma que as operações internas sejam atendidas corretamente, gerando um resultado prático como foi esperado. 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/exemplo_pilha.png}
\caption{Exemplo de carregamento de dados de uma equação para a pilha.}
\label{img_exemplo_pilha}
\end{figure}

Portanto, sempre que o compilador necessita traduzir uma operação aritmética, ele visualiza as prioridades da mesma e faz com que instruções de carregamento dos dados estejam posicionadas na ordem certa. Como os dados da \pvm{} executam dentro de uma pilha, existe uma ordem específica para que os dados sejam adicionados na pilha, já que a mesma irá retirar sempre o último dado primeiro. Então, como ver-se-á na seção \ref{op-arit}, operações aritméticas executam sempre entre os dois dados no \tos{}. Logo, dados que estejam entre parênteses, por exemplo, serão os últimos a serem carregados, pois precisarão estarem mais ao \tos{} do que os demais. Pode-se dizer, então, que a ordem de carregamento de dados para a pilha é inversa à ordem de prioridade, sendo o primeiro a ser carregado aquele que apresenta a menor prioridade.

Após todos os carregamentos concluídos, são feitas as chamadas de funções aritméticas, por exemplo, na ordem idêntica à de prioridade. Tal fato ocorre porque, como as primeira e segunda posições da pilha contêm os dois operandos da operação de maior prioridade, como dito anteriormente, sua operação deverá ser executada antes de qualquer outra. Então, a terceira e a quarta posições possuem elementos cuja operação tem precedência igual ou inferior à operação a ser executada sobre os elementos da primeira e segunda posição (respectivamente, o topo e o pré topo). Seguindo a ordem de prioridade até que todas as instruções tenham sido executadas. A Figura \ref{img_exemplo_prioridades} apresenta a execução de uma equação que possui uma multiplicação e uma soma. Em (a), é apresentada a equação; em (b), aparecem todos os três valores carregados para a pilha; em (c), a pilha aparece com dois valores, pois já foi executada a operação de multiplicação (que possui prioridade superior à soma) e; em (d) pode-se observar que só existe o valor final da equação, após a realização da soma entre o resultado da multiplicação e o terceiro valor.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.6]{images/exemplo_prioridades.png}
\caption{Exemplo de uma operação, através da pilha, de uma equação com três operândos e prioridades diferentes.}
\label{img_exemplo_prioridades}
\end{figure} 

Após obter-se o resultado da equação matemática no \tos{}, é então chamada uma instrução que deverá salvar o conteúdo do \tos{} em uma posição da memória para que ela fique acessível para possíveis outras utilizações. Note que a definição das ordens de prioridades é feita completamente pelo compilador da linguagem \py{}, sendo necessário, somente, que o usuário programador especifique corretamente as prioridades de uma operação os sinais adequados.

As instruções de carga e armazenamento de dados da linguagem \textit{Python} são:

\begin{description}
	\item[LOAD\_CONST]: é a instrução responsável por carregar um valor para a posição TOS. Seu uso ocorre, na maioria das vezes, quando é preciso definir o valor de uma variável inicialmente para, após, salvar tal variável na memória. 
	\item[LOAD\_FAST]: é a instrução capaz de carregar, diretamente da memória, o conteúdo de uma variável que foi previamente salva. Seu argumento indica a posição de memória que será lida para que o conteúdo seja carregado direto para o \tos{}.
	%\item[LOAD\_GLOBAL]: \textbf{FALTA APROFUNDAMENTO TEÓRICO}
	\item[STORE\_FAST]: é a instrução responsável por levar o conteúdo do \tos{} para uma posição específica da memória. Ela recebe como argumento o endereço de memória onde o dado será salvo. 
\end{description}

\subsection{Pulos (jumps)}
\label{instr_pulos}

As instruções que são responsáveis por executar saltos (\textit{jumps}) dentro do código visam otimizar determinada tarefa, permitindo que haja reaproveitamento de código, e permitem que haja pulos de uma linha de código para outra muito a frente ou atrás, não sendo, portanto, necessária uma execução sequencial durante todo o tempo. Na maioria das vezes, tais instruções são utilizadas em laços de repetições (\textit{loops}) e em comparações (isto é, desvios condicionais). %\textbf{CITAR INSTRUÇÕES DE REPETIÇÃO} 

Sua utilização é muito importante, visto que somente essas instruções é possível reaproveitar partes de códigos em mais de um contexto e momento. Como exemplo disso, pode-se reutilizar qualquer procedimento implementado em uma linguagem de alto nível, tal como C ou \py{}. Esse procedimento é definido como uma parte de código que executa uma sequência de funcionalidades específicas que podem ser utilizadas várias vezes durante a execução do programa, com a finalidade de evitar que a mesma funcionalidade seja escrita e armazenada na memória mais de uma vez. Com isso, diz-se que sempre que uma outra função precisar executar as mesmas linhas de código mais de uma vez, ela irá "chamar" o procedimento que descreve essas linhas, em uma linha de código apenas, sem a necessidade de reescrever tudo o que está dentro da função chamada novamente.

Logo, é possível olhar e entender o funcionamento descrito por meio de uma linguagem de alto nível com certa simplicidade, porém, como se está trabalhando com o código \textit{Assembly} da linguagem \textit{Python}, é preciso entender como essa simples chamada irá resultar na execução de uma função e, depois, retornar de onde parou. 

%Para explicar isso, começar-se com um simples exemplo de um fluxo de repetição (\textit{while}). Quando escreve-se no algoritmo \textit{Python} que uma sequência de código irá executar repetidamente enquanto uma variável "X", por exemplo, estiver com seu valor entre 0 e 10, incrementando sempre o valor em uma unidade, evita-se de escrever dez vezes o mesmo trecho de código. Então, na primeira execução, o valor de "X" é comparado com o valor final (dez), para verificar se esse já foi atingido ou não. Caso não tenha sido, ir-se-á passar para a próxima linha de código e começará a executar o \textit{loop} pela primeira vez. Ao chegar no final da sequência de código, haverá um pulo para a linha inicial do \aloop{}, onde a variável "X" é carregada da memória para a pilha, juntamente com a constante 10. Nesse pulo, o valor que define a linha atual que o processador está lendo (contador de programa - PC) será substituído pelo valor referente ao da primeira instrução da estrutura de repetição. Então, se inicia novamente o fluxo até que chegue o número final alvo, neste caso 10.

%Supondo então que o valor alvo já foi atingido e o contador de programa está apontando para a instrução de comparação. Então, a instrução de comparação irá resultar em falso, já que será feita a comparação do valor atual de "X", que não é menor que 10. Como o valor de "X", agora, é igual a 10, o resultado da comparação será falso. Obtendo esse resultado, não é possível simplesmente continuar executando a linha de código imediatamente após a comparação. É necessário, então, um pulo para fora do \textit{loop}. Então, é feito um pulo que tem como alvo a linha de código imediatamente após o final do \textit{loop}. Tal linha deve ter sido salva antes de iniciar-se o \textit{loop} e, na maioria das vezes, esse pulo é realizado com a instrução JUMP\_FORWARD. Os detalhes mais específicos sobre as implementações dessa categoria de instruções será abordado na seção \ref{def_inst_esc}.

Os pulos inseridos em um \aloop{} foram utilizados como exemplo para explicar o funcionamento de duas instruções de pulos diferentes e a necessidade deles para que trechos de código sejam reaproveitados. Então, em resumo, um pulo seria a troca do valor do \pc{} para o valor referente ao início de um procedimento e, após, para o valor referente à instrução imediatamente após a chamada do procedimento. Neste caso, diferentemente do caso de um \textit{loop}, em que não salva-se o valor de \pc{} anterior ao início do \aloop{}, deve-se salvar o valor de \pc{} anterior como sendo a linha de código logo após a chamada do procedimento. Então, após chegar na última linha do procedimento, deve-se executar um pulo que leve o \pc{} de volta para a linha de código que foi salva previamente. 

As instruções escolhidas da ISA da \pvm{} para tratar de desvios neste trabalho são as seguintes:

\begin{description}
	\item[POP\_JUMP\_IF\_FALSE:] é a instrução de desvio condicional responsável por executar um pulo após uma comparação que obtém um resultado falso. Pode ser utilizada, por exemplo, em uma saída de \textit{loop}, onde o resultado da comparação será falso.
	\item[POP\_JUMP\_IF\_TRUE:] é a instrução de desvio condicional responsável por executar um pulo após uma comparação que obtém um resultado negativo. Ela é comumente utilizada para a execução de um \textit{loop} que realiza a comparação após a execução do código interno, diferentemente de um \textit{loop} \textit{while} que a executa antes. Ao utilizar um \textit{loop} como comparação após a execução, precisa-se voltar para o início caso a comparação seja verdadeira.
	\item[JUMP\_FORWARD:] é a instrução de desvio incondicional capaz de incrementar o valor de PC (\textit{program counter} - \pc) com um valor 'DELTA' determinado. Então, se o 'DELTA' for 10 e PC estiver com o valor 7, ao utilizar esta instrução, o PC passará a ter o valor 17.
	\item[JUMP\_ABSOLUTE:] é a instrução de desvio incondicional capaz de definir livremente o valor de PC. Ela é utilizada para uma chamada de função, por exemplo, em que o valor de PC deverá assumir o endereço da rotina a ser executada. 
\end{description}

\subsection{Comparações}

Os comandos no \py{} responsáveis por fazer comparações entre dois elementos são utilizadas quando se precisa tomar uma decisão dentro do algoritmo e gerar resultados diferentes dependendo de cada situação. Elas são conhecidas como \textit{if}, \textit{elif} e \textit{else}. 

A primeira, \textit{if}, é a função básica da qual as outras duas dependem. Ela é chamada juntamente com um argumento, o qual é, necessariamente, uma afirmação lógica (maior que, menor que, igual ou ainda um valor que será sempre verdadeiro, tal como 1). Com o resultado dessa afirmação lógica sendo verdadeiro, acontece a execução do código previsto para essa opção, encontrado dentro da estrutura \textit{if}. Caso obtenha-se um resultado falso, é necessário, então, passar para o próximo passo de comparação. Vale lembrar que um \textit{if} pode ou não ser seguido de \textit{elif} ou \textit{else}. Uma chamada \textit{elif} define que determinada rotina deve ser executada caso a primeira comparação resulte falsa e mediante uma segunda comparação, que deve ser verdadeira. Já a chamada \textit{else} define que a rotina interna a ele deve ser executada caso nenhuma das comparações anteriores seja verdadeira, não precisando-se, portanto, executar uma nova comparação. Caso um \textit{if} não seja seguido por nada e obtendo-se resultado negativo para a comparação, o código contido no no corpo da comparação, que deveria ser executado caso ela fosse verdadeira, é ignorado e o algoritmo segue seu fluxo normal de execução. 

Já quando, após um \textit{if}, encontrase-se um \textit{elif}, significa que, caso a comparação do \textit{if} retorne um resultado falso, testar-se-á novamente, utilizando outra afirmação lógica. Uma chamada \textit{elif} também possui uma rotina de execução que será executada caso tal afirmação seja verdadeira. Caso a afirmação retorne como sendo falsa, o trecho código contido dentro da função é ignorado e passa-se a verificar a existência de outro \textit{elif} ou um \textit{else}.

Caso seja encontrado um \textit{else} após um \textit{elif} ou até mesmo diretamente após um \textit{if}, entende-se que, caso todas as afirmações feitas anteriormente retornem como sendo falsas, deve-se executar o trecho de código presente no \textit{else}. Contudo, é importante salientar que não é necessária a existência de um \textit{else}, visto que alguns algoritmos pretendem executar determinada parte do código somente caso seja verdadeira e, caso contrário, esperam simplesmente ignorar o que foi escrito no corpo da comparação.


A \pvm{} prevê a utilização de uma função de comparação, chamada \textit{COMPARE\_OP}, que passará em seu argumento uma classe de comparação que será feita entre o \tos{} e o elemento encontrado logo abaixo dele. Aliado a essa comparação, é possível sempre encontrar uma instrução que já foi apresentada anteriormente na seção \ref{instr_pulos}. Essa instrução é comumente a \textit{POP\_JUMP\_IF\_FALSE}, podendo ainda ser a inversa dela, e, como já foi descrito aqui, somente funcionará caso a operação anterior a ela retorne um resultado falso. Essa instrução é utilizada para, caso a afirmação feita na comparação retorne como sendo falsa, exista a possibilidade de ignorar o código presente no interior da chamada \textit{if} (em alto nível) e que, em baixo nível, se encontrará logo após o pulo condicional. Após o pulo, existe o conjunto de instruções que deve ser executado caso a comparação seja verdadeira.

\subsection{Operações aritméticas}
\label{op-arit}

Finalmente, o princípio de operações aritméticas utilizado para a \vm{} da linguagem \textit{Python} dispõe de instruções binárias, como são chamadas, que executam cálculos utilizando dois operandos \cite{Dubois1996}. Para executar uma instrução deste tipo, é necessário que os dois operandos alvos estejam presentes na pilha e, especificamente, nas duas posições superiores dela.

Tendo em vista que já foram executados os \textit{loads} necessários e que os operandos se encontram nas suas corretas posições na pilha, chama-se uma das instruções responsáveis por cálculos. Falar-se-á sobre as instruções responsáveis pelos cálculos ao final desta subseção. É importante destacar que todas as operações aritméticas ocorrem sobre números inteiros positivos nesta proposta, haja vista sua baixa complexidade. 

Como o código \as{} de um algoritmo, em uma situação normal, é definido e montado inteiramente pelo compilador, baseado no que foi escrito pelo programador, cabe a ele também a função de entender o que foi escrito em alto nível e o que o usuário programador deseja obter de resultado, com base no que foi digitado. Na maioria das vezes, as equações matemáticas que são adicionadas em um algoritmo dispõem de mais de dois operandos, fazendo com que se torne menos evidente o que e como deverá ser feito tal cálculo na \vm{}, tendo em vista que o conjunto de instruções da \pvm{} só contém instruções de operações entre dois elementos.

Para resolver tal problema, é necessário entender que cada equação matemática necessita de um conhecimento prévio sobre prioridades de solução para que gere o resultado correto e esperado. Então, independentemente da ordem em que as operações matemática foram escritas na equação de alto nível, é necessário respeitar as prioridades. Quando as instruções escritas em alto nível são enviadas ao compilador para serem convertidas em um código \as{}, é tarefa deste analisar as prioridades e montar a sequência de código de forma que o resultado final seja exatamente o esperado pelo usuário. 

Um exemplo de uma equação matemática simples que necessita respeitar a prioridade de operações é uma soma seguida de uma multiplicação, nessa ordem e sem a presença de parênteses, tal como \(val = val1 + val2 * val3\). Percebe-se que a soma está sendo apresentada antes da multiplicação e, ignorando as prioridades, intuitivamente resolver-se-ia a soma antes e, após, a multiplicação. Contudo, resolver a operação desse modo resultaria em um erro no resultado final. Então, sabendo que uma operação de multiplicação possui maior precedência que uma operação de soma, deve-se executar a multiplicação primeiro. A execução de uma operação similar foi apresentada na Figura \ref{img_exemplo_prioridades}, apresentada na subseção \ref{manipulacao_dados}, porém com objetivo em mostrar a ordem em que os dados são carregados para a pilha.

Seguindo as prioridades e utilizando o exemplo acima, pode-se esperar que um compilador execute a operação de multiplicação antes da operação de soma. E, como são esperados que existam três operandos distintos, o compilador executa uma operação de carregamento para a pilha (\textit{load}) em todos os operandos. Tal operação deve ser feita na ordem inversa à ordem de prioridade, fazendo com que os operandos na multiplicação fiquem no \tos{} e na posição logo abaixo. Como os operandos da soma são o resultado da multiplicação e um valor, definido no exemplo por \textit{val1}, pode-se esperar que o primeiro \textit{load}, feito no inicio da execução, seja na variável \textit{val1}, que se encontrará na posição mais abaixo na pilha. Assim, após realizar-se a multiplicação, ter-se-á que o valor do seu resultado presente no \tos{} e, na segunda posição, o valor de \textit{val1}. Logo, é possível executar uma soma sem que seja necessária nenhuma outra operação de \textit{load} ou \textit{store}.

Quanto ao resultado de uma operação aritmética, tem-se que o resultado estará no novo \tos{}. Isso acontece porque sempre que um dado é carregado da pilha, ou seja, utilizado, ele é automaticamente excluído da mesma. Assim sendo, em uma operação aritmética simples, tendo \textit{val1} e \textit{val2} no \tos{} e na posição logo abaixo dele, respectivamente, exclui-se \textit{val1} e, após, exclui-se \textit{val2}. Quando o resultado é obtido, salva-se seu valor no novo \tos{}, que estará localizado exatamente na posição onde estava \textit{val2}. A Equação \ref{eq_tos} apresenta como são feitas as alocações da pilha. Considere que \textit{TOS} é o \tos{} e \textit{TOS1} é a posição logo abaixo.

\begin{equation} \label{eq_tos}
	TOS1 = TOS1 + TOS
\end{equation}

Observe ainda que, conforme a Equação \ref{eq_tos} mostra, o \tos{} se posiciona como sendo o segundo operando de uma operação. Em uma operação de adição, como a do exemplo, a ordem não importa, pois o resultado será o mesmo de qualquer forma. Já em operações de subtração e divisão, tem-se resultados completamente diferentes com a troca dos operandos de lugar. Então, considere uma operação entre \(r = val1 / val2\). Para que ela funcione corretamente, é necessário carregar \textit{val1} para a pilha e, após, \textit{val2}. Nesse caso, a simples inversão da ordem de carregamento dos dois operandos resultaria em um erro enorme.

As instruções \textit{Assembly} responsáveis por executar operações aritméticas na linguagem \textit{Python} são:

\begin{enumerate}
	\item[BINARY\_ADD]: executa uma operação de soma entre o TOS e a segunda posição da pilha.
	\item[BINARY\_SUBTRACT]: executa uma operação de subtração entre o TOS e a segunda posição da pilha.
	\item[BINARY\_MULTIPLY]: executa uma operação de multiplicação dentre o TOS e a segunda posição da pilha.
	\item[BINARY\_DIVIDE]: executa uma operação de divisão entre o TOS e a segunda posição da pilha.
	%\item[INPLACE\_ADD]: \textbf{FALTA EXPLICAÇÃO}
\end{enumerate}

\section{Formato das instruções da \pvm{}} % talvez trocar para "INSTRUÇÕES DA \pvm{}"
\label{rf_modos_enderecamento}
A linguagem \textit{Python}, possuindo uma máquina virtual, necessita também de um método de endereçamento para que ela consiga funcionar corretamente. Para isso, foi definido pelo desenvolvedor e criador da linguagem que cada endereço da \pvm{} deveria conter 2 \textit{bytes} (ou 16 \textit{bits}). 

Então, quando uma instrução buscada na memória de instruções e lida pelo decodificador, são acessados os 16 \textit{bits} que formam a instrução. A divisão para esses 2 \textit{bytes} é que o primeiro \textit{byte} seja responsável por armazenar o \textit{OpArg} da instrução. Isso significa que o primeiro \textit{byte} da instrução é responsável por apresentar o argumento que será passado para a instrução chamada. Sobre o exemplo anterior, onde é feito um carregamento de uma constante para o topo da pilha, o argumento desta instrução seria o valor da constante expresso em código binário e utilizando os 8 primeiros \bis{} do endereço. O autor \cite{insidePVM} utiliza, em seu livro, a nomenclatura \textit{OpArg} e \textit{OpCode} para se referir ao argumento e ao código da instrução. Tal abreviação deriva-se da junção das palavras \textit{operation} e \textit{argument} ou \textit{code}, que em uma tradução livre, resultam em argumento da operação e código da operação.

Já os 8 \textit{bits} menos significativos, ou seja, mais à direita, são responsáveis por definir o tipo de instrução que será executada. Apenas lendo essa sequência de \textit{bits}, é possível saber qual instrução será executada, por exemplo, a instrução \textit{LOAD\_CONST}. A esse segundo \textit{byte}, atribui-se o nome de \textit{opcode}.

É importante lembrar que, para algumas instruções, o primeiro \textit{byte} não é utilizado. Isso acontece porque algumas instruções não necessitam utilizar um argumento, pois executam uma funcionalidade específica e independente de qualquer entrada externa. Um exemplo de instrução que não necessita de argumento em sua chamada é a \textit{BINARY\_ADD}, que executa uma soma entre o \tos{} e a segunda posição. Assim, ao ser identificado o \textit{opcode} que chama tal instrução, ignora-se o segundo \textit{byte} do endereço e segue-se para a execução. 

A Figura \ref{img_endCode} apresenta o formato de uma instrução \textit{Python}, contendo o \textit{oparg} primeiro, até o \textit{bit} número 7, e o \textit{opcode} a partir do \textit{bit} número 8 até o final do argumento. 
\begin{figure}[htp]
\centering
\includegraphics{images/bytecodeFormat.png}
\caption{Formato de um endereço binário de 2 \textit{bytes}, retirada do livro \cite{insidePVM}}
\label{img_endCode}
\end{figure}

Os endereços da linguagem \textit{Python} são criados e definidos pelo próprio compilador e, ao serem executados em um processador, devem ser salvos na memória de instruções. O compilador, ao ler o código de alto nível e interpretá-lo, monta os endereços, definindo \textit{OpCode} e \textit{OpArg}. Então, cabe ao compilador atribuir argumentos às instruções de modo que tudo possa funcionar. 

\subsection{\textit{OpArg Python}}

A primeira parte de um endereço \textit{Python}, onde está contido o arqumento da instrução, contém 8 \textit{bits} e é utilizada para mostrar ao sistema um endereço de memória, valor ou tipo de operação, o qual será utilizado pela instrução a ser executada. Todas as instruções possuem um espaço reservado para o argumento, porém, em algumas delas, esse espaço é simplesmente preenchido com qualquer valor, pois será ignorado. A essas instruções, atribui-se a característica de ter um argumento sem importância ("\textit{don't care}").

Quando o processador percebe que está executando uma instrução que necessita de um argumento, ele imediatamente o lê e passa para o componente responsável por manipulá-lo. Como o argumento pode ser uma constante, que será carregada diretamente para a pilha, um endereço de memória ou ainda uma definição de operação (utilizada pela instrução COMPARE\_OP), o decodificador deve ler o valor contido na primeira metade do endereço e conseguir passá-lo para o componente necessário, dependendo do \textit{OpCode} que foi lido. Por isso, todas as decisões sobre a utilização do argumento, assim como outras decisões dentro da execução, devem ser feitas dentro de um módulo de controle.

O campo argumento, então, é utilizado única e exclusivamente para que seja possível existir uma entrada de dados externa. Ao executar-se uma compilação de um algoritmo \textit{Python}, o próprio compilador já cria os endereços e, a eles, já adiciona os argumentos. Então, quando se precisa realizar uma comparação, por exemplo, o próprio compilador define o \textit{OpCode} de comparação, precedido por um argumento que define o tipo de operação a ser executada.

\subsection{\textit{OpCode Python}}

A segunda parte de um endereço \py{}, onde está contido o código de uma instrução que deverá ser executada, contém 8 \bis{}. Ela é responsável por apresentar ao módulo de controle o que deverá ser executado, para que, então, esse último decida o que será feito no processador. 

A leitura do \textit{OpCode} é feita juntamente com a leitura do \textit{OpArg}, contudo, esse último pode ser ignorado caso não seja necessário o seu uso. Já o primeiro é fundamental para qualquer instrução, já que o sistema jamais saberia qual instrução deveria executar caso ele não existisse. 

O \by{} responsável pelo código de instrução define, conforme o exemplo anterior, que a instrução que deverá ser executada é a COMPARE\_OP e que o seu argumento deverá ser utilizado como uma entrada do controle, por exemplo, para que esse possa indicar o tipo de operação de comparação que deverá ser feita na unidade lógica aritmética. 