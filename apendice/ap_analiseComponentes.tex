\section{Análise de requisitos para a arquitetura}
\label{a_requisitos}

Após realizadas as análises sobre quais serão as instruções a serem implementadas, inicialmente, na arquitetura, é preciso projetar a arquitetura de forma que consiga atender a todos os requisitos de cada instrução.

Para iniciar tal análise, foram separadas em diversas subseções os diferentes tipos de instruções, tais como foram separadas na subseção \ref{def_inst_esc}. Isso se deve ao fato de que analisar a arquitetura como um todo, em uma só subseção, é inviável, visto a quantidade de informações que precisam ser apresentadas.

\subsection{Conceitos básicos}
\label{a_requisitos_basicos}

Antes de iniciar a análise das instruções propriamente ditas, é necessário que a arquitetura consiga suportar a entrada e, ainda, consiga percorrer através delas. Para isso, é preciso que conceitos básicos de execução de algoritmos sejam analisados. %\textbf{CITAR REFERENCIA DE EXECUÇÃO DE ALGORITMOS PC+1} 

Ao executar-se um algoritmo, as instruções \textit{Assembly} são salvas em uma memória específica para elas e, então, são percorridas sequencialmente, podendo haver desvios (pulos) entre elas ou não. Assim, o primeiro componente que deve ser adicionado à arquitetura é uma memória de instruções, chamada de \textit{memInstr}. Ela será responsável por salvar os argumentos (\textit{OpArg}) e os códigos de instruções (\textit{OpCode}), tais como foram apresentados na seção \ref{rf_modos_enderecamento}. Então, cada posição de sua memória deverá receber uma instrução, juntamente com seu argumento (mesmo que ele seja dispensável, como nas instruções BINARY\_). Desta forma, torna-se necessário que cada bloco da memória de instruções possua 2 \bys{}, já que tanto \textit{OpCode} quanto \textit{OpArg} possuem 8 \bis{}.

Porém, para manter essa funcionalidade, serão necessários ainda três outros componentes. O primeiro deles, o qual será responsável por gerenciar qual será a instrução lida a cada momento, será um registrador de contador de programa, chamado de \textit{regPc}. Tal registrador irá apontar para o endereço na memória de instrução que está sendo executado a cada instante. Então, quando \textit{regPc} possuir como saída o valor binário referente ao decimal zero, indicará que a primeira posição na memória de instruções está sendo lida e, por conseguinte, sendo executada pela arquitetura. 

A cada instrução executada no processador, o valor de saída do \textit{regPc} será atualizado com a soma do valor um. Assim sendo, o programa irá ser executado sequencialmente. Contudo, existe a possibilidade de serem realizados pulos, que serão apresentados na subseção \ref{a_requisitos_jump}. Esses pulos substituirão o valor de \textit{regPc} por um valor passado nos seus argumentos, redirecionando, então, para a execução de uma instrução fora da ordem localmente adjacente.

O segundo componente responsável pela execução básica do programa é um registrador que salvará o tipo de instrução (\textit{OpCode}), contendo 8 \textit{bits}, que está sendo executado no momento. Tal registrador, chamado de \textit{regInstr}, irá receber um valor diretamente da memória de instruções e o passará diretamente para o controle, o qual será apresentado na seção \ref{projeto_control} e será responsável por tomar todas as decisões de execução necessárias. Esse valor de 8 \bis{} vem da segunda metade do endereço de 16 \bis{} contido no bloco da memória que está sendo lido no momento. 

O último componente apresentado nesta subseção é o registrador que salvará os argumentos das instruções executadas. Esse registrador, chamado de \textit{regArg}, manterá os valores dos argumentos estáveis para que possam ser utilizados a qualquer momento durante a execução de uma mesma instrução. Instruções como COMPARE\_OP e LOAD\_CONST utilizam seus argumentos em diferentes momentos. Logo, é necessário que o argumento se mantenha estável durante toda a execução de uma instrução. O \textit{regArg} receberá a outra metade do endereço vindo da \textit{memInstr}, o qual se referente aos primeiros 8 \bis{} do bloco de memória lido.

Então, os componentes básicos para que a arquitetura consiga executar códigos são uma memória de instruções, \textit{memInstr}, um registrador para o contador de programa, \textit{regPc}, e dois registradores para instruções e argumentos, \textit{regInstr} e \textit{regArg}, respectivamente. Com todos esses componentes básicos de execução, é possível, até agora, receber uma sequência de códigos \as{}, lê-los de uma memória e armazená-los durante a execução. Contudo, ainda falta uma unidade lógica aritmética, que adicionará a funcionalidade de avançar entre as instruções, através da execução de \(PC+1\).

A Figura \ref{img_analisebasicos} apresenta os componentes citados nessa subseção e que são utilizados o recebimento e leitura de instruções no processador. Nela, é possível perceber a memória de instruções (\textit{memInstr}) que possui uma entrada, que é o valor de PC, e duas saídas, que são o valor de \textit{OpCode} e \textit{OpArg}. Além da memória, existem três registradores, considerados simples, já que possuem uma entrada de dados, uma saída de dados e uma entrada de controle, chamada de "\textit{ctrl}" (que define o momento em que um registrador deverá armazenar o que está entrando através do pino de entrada). Contudo, ainda existe uma outra entrada em cada um deles, a qual não foi inserida na Figura, que recebe o valor referente ao \textit{clock} do processador. Os três registradores são, então, os registradores o de contador de programa (\textit{regPc}), o de argumento (\textit{regArg}) e o de instruções (\textit{regInstr}). 

\begin{figure}[htp]
\caption{Componentes utilizados o funcionamento básico do processador.}
\centerline{\includegraphics[scale=0.8]{images/analise_basicos.png}}
\fonte{Autor (2019)}
\label{img_analisebasicos}
\end{figure}


\subsection{Instruções de carga e armazenamento de dados}
\label{a_requisitos_dados}

O primeiro conjunto de instruções engloba as instruções responsáveis pelo gerenciamento de dados dentro da arquitetura. As instruções escolhidas para esta área, tal como foi dito anteriormente, foram: LOAD\_CONST, LOAD\_FAST, LOAD\_GLOBAL e STORE\_FAST.

Iniciando, então, uma análise de requisitos para essa área, percebe-se que serão necessárias, além da memória de instruções, apresentada na subseção \ref{a_requisitos_basicos}, mais duas memórias. A primeira delas, e igualmente importante à segunda, será a pilha. Dentro dela, serão encontrados todos os dados que estão em uso durante a execução de um algoritmo \textit{Python}. Logo, será possível encontrar no seu interior dados como operandos de uma operação aritmética iminente, dados que estão aguardando para serem salvos na memória e dados que estão entrando no sistema como constantes e ainda não foram salvos. A pilha tem como característica principal possuir 8 \bis{} em cada uma de suas palavras, contendo 256 posições de memória, que podem ser endereçadas com também 8 \bis{}.

Como tal componente é uma pilha, pressupõe-se que os dados que entraram por último sejam os primeiros a serem lidos. Este trabalho não abordará profundamente conceitos de pilha. Tais conceitos podem ser encontrados em \cite{Aho}.

Contudo, sabendo que a saída de uma pilha deverá ser sempre o último valor que entrou, ou seja, seu topo, é necessário que exista ponteiro que informe a posição de leitura na pilha a cada instante. Para isso, será necessária a utilização de um registrador de topo (posição ocupada pelo dado adicionado por último), chamado de \textit{regTos}, que estará diretamente conectado à entrada de endereços da pilha. Ele deve conter a mesma quantidade de \bis{} necessária para realizar o endereçamento da pilha, ou seja, 8 \bis{}. Sempre que for realizada uma entrada de dados, o valor presente nesse registrador deverá ser atualizado com o acrescimento de uma unidade, indicando que o topo foi modificado. Quando existir uma retirada de dados, o ponteiro deverá apontar para a posição logo abaixo do dado retirado, ou seja, dever-se-á subtrair uma unidade do valor de \textit{regTos}.

Além de uma pilha, é necessário que exista um componente que irá armazenar valores de entrada e de saída da pilha para que eles fiquem estáveis enquanto são utilizados por outros componentes ou salvos na pilha. Para tal finalidade, foi incluído o registrador de pilha, chamado de \textit{regPilha}, responsável por salvar dados que entrarão na pilha e dados que estão saindo da pilha. Esse registrador permite que os dados fiquem estáveis por tempo suficiente, permitindo que outros componentes ou a pilha realize as operações utilizando sua saída.

O \textit{regPilha} possui duas entradas e duas saídas, ambas com largura de 8 \bis{}. Na realidade, o registrador de pilha pode ser considerado a junção de dois registradores simples, porém foi definido que ele seria apenas um registrador duplo para melhor apresentação e utilização. O primeiro par de entrada e saída será utilizado para os dados que irão ser salvos na pilha, então, com um sinal de controle definido para escrita na pilha, a entrada de escrita (\textit{entrada\_write}) terá permissão para salvar seu valor na saída de escrita (\textit{saída\_write}). O dado escrito nessa saída terá como destino a entrada de escrita da pilha. A Figura \ref{img_analisedados}, que será apresentada e explicada na sequência, apresenta exatamente o que foi explicado aqui.

O outro par de pinos do \textit{regPilha} é utilizado para dados que estão saindo da pilha. Então, ao ler-se um dado da pilha, é necessário salvá-lo no \textit{regPilha} utilizando a saída de operandos, nome dado à esse pino. Tal pino terá como destino final as entradas de operandos da unidade lógica aritmética (ULA), que será abordada em detalhes na subseção \ref{a_requisitos_arith}, e a entrada de escrita na memória externa, que será abordada ainda nesta subseção.

Definidos os dois componentes responsáveis pelo pleno funcionamento do componente pilha (\textit{regPilha} e \textit{regTos}), passa-se então para a memória externa. Essa memória terá o mesmo funcionamento de uma memória comum, onde os dados serão salvos em um endereço específico dentro da memória e só poderão ser acessados, posteriormente, com a utilização do mesmo endereço. Para maiores informações sobre o funcionamento básico de uma memória, recomenda-se a leitura de \cite{Stallings2002}.

A memória externa possui como característica principal, assim como a pilha, o fato de estar sempre lendo um de seus endereços. Tendo, portanto, uma saída durante todo o período de execução, exceto quando não existe nenhum dado salvo na posição apontada pelo endereço. Porém, a escrita no seu interior depende de um sinal de controle específico que permitirá que ela exista na próxima borda de relógio (\textit{clock}), de modo idêntico ao funcionamento da pilha. Ela possui, assim como a pilha, largura de bloco de 8 \bis{} e 256 posições, que podem ser endereçadas com os 8 \bis{} recebidos como argumento em uma instrução de acesso a dados.

Contudo, juntamente com a memória, deverão existir dois componentes que manterão estáveis informações essenciais para o correto funcionamento da memória. O primeiro, chamado de registrador de endereço, \textit{regEnd}, é responsável por manter estável o endereço do bloco de memória que está sendo lido. Sua atualização é feita através da entrada do registrador de argumentos, \textit{regArg}, apresentado em detalhes na subseção \ref{a_requisitos_basicos}. O registrador \textit{regEnd} deve conter, assim como o registrador \textit{regArg}, 8 \bis{} de largura e sua funcionalidade pode ser comparada à do registrador de \tos{}, porém com atualização de seu valor sendo inteiramente feita pelo argumento recebido.

Além do \textit{regEnd}, dever-se-á existir um registrador semelhante ao \textit{regPilha}, o qual será responsável por manter estáveis dados lidos da memória e dados que serão escritos nela. Ele recebe o nome de \textit{regMemExt} e seu funcionamento é similar ao funcionamento do registrador de pilha, o qual possui dois pinos de entrada e dois de saída, divididos em pares. O par que permitirá a escrita na memória receberá dados diretamente do \textit{regPilha}. Já o par que permitirá a leitura de dados da memória passará os dados para o mesmo registrador, porém em outra entrada.

A Figura \ref{img_analisedados} apresenta todos os componentes utilizados para acesso de dados dentro do processador. Nela, aparecem os componentes pilha, memória externa (\textit{memExt}), registrador de pilha (\textit{regPilha}), registrador de endereço (\textit{regEnd}), registrador de \tos (\textit{regTos}) e o registrador de memória externa (\textit{regMemExt}). É possível ver, na imagem, todas as entradas e saídas previstas para esses componentes. É necessário destacar que aparecem os mesmos pinos de controle nos registradores \textit{regPilha} e \textit{regMemExt}, mas na realidade ambos os registradores possuem duas entradas de controle, uma para cada par. Logo, entenda-se "\textit{ctrl}" como sendo o necessário para controlar cada registrador, podendo ser mais de um pino ou um pino com largura maior.

\begin{figure}[htp]
\caption{Componentes utilizados para instruções de gerenciamento de dados.}
\centerline{\includegraphics[scale=0.8]{images/analise_dados.png}}
\fonte{Autor (2019)}
\label{img_analisedados}
\end{figure}


\subsection{Instruções de operações aritméticas e comparações}
\label{a_requisitos_arith}

As instruções responsáveis por operações aritméticas e comparações utilizam praticamente os mesmos componentes. Porém, a grande diferença entre elas é que cada uma salva o resultado em locais diferentes. 

O componente principal desta área é a unidade lógica aritmética (ULA), que será responsável por executar as operações propriamente ditas. Contudo, para que as operações consigam chegar à ULA e seus resultados serem armazenados, são necessários outros componentes auxiliares. 

Como as instruções responsáveis por operações aritméticas da linguagem \py{} sempre são executadas com dois operandos. Por esse motivo, em seus nomes, está a palavra "\textit{binary}", que pode ser livremente traduzida para "binário", indicando uma operação entre dois elementos. Isto posto, os dois primeiros componentes, responsáveis pelas entradas dos operandos a serem operados na ULA, são os registradores de operandos, \textit{regOp1} e \textit{regOp2}. Eles possuem ligações com as duas entradas de operandos do componente ULA. Suas finalidades são manter os valores que serão utilizados nos calculos da ULA estáveis até que o resultado seja salvo.

Isso acontece porque a unidade lógica não utiliza períodos de relógio para gerar resultados nem armazena nada em seu interior. Assim sendo, quando há uma mudança ou instabilidade na entrada da ULA, tal acontecimento reflete diretamente na sua saída. Por esse motivo, é de grande importância manter as entradas estáveis durante todo o período entre a entrada dos dados na ULA e o salvamento do resultado.

Também conectados à ULA, estão os componentes de saída. Eles somam, ao todo, três, sendo que um deles já foi apresentado na seção anterior. Começando pelo componente que já foi apresentado na subseção \ref{a_requisitos_dados}, tem-se o \textit{regPilha}, o qual é responsável por salvar o resultado de dados. Isso acontece porque o resultado da ULA em operações aritméticas é salvo diretamente na pilha. Logo, é possível aproveitar o mesmo componente para salvar diretamente na pilha, assim como ele também é aproveitado para outras funcionalidade que já foram mostradas.

O segundo componente, chamado de registrador de \textit{overflow} ou \textit{regOverflow}, é o registrador que salvará um sinal indicando se o resultado da ULA ultrapassou o número de \textit{bits} suportado pelo sistema ou não. Então, tem-se que a saída de resultados da ULA deve possuir o mesmo número de \textit{bits} que as entradas do componente, ou seja 8 \bis{}. Porém, operações como multiplicação e soma podem gerar valores que não podem ser salvos, visto que excedem esse valor. Quando é feita uma multiplicação em valores binários, o resultado possui o tamanho de \(t1 + t2\), sendo \textit{t1} o tamanho do primeiro operando e \textit{t2} o do segundo. Logo, em uma operação de multiplicação com dois operandos de mesmo tamanho, o resultado é um valor com o dobro do tamanho. 

Contudo, caso a metade mais significativa do resultado possua apenas zeros, eles podem ser descartados e a saída da ULA será do mesmo tamanho das entradas. Nesse caso, o valor salvo no \textit{regOverflow} será zero, pois o valor salvo como resultado não possuiu nenhuma alteração forçada pelo número de \textit{bits}. Já quando o resultado de uma operação multiplicação, por exemplo, possuir um valor 1 presente na metade mais significativa do valor, apenas a parte menos significativa será considerada. Logo, haverá uma alteração no resultado final forçada pela quantidade de \textit{bits}. Nesse caso, considera-se que houve um excesso de valores (\textit{overflow}) e é salvo, em \textit{regOverflow}, o valor 1. 

O último componente desta classe de instruções é o registrador responsável por salvar o resultado de uma comparação, sendo ele verdadeiro ou falso. Chamado de \textit{regComp}, tal registrador tem sua escrita ativa quando há a execução da instrução COMPARE\_OP e recebe 1 referente à uma comparação verdadeira e 0 a uma falsa. O uso desse registrador se faz necessário visto que a pilha não possui ligações com a unidade de controle, logo, as instruções de pulos, que serão vistas na subseção \ref{a_requisitos_jump}, não poderiam ser executadas. Consequentemente, a saída do componente \textit{regComp} precisa estar conectada ao controle.

A Figura \ref{img_analisearith} apresenta todos os componentes utilizados para a realização de operações aritméticas no processador. Os componentes nela presentes são a unidade lógica arimética (ULA), dois registradores de operandos (\textit{regOp1} e \textit{regOp2}), o registrador de comparação (\textit{regComp}) e o registrador de \textit{overflow} (\textit{regOverflow}).

\begin{figure}[htp]
\caption{Componentes utilizados para instruções que realizam operações aritméticas e comparações.}
\centerline{\includegraphics[scale=0.8]{images/analise_aritmeticas.png}}
\fonte{Autor (2019)}
\label{img_analisearith}
\end{figure}

\subsection{Instruções de pulos}
\label{a_requisitos_jump}

A classe de instruções responsáveis por executar pulos/desvios dentro do código \textit{Assembly} salvo na memória de instruções não necessita de nenhum componente específico para funcionar. Todas as operações realizadas por ela utilizam componentes que já foram citados nas subseções anteriores.

Então, para executar uma instrução que substitui o valor do registrador \textit{regPc} por seu argumento, tal como JUMP\_ABSOLUTE, utiliza-se a unidade lógica aritmética (ULA), que tem seu resultado ligado à entrada do registrador PC e sua entrada ligada, também, ao registrador de argumento. A seção \ref{projeto_arq} irá mostrar com mais detalhes as ligações necessárias para que se utilize os mesmos componentes para diferentes funções. Contudo, para se utilizar a ULA, precisa-se realizar uma operação lógica ou aritmética entre dois operandos. Como tem-se um valor que deverá substituir o valor de \textit{regPc}, a operação ideal a ser realizada na ULA é uma soma por zero. 

Em uma instrução onde se realiza um pulo controlado por um \textit{delta}, o qual seu valor será somado no valor de \textit{regPc} atual, utiliza-se também a ULA. Para isso, é necessário conectar a saída de \textit{regPc} à uma das entrada da ULA (que ela naturalmente já é conectada) e utilizar na outra entrada o valor que deverá ser somado ao PC, o qual virá do registrador \textit{regArg}. Após obter-se o resultado, ele é salvo em \textit{regPc} e a instrução é finalizada.

Nas instruções que necessitam de uma comparação anterior para serem executadas, utilizar-se-á o registrador de comparação. Tal registrador, ligado ao controle, o permitirá decidir se será realizada a substituição do valor de \textit{regPc} pelo valor do argumento da instrução ou não. Caso a substituição seja feita, ela ocorre exatamente como foi detalhado na explicação da instrução JUMP\_ABSOLUTE, nesta mesma seção. Caso ela seja ignorada, simplesmente soma-se o valor um ao valor de PC (PC+1) atual e segue-se executando as próximas instruções. As instruções que realizam pulos conforme o resultado de uma comparação são POP\_JUMP\_IF\_TRUE e POP\_JUMP\_IF\_FALSE.

Como dito anteriormente, para a realização de desvios não é necessário incluir nenhum novo componente, já que tais instruções utilizam componentes básicos e de operações aritméticas, apresentados nas Figuras \ref{img_analisebasicos} e \ref{img_analisearith}, respectivamente. 

\subsection{Instruções de chamada e retorno de funções}
\label{a_requisitos_funcoes}

As instruções responsáveis por chamar uma função e retornar da mesma são chamadas CALL\_FUNCTION e RETURN\_VALUE, respectivamente. Elas são de importantes quando se precisa reutilizar um trecho de código para mais de uma finalidade. A primeira, realiza uma chamada de função, salvando o valor de PC atual, incrementado em um, e realizando um desvio incondicional. Nela, ainda é preciso salvar o valor do ponteiro de \tos{} atual, visto que a chamada de uma função adiciona um bloco de dados na pilha, sendo necessário excluí-lo no retorno. Já a segunda obtém os valores salvos pela primeira, guarda o valor do topo atual da pilha. Após, retorna o valor de \textit{regPc} para PC+1, salvo anteriormente, e de \textit{regTos} para TOS+1, para que seja salvo um valor sem interferir nos dados já existentes na pilha. Após o retorno, o valor salvo do \tos{}, que era o topo do bloco da função na pilha, é salvo no topo da pilha atual, já sem o bloco.

Para melhor entendimento, pode-se utilizar um exemplo simples. A Figura \ref{img_analise_exemplo_funcoes} apresenta três pilhas listadas com suas letras. Em (a), pode-se perceber que existe um valor na primeira (e única) posição da pilha ocupada. Após, em (b), é chamada uma função que realiza uma operação entre os três valores carregados posteriormente, já dentro da função. No \tos{}, obtém-se um valor que é considerado o resultado da função. Quando a função é encerrada com a instrução RETURN\_VALUE, o valor presente no \tos{} é salvo no registrador de retorno de dados (\textit{regDataReturn}), o bloco da função, ou seja, a sequência de posições alocadas na pilha para receber os dados relativos a uma função, é excluído e esse mesmo valor retorna como sendo o valor do novo \tos{}. A pilha final, após a chamada e o retorno da função, pode ser vista na pilha (c). 

Vale lembrar que os valores não são fisicamente excluídos da pilha, somente são ignorados, pois para a arquitetura, os únicos valores que importam são os que estão abaixo do ponteiro que aponta para o \tos{}. Na Figura \ref{img_analise_exemplo_funcoes} os espaços aparecem em branco para melhor entendimento, mas na realidade o valores estão fisicamente lá, e só serão substituídos quando forem feitas novas escritas em suas posições.

\begin{figure}[htp]
\caption{Exemplo de comportamento de uma pilha ao ser manipulada por funções.}
\centerline{\includegraphics[scale=0.8]{images/analise_exemplo_funcoes.png}}
\fonte{Autor (2019)}
\label{img_analise_exemplo_funcoes}
\end{figure}

Então, para realizar todas essas operações, são necessários novos componentes na arquitetura. Necessita-se salvar os valores de \textit{regPc} e de \textit{regTos} antigos, logo, a ideia inicial seria utilizar um registrador. Porém, como uma linguagem como \py{} permite que sejam chamadas inúmeras funções, umas dentro das outras, um registrador somente conseguiria retornar para a função imediatamente anterior à chamada atual. 

Assim, fá-se necessário o uso de uma pilha, que conseguiria guardar na ordem correta todos os valores de retornos. Assim, foram adicionadas, como mostra a Figura \ref{img_analise_funcoes}, as pilhas de função (\textit{pilhaFuncao}) e retorno de TOS (\textit{pilhaTosRetorno}), que guardam \textit{regPc} e \textit{regTos}, respectivamente.

Como toda pilha, ela tem seu próprio indicador de topo. Logo, necessita um registrador para salvar esse indicador. Então, adiciona-se um registrador chamado \textit{regTosFuncao}. Ele indicará o topo das duas pilhas que foram adicionadas, visto que elas trabalham juntas e devem estar na mesma posição sempre para que estejam sincronizadas.

Para atualizar o indicador de \tos{} principal, que gerencia a pilha principal, utiliza-se a unidade lógica aritmética. Porém, como ela já é utilizada para diversos fins diferentes, optou-se por adicionar um somador/subtrator, que terá como única função atualizar o valor do registrador \textit{regTosFuncao}, incrementando-o ou decrementando-o conforme a unidade de controle indicar.

Como dito, a Figura \ref{img_analise_funcoes} apresenta todos os componentes necessários para o correto funcionamento das instruções CALL\_FUNCTION e RETURN\_VALUE. Nela, são apresentados os pinos de entradas e saídas de cada componente, assim como seus nomes abaixo.  

\begin{figure}[htp]
\caption{Componentes utilizados para instruções que permite chamada e retorno de funções.}
\centerline{\includegraphics[scale=0.8]{images/analise_funcoes.png}}
\fonte{Autor (2019)}
\label{img_analise_funcoes}
\end{figure}