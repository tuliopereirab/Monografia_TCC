A realização de testes, tanto de simulação utilizando o \textit{Modelsim}, quanto diretamente no FPGA com a ferramenta \textit{Quartus}, exige a criação de arquivos binários para inicializar a memória de instruções. Ou seja, um algoritmo \py{}, passado para código \as{}, precisa ainda ser convertido em código binário e escrito nos arquivos.

Os arquivos em questão, os quais serão abordados especificamente na Seção \ref{conv_arq}, são os \textit{.mem} e \textit{.mif}. Sendo utilizados, respectivamente, nas ferramentas \modelsim{} e \quartus{}. 

O principal objetivo da criação deste conversor, chamado de \textit{pyConv}, é agilizar a execução de algoritmos \py{} diretamente no processador. Simplificando, portanto, a execução dos testes e permitindo que algoritmos mais complexos sejam executados na arquitetura sem a necessidade de escrever código binário em cada uma das posições de memória.

O \textit{pyConv} tem ainda como objetivo evitar ao máximo a inicialização da memória com algoritmos que contenham erros. A verificação desses erros, que será assunto da Seção \ref{conv_erros}, permite a identificação de erros léxicos, sintáticos e até lógicos, os quais poderiam tornar algum sinal da arquitetura inválido (assunto da Seção \ref{errorMod}).

Além do que será apresentado sobre o \textit{pyConv} neste capítulo, sugere-se a verificação dos apêndices  \ref{diag_casos}, \ref{diag_seq} e \ref{diag_class} para análise dos diagramas de casos de uso, sequência e classes, respectivamente. Com eles é possível compreender, com maior facilidade, o funcionamento do conversor e como ele foi desenvolvido.

\section{Funcionalidades}
\label{conv_func}

O a ferramenta \textit{pyConv}, desenvolvida em C, recebe como entrada os códigos \as{} no mesmo formato gerado pelo compilador \py{}, utilizando a funcionalidade \textit{Disassembler}. 

Tais formatos, que já foram vistos no Capítulo \ref{ref-teorico}, definem uma instrução no formato "\textit{LOAD\_CONST [argumento]}", por exemplo. Essas instruções servem, então, de entrada para o conversor.

Esta seção apresentará como são feitos: 
\begin{itemize}
	\item O recebimento de instruções pelo conversor (subseção \ref{conv_func_instr}); 
	\item O gerenciamento de memória (subseção \ref{conv_func_mem}); e
	\item O menu de ajuda à compreensão (subseção \ref{conv_func_help}).
\end{itemize}

\subsection{Recebimento de instruções}
\label{conv_func_instr}

Ao ser inicializado, o \textit{pyConv} gera uma matriz que simula uma memória de instruções e passa a aguardar a entrada de instruções. Ao receber uma, verifica alguns erros que podem estar ligados a essa instrução, os quais serão abordados na Seção \ref{conv_erros}, e, caso tudo esteja correto, adiciona a instrução diretamente na palavra de memória da matriz.

A palavra de memória é a posição de memória que é apontada pelo ponteiro PC na arquitetura, então é de extrema importância que uma instrução seja digitada na posição correta. Então, para gerenciar isso, o próprio conversor já espera uma instrução indicando a posição de memória referente à memória física, conforme mostra a Figura \ref{img_conv_line}. Nela, é possível identificar que foi inserido uma instrução na posição zero e aguarda-se o próximo na posição um.

\begin{figure}[htp]
\caption{Indicação numérica da palavra de memória que está sendo escrita.}
\centerline{\includegraphics[scale=0.6]{images/conversor/img_conv_line.jpg}}
\fonte{Autor (2019)}
\label{img_conv_line}
\end{figure}

Então, com a palavra (ou palavras, no caso de instruções que recebem endereços) salva na matriz, retorna-se para a função inicial que espera uma nova instrução. A posição de memória é, então, atualizada para a próxima, conforme o tipo de instrução inserido anteriormente. Caso seja uma instrução que recebe endereços e, então, necessita de duas palavras de memória para funcionar, a linha atual recebe um incremento de 2, caso contrário, apenas 1.

Quando existe um desvio, é necessário que seja escrito na memória em uma posição fora de ordem. Para isso, dentro do \textit{pyConv}, existe o comando "\textit{line}", que permite que o conversor passe a escrever em uma linha diferente, indicada pelo usuário. Esse comando pode ser utilizado tanto para desvios quanto para corrigir erros de digitação cometidos anteriormente, reescrevendo uma posição. 

Ao final da inserção das instruções, utiliza-se o comando "\textit{quit}", que dispara uma verificação geral e final do algoritmo, explicada na subseção \ref{conv_erros_sim}, e então libera-se a escrita nos arquivos a serem gerados.

\subsection{Gerenciamento de memória}
\label{conv_func_mem}
A linguagem \py{} permite que existam variáveis no seu código de alto nível. Tais variáveis, em \hw{}, podem ser consideradas as posições da memória externa onde foram salvas. Em outras palavras, para criar-se uma variável em \hw{}, salva-se um valor na memória externa e o acessa sempre através do mesmo endereço utilizado.

Fazendo uma analogia com um algoritmo de alto nível, a variável \textit{resultado} recebe o endereço 12. Sempre que ela precisar ser acessada em alto nível, seu nome é digitado. Mas em \hw{}, seu endereço é inserido.

Então, como ficaria difícil para alguém que quer digitar um algoritmo \as{} para rodar na arquitetura ficar digitando os endereços de cada uma das variáveis, foi criada uma funcionalidade que permite atribuir nomes às variáveis. Tal funcionalidade é similar à utilizada em um algoritmo de alto nível.

Seu funcionamento baseia-se em uma matriz de variáveis e chaves de acesso. Ao realizar-se a inserção de uma instrução STORE\_FAST, utiliza-se como argumento uma chave (caracteres numéricos ou letras) que será salva na matriz juntamente com o endereço correspondente na memória externa. Sempre que se utilizar STORE\_FAST ou LOAD\_FAST com esta chave, o endereço será automaticamente adicionado juntamente com a instrução na memória de instruções.

Assim sendo, a manipulação de variáveis é facilitada em \hw{} por um sistema baseado na mesma manipulação em alto nível. Isso permite agilidade e rapidez na criação e carregamento de variáveis.

\subsection{Menu de ajuda}
\label{conv_func_help}
O \textit{pyConv}, por utilizar alguns atalhos para algumas instruções, tais como os códigos de operação de comparação (0 para \textit{igual}, 1 para \textit{menor que} e 2 para \textit{maior que}), possui um menu de ajuda para quem for utilizá-lo. 

Esse menu é acessado diretamente pela entrada de instruções, sendo necessário que a palavra \textit{"help"} seja digitada. Então, o sistema pedirá a instrução que se está buscando ajuda e mostrará as informações dela, tais como formato, descrição e informações adicionais que algumas instruções possam possuir. 

A Figura \ref{img_conv_help} apresenta um exemplo de informação apresentada pela função \textit{help} para a instrução COMPARE\_OP.

\begin{figure}[htp]
\caption{Apresentação das informações para a instrução COMPARE\_OP.}
\centerline{\includegraphics[scale=0.5]{images/conversor/img_conv_help.jpg}}
\fonte{Autor (2019)}
\label{img_conv_help}
\end{figure}

Além disso, o menu de ajuda é de extrema importância se for considerado o fato de que as instruções de entrada no \textit{pyConv} podem ser iguais ou diferentes às instruções de \as{} da linguagem \py{}. Ou seja, foram criados apelidos para as instruções \py{}, o que facilita a inserção de dados no conversor. Um exemplo disso é a instrução LOAD\_CONST, que recebe o apelido de \textit{lconst}. A Tabela \ref{img_conv_help_instr} apresenta a tabela de instruções e apelidos. 

\begin{table}[]
\caption{Lista de instruções e seus respectivos apelidos.}
\label{img_conv_help_instr}
\centerline{\begin{tabular}{|c|c|}
\hline
\textbf{Instrução}   & \textbf{Apelido} \\ \hline
LOAD\_CONST          & lconst           \\ \hline
LOAD\_FAST           & lfast            \\ \hline
STORE\_FAST          & sfast            \\ \hline
POP\_JUMP\_IF\_TRUE  & jtrue            \\ \hline
POP\_JUMP\_IF\_FALSE & jfalse           \\ \hline
JUMP\_FORWARD        & jfor             \\ \hline
JUMP\_ABSOLUTE       & jabs             \\ \hline
BINARY\_ADD          & badd             \\ \hline
BINARY\_SUBTRACT     & bsub             \\ \hline
BINARY\_MULTIPLY     & bmult            \\ \hline
BINARY\_DIVIDE       & bdiv             \\ \hline
BINARY\_AND          & band             \\ \hline
BINARY\_OR           & bor              \\ \hline
BINARY\_XOR          & bxor             \\ \hline
UNARY\_NOT           & unot             \\ \hline
COMPARE\_OP          & cop              \\ \hline
CALL\_FUNCTION       & cfunc            \\ \hline
RETURN\_VALUE        & rval             \\ \hline
\end{tabular}}
\fonte{Autor (2019)}
\end{table}


\section{Arquivos Gerados}
\label{conv_arq}

Como já foi dito anteriormente, são duas as ferramentas utilizadas para a implementação deste projeto em \hw{}. Cada uma delas possui um arquivo de inicialização da memória diferente, sendo o \modelsim{} possuindo um arquivo \mem{} (subseção \ref{conv_arq_mem}) e o \quartus{} um \mif{} (subseção \ref{conv_arq_mif}). 

Então, para facilitar a execução em abas as ferramentas, o conversor gera os dois formatos de arquivos e, como normalmente são gerados vários arquivos, é gerado ainda um arquivo de texto com as instruções escritas (subseção \ref{conv_arq_texto}).

\subsection{Arquivo \textit{.mem}}
\label{conv_arq_mem}
O primeiro deles, \mem{}, é importado diretamente para a memória reconhecida pelo \modelsim{} ao realizar-se uma simulação. Ele possui o formato de uma matriz \textit{[profundidade da memória] x 4}, considerando que a equação (\ref{eq_prof}) que descreve o valor \textit{profundidade de memória}, e recebe algumas informações de cabeçalho. Seus indices são expressos em hexadecimal e mostram a posição de memória da primeira palavra de cada linha.

\begin{equation}
\label{eq_prof}
profundidade\_memoria = \frac{2^{ADDR\_WIDTH}}{4}
\end{equation}

\begin{figure}[htp]
\caption{Exemplo de arquivo \textit{.mem}.}
\centerline{\includegraphics[scale=0.5]{images/conversor/img_conv_mem.jpg}}
\fonte{Autor (2019)}
\label{img_conv_mem}
\end{figure}

A Figura \ref{img_conv_mem} mostra um exemplo de arquivo \mem{} criado pelo \textit{pyConv}.

\subsection{Arquivo \textit{.mif}}
\label{conv_arq_mif}
Já o arquivo \mif{} é utilizado para se inicializar a memória no \quartus{}. Ele é automaticamente importado pela ferramenta e seu formato é simplesmente composto por linhas com uma palavra cada, apresentando, respectivamente, posição de memória, em decimal, e instrução, em binário.

A ferramenta \quartus{}, ao gerá-los, utiliza simplificações quando várias posições consecutivas possuem o mesmo valor binário. Essa simplificação é no formato: 

\begin{center}
\textit{[2..10]	:	0000000000000000;}
\end{center}

Isso significa que da posição 2 até a posição 10 todas as posições receberão o valor 0 em binário, contendo 16 \bis{} cada. A Figura \ref{img_conv_mif} apresenta um exemplo de arquivo \mif{} criado pelo conversor.

\begin{figure}[htp]
\caption{Exemplo de arquivo \textit{.mif}.}
\centerline{\includegraphics[scale=0.5]{images/conversor/img_conv_mif.jpg}}
\fonte{Autor (2019)}
\label{img_conv_mif}
\end{figure}

\subsection{Arquivo texto}
\label{conv_arq_texto}

O último arquivo, gerado apenas para suprir uma eventual necessidade de análise do que foi executado, é um arquivo de texto contendo todas as instruções em suas devidas posições. Ele se faz importante pois sempre que geram-se arquivos de testes e execução, são gerados vários. 

Alguns complexos, outros nem tanto, é necessário que todos eles possam ser lidos para que seja possível comparar o que foi executado e o que era esperado. Antes de existir um arquivo texto, era necessário ler a memória (em código binário) e decodificar cada uma das posições manualmente, algo que levava certo tempo.

\begin{figure}[htp]
\caption{Exemplo de arquivo texto.}
\centerline{\includegraphics[scale=0.5]{images/conversor/img_conv_arq_texto.jpg}}
\fonte{Autor (2019)}
\label{img_conv_arq_texto}
\end{figure}

O arquivo texto, basicamente, recebe o número da linha, a instrução e o argumento, quando este último existe. A Figura \ref{img_conv_arq_texto} apresenta um exemplo de um arquivo texto.

\section{Erros Verificados}
\label{conv_erros}

Após se implementar um algoritmo em alto nível, executa-se uma compilação. Tal ato permite que erros léxicos e sintáticos sejam identificados e, assim, evitados. Alguns erros lógicos previsíveis podem ser capturados pelo compilador e, então, podem evitar problemas futuros.

Tendo em vista essa funcionalidade, foram adicionadas duas camadas de verificação de erros neste projeto. A segunda, abordada na Seção \ref{errorMod} e implementada diretamente na unidade de controle física do processador, permite a identificação de erros que passaram pelo conversor e chegaram à arquitetura.

Como a ideia do projeto que é que os algoritmos executados na arquitetura sejam gerados pelo \textit{pyConv}, não é esperado que a camada de verificação de erros em \hw{} seja utilizada. Ela está presente apenas para a segurança do processador caso algum erro não seja encontrado pelo conversor ou algum usuário realize a criação dos arquivos de inicialização de memória manualmente.

Os erros verificados em \sw{} são, na sua maioria, os mesmos verificados em \hw{}. Em \sw{} são analisados tanto erros de digitação (subseção \ref{error_dig}) quanto erros lógicos previsíveis (subseção \ref{error_form}), que levam a arquitetura a funcionar em estado de erro. E ainda, para finalizar, existe uma verificação final (subseção \ref{conv_erros_sim}), onde são detectados erros lógicos de elevada complexidade.

\subsection{Erros de digitação}
\label{error_dig}

Quando o conversor está sendo executado e recebe uma instrução, essa instrução deverá ser verificada e reconhecida. Então, primeiramente, ela passa pela verificação do seu "nome", o qual deve corresponder exatamente ao gerado pela função \textit{Disassembler} do compilador \py{} ou com o apelido dela apresentado pela Tabela \ref{img_conv_help_instr}. Caso contrário, o conversor retorna um erro e ignora o que foi inserido.

O segundo passo de verificação é referente ao argumento. Para instruções de entrada de dados, como LOAD\_CONST, espera-se que o argumento possa ser escrito em 8 \bis{} e, portanto, seja um valor decimal positivo entre 0 e 255. Já para endereços, espera-se que o valor possa ser escrito com o número de \bis{} de endereçamento, o qual, conforme Seção \ref{estMod}, pode ser modificado facilmente e, portanto, deve ser modificado também no conversor (como também apresentado anteriormente, foi definido que os endereços para este documento sejam de 12 \bis{}, então os valores devem estar entre 0 e 4095).

Algumas instruções, contudo, não possuem argumento e, por isso, quando não há a entrada de argumento, a instrução inserida passa por uma verificação que indica se ela precisa ou não de argumento.

Ao escrever as instruções digitadas no arquivo de memória, sabe-se que todas as entradas salvas são correspondentes a instruções suportadas pelo conversor e pela arquitetura. Sendo assim, seus códigos binários já salvos serão digitados corretamente nos arquivos de inicialização de memória. As posições das entradas, no caso de instruções de desvios, por exemplo, que utilizam duas palavras, são também corretamente escritas nos arquivos (\textit{PC: instrução + parte do endereço; PC+1: restante do endereço}). 

\subsection{Erros lógicos previsíveis}
\label{error_form}

A verificação de erros lógicos é feita com o objetivo de evitar que nenhum componente entre em estado de erro. O erro mais comum, por exemplo, é fazer com que o valor de topo da pilha (TOS) se torne um valor negativo e, portanto, inválido. Isso ocorre quando executa-se uma leitura na pilha sem antes haver uma escrita. 

Então, o \textit{pyConv} possui uma variável de controle do topo da pilha, o qual é incrementado sempre que recebe uma instrução válida que adiciona algo à pilha e decrementado quando uma instrução retira algo da pilha. Com essa variável, é possível verificar, sempre que uma instrução de leitura da pilha for inserida, se ela pode ou não ser executada.

Um exemplo simples é qualquer uma das instruções BINARY\_, que necessitam de duas posições da pilha para serem lidas. Então, caso não haja, a instrução não será adicionada ao arquivo. Caso haja, será decrescido apenas 1 da variável da de controle, pois essa instrução retorna um resultado a ser no \tos{}. 

Seguindo a mesma teoria de prevenção de erro do ponteiro de \tos{}, ao ser inserida a função CALL\_FUNCTION, o topo da pilha de funções é incrementado e, com a instrução RETURN\_VALUE, decrementado. Assim, não é possível inserir a instrução RETURN\_VALUE sem antes inserir CALL\_FUNCTION. A correção desse erro é idêntica à utilizada no erro anterior, porém com outra variável.

Além desses erros, existe outro erro que pode estar ligado à instrução LOAD\_FAST. A verificação desse evita que um essa instrução seja executada com um endereço que não foi salvo anteriormente (com a instrução STORE\_FAST). Então, como tem-se uma matriz de variáveis, sempre que é inserida a instrução LOAD\_FAST, faz-se uma busca e, caso a variável inserida exista, a instrução é formalmente inserida no arquivo, caso contrário, sua inserção é negada.

Outro erro previsto está ligado às instruções de desvio condicional, as quais precisam de uma comparação prévia para que sejas executadas. Assim, sempre que for inserida a instrução COMPARE\_OP, uma variável de controle é ativada. Ela permite que haja a inserção de uma das instruções de desvio condicional (POP\_JUMP\_IF\_TRUE ou FALSE) quando digitada.

Somente depois de todas essas verificações de erros que uma instrução pode, finalmente, ser inserida na matriz que irá para o arquivo de memória.  


\subsection{Verificação Final de Erros}
\label{conv_erros_sim}

Quando se estava projetando a análise de todos os erros possíveis, foi percebido que alguns erros, por serem de elevada complexidade, não eram previsíveis e nem detectáveis durante as inserções de instruções. No entanto, era de grande importância que eles fosse detectados e não fossem passados para a arquitetura.

Percebeu-se, então, que o único jeito de detectar erros complexos seria executando o algoritmo escrito, por completo. Porém, sabendo que o objetivo deste conversor é evitar que um algoritmo contendo erros seja carregado para a arquitetura, como verificar a existência de erros complexos sem transferir erros para o processador?

A resposta para isso veio de trabalhos acadêmicos não publicados desenvolvidos pelo próprio autor deste documento durante aulas da graduação, os quais tinham por objetivo implementar um simulador de algum processador em \sw{}. Foi percebido que não existe melhor maneira de verificar erros do que simulando a arquitetura em \sw{}, criando, assim, uma verificação final.

Essa verificação final é executada após o comando \textit{quit}, onde já é esperado que todo o algoritmo esteja completo. Então inicia-se o simulador da arquitetura e uma a uma as instruções são executadas na ordem em que aparecem na matriz de instruções. 

O simulador, por sua vez, possui todos os sinais e componentes básicos e potencialmente problemáticos quando manipulados erroneamente. Tais componentes são os ponteiros PC, TOS e TOS\_função, dentre outros. 

Ao ser iniciado, o simulador executa uma instrução e retorna para o conversor o seu \textit{status} atual, que deve ser sempre zero. Ao retornar um valor negativo, o conversor finaliza o teste e ignora a criação dos arquivos de memória. O próprio simulador é responsável por gerar mensagens de erros, indicando o código de erro e sua explicação, conforme Tabela \ref{conv_erros_sim}.

\begin{table}[]
\caption{Lista de erros retornados pelo simulador.}
\label{conv_erros_sim}
\centerline{\begin{tabular}{|c|c|}
\hline
\textbf{CÓDIGO} & \textbf{DESCRIÇÃO}                                                                                                                                                       \\ \hline
-1              & Argumento contém letras e deveria conter apenas números.                                                                                                                 \\ \hline
-2              & Largura de dado incorreta.                                                                                                                                               \\ \hline
-3              & Largura de endereço incorreta.                                                                                                                                           \\ \hline
-4              & \begin{tabular}[c]{@{}c@{}}Ponteiro do topo da pilha ficará negativo. \\ Adicione algo na pilha antes de remover.\end{tabular}                                   \\ \hline
-5              & \begin{tabular}[c]{@{}c@{}}Ponteiro do topo da pilha ultrapassará limite superior. \\ Retire algo da pilha antes de adicionar algo.\end{tabular}                         \\ \hline
-6              & Endereço de memória está fora do intervalo esperado (0 a 4095).                                                                                                          \\ \hline
-7              & \begin{tabular}[c]{@{}c@{}}Ponteiro do topo da pilha de funções ultrapassará limite superior.\\ Execute 'RETURN\_VALUE' antes de utilizar 'CALL\_FUNCTION'.\end{tabular} \\ \hline
-8              & \begin{tabular}[c]{@{}c@{}}Ponteiro do topo da pilha de funções ficará negativo.\\ Utilize 'CALL\_FUNCTION' antes de 'RETURN\_VALUE'.\end{tabular}                       \\ \hline
-9              & \begin{tabular}[c]{@{}c@{}}Pilha não suporta as duas leituras exigidas. \\ Certifique-se que existam dois dados na pilha.\end{tabular}                                   \\ \hline
-10             & \textit{warning: Resultando com Overflow.}                                                                                                                               \\ \hline
-11             & \begin{tabular}[c]{@{}c@{}}Variável inexistente.\\ Utilize 'STORE\_FAST' para criá-la.\end{tabular}                                                                      \\ \hline
-12             & \begin{tabular}[c]{@{}c@{}}\textbf{SAÍDA: Um ou mais erros foram encontrados no simulador.} \\ \textbf{Instrução não executada.}\end{tabular}                                                                                         \\ \hline
-13             & \begin{tabular}[c]{@{}c@{}}Resultado da comparação inválido.\\ Execute uma comparação antes de um desvio condicional.\end{tabular}                                       \\ \hline
-14             & Valor do endereço fora do intervalo esperado (0 a 4095).                                                                                                                 \\ \hline
-15             & Soma entre PC atual e argumento da instrução ultrapassam valor máximo de 4095.                                                                                           \\ \hline
-16             & Valor de PC ficará acima do máximo suportado.                                                                                                                            \\ \hline
-17             & Instrução inválida.                                                                                                                                                      \\ \hline
-18             & \begin{tabular}[c]{@{}c@{}}Opção da instrução 'COMPARE\_OP' inválida.\\ Utilize: 0-\textgreater igual, 1-\textgreater menor que, 2-\textgreater maior que.\end{tabular}  \\ \hline
-20             & \textbf{\begin{tabular}[c]{@{}c@{}}SAÍDA: simulador retornou WARNING.\\ (instrução executada, porém o resultado pode ser inválido)\end{tabular}}                         \\ \hline
\end{tabular}}
\fonte{Autor (2019)}
\end{table}